{"version":3,"file":"core.modern.js","sources":["../src/constants.ts","../../../node_modules/tslib/tslib.es6.js","../src/graph/graph-links.ts","../src/graph/graph.ts","../src/graph/graph-decorators.ts","../src/utils/bounds.ts","../src/utils/buffer-utils.ts","../src/utils/color-utils.ts","../src/utils/file-utils.ts","../src/utils/image-utils.ts","../src/utils/math-utils.ts","../src/utils/logger.ts","../src/utils/uuid.ts","../src/properties/property.ts","../src/graph/graph-node.ts","../src/properties/extensible-property.ts","../src/properties/accessor.ts","../src/properties/animation.ts","../src/properties/animation-channel.ts","../src/properties/animation-sampler.ts","../src/properties/buffer.ts","../src/properties/camera.ts","../src/properties/extension-property.ts","../src/properties/property-links.ts","../src/properties/property-graph.ts","../src/properties/texture-info.ts","../src/properties/material.ts","../src/properties/mesh.ts","../src/properties/node.ts","../src/properties/primitive.ts","../src/properties/primitive-target.ts","../src/properties/scene.ts","../src/properties/skin.ts","../src/properties/texture.ts","../src/properties/root.ts","../src/document.ts","../src/extension.ts","../src/io/reader-context.ts","../src/io/reader.ts","../src/io/writer-context.ts","../src/io/writer.ts","../src/io/platform-io.ts","../src/io/node-io.ts","../src/io/web-io.ts"],"sourcesContent":["// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * Current version of the package.\n * @hidden\n */\nexport const VERSION = `v${PACKAGE_VERSION}`;\n\n/** @internal */\nexport const NAME = '@gltf-transform/core';\n\n/**\n * Interface allowing Accessor setter/getter methods to be used interchangeably with gl-matrix\n * arrays or with three.js math objects' fromArray/toArray methods. For example, THREE.Vector2,\n * THREE.Vector3, THREE.Vector4, THREE.Quaternion, THREE.Matrix3, THREE.Matrix4, and THREE.Color.\n *\n * @internal\n * @internal\n */\nexport interface ArrayProxy {\n\t/** Sets the value of the object from an array of values. */\n\tfromArray(array: number[]): ArrayProxy;\n\t/** Writes the value of the object into the given array. */\n\ttoArray(array: number[]): number[];\n}\n\n/**\n * 2-dimensional vector.\n * @hidden\n */\nexport type vec2 = [number, number];\n\n/**\n * 3-dimensional vector.\n * @hidden\n */\nexport type vec3 = [number, number, number];\n\n/**\n * 4-dimensional vector, e.g. RGBA or a quaternion.\n * @hidden\n */\nexport type vec4 = [number, number, number, number];\n\n// prettier-ignore\n/**\n * 3x3 matrix, e.g. an affine transform of a 2D vector.\n * @hidden\n */\nexport type mat3 = [\n\tnumber, number, number,\n\tnumber, number, number,\n\tnumber, number, number,\n];\n\n// prettier-ignore\n/**\n * 4x4 matrix, e.g. an affine transform of a 3D vector.\n * @hidden\n */\nexport type mat4 = [\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n];\n\n/** @hidden */\nexport type bbox = { min: vec3; max: vec3 };\n\n/** @hidden */\nexport const GLB_BUFFER = '@glb.bin';\n\n/**\n * Abstraction representing any one of the typed array classes supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArray = Float32Array | Uint32Array | Uint16Array | Uint8Array | Int16Array | Int8Array;\n\n/**\n * Abstraction representing the typed array constructors supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArrayConstructor =\n\t| Float32ArrayConstructor\n\t| Uint32ArrayConstructor\n\t| Uint16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Int8ArrayConstructor;\n\n/** String IDs for core {@link Property} types. */\nexport enum PropertyType {\n\tACCESSOR = 'Accessor',\n\tANIMATION = 'Animation',\n\tANIMATION_CHANNEL = 'AnimationChannel',\n\tANIMATION_SAMPLER = 'AnimationSampler',\n\tBUFFER = 'Buffer',\n\tCAMERA = 'Camera',\n\tMATERIAL = 'Material',\n\tMESH = 'Mesh',\n\tPRIMITIVE = 'Primitive',\n\tPRIMITIVE_TARGET = 'PrimitiveTarget',\n\tNODE = 'Node',\n\tROOT = 'Root',\n\tSCENE = 'Scene',\n\tSKIN = 'Skin',\n\tTEXTURE = 'Texture',\n\tTEXTURE_INFO = 'TextureInfo',\n}\n\n/** Vertex layout method. */\nexport enum VertexLayout {\n\t/**\n\t * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex\n\t * data may improve performance by reducing page-thrashing in GPU memory.\n\t */\n\tINTERLEAVED = 'interleaved',\n\n\t/**\n\t * Stores each vertex attribute in a separate buffer view. May decrease performance by causing\n\t * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.\n\t */\n\tSEPARATE = 'separate',\n}\n\n/** Texture channels. */\nexport enum TextureChannel {\n\tR = 0x1000,\n\tG = 0x0100,\n\tB = 0x0010,\n\tA = 0x0001,\n}\n\nexport enum Format {\n\tGLTF = 'GLTF',\n\tGLB = 'GLB',\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { GraphNode } from './graph-node';\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n *\n * @hidden\n * @category Graph\n */\nexport class Link<Parent extends GraphNode, Child extends GraphNode> {\n\tprivate _disposed = false;\n\tprivate readonly _listeners: (() => void)[] = [];\n\tconstructor(private readonly _name: string, private readonly _parent: Parent, private _child: Child) {\n\t\tif (!_parent.canLink(_child)) {\n\t\t\tthrow new Error('Cannot link disconnected graphs/documents.');\n\t\t}\n\t}\n\n\t/** Name. */\n\tgetName(): string {\n\t\treturn this._name;\n\t}\n\n\t/** Owner node. */\n\tgetParent(): Parent {\n\t\treturn this._parent;\n\t}\n\n\t/** Resource node. */\n\tgetChild(): Child {\n\t\treturn this._child;\n\t}\n\n\t/**\n\t * Sets the child node.\n\t *\n\t * @internal Only {@link Graph} implementations may safely call this method directly. Use\n\t * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n\t */\n\tsetChild(child: Child): this {\n\t\tthis._child = child;\n\t\treturn this;\n\t}\n\n\t/** Destroys a (currently intact) link, updating both the graph and the owner. */\n\tdispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis._disposed = true;\n\t\tthis._listeners.forEach((fn) => fn());\n\t\tthis._listeners.length = 0;\n\t}\n\n\t/** Registers a listener to be invoked if this link is destroyed. */\n\tonDispose(fn: () => void): this {\n\t\tthis._listeners.push(fn);\n\t\treturn this;\n\t}\n\n\t/** Whether this link has been destroyed. */\n\tisDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n}\n","import { Link } from './graph-links';\nimport { GraphNode } from './graph-node';\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n *\n * @hidden\n * @category Graph\n */\nexport class Graph<T extends GraphNode> {\n\tprivate _emptySet: Set<Link<T, T>> = new Set();\n\n\tprivate _links: Set<Link<T, T>> = new Set();\n\tprivate _parentRefs: Map<T, Set<Link<T, T>>> = new Map();\n\tprivate _childRefs: Map<T, Set<Link<T, T>>> = new Map();\n\n\tprivate _listeners: { [event: string]: ((target: unknown) => void)[] } = {};\n\n\tpublic on(type: string, fn: (target: unknown) => void): this {\n\t\tthis._listeners[type] = this._listeners[type] || [];\n\t\tthis._listeners[type].push(fn);\n\t\treturn this;\n\t}\n\n\tpublic emit(type: string, target: T): this {\n\t\tfor (const fn of this._listeners[type] || []) fn(target);\n\t\treturn this;\n\t}\n\n\t/** Returns a list of all parent->child links on this graph. */\n\tpublic getLinks(): Link<T, T>[] {\n\t\treturn Array.from(this._links);\n\t}\n\n\t/** Returns a list of all links on the graph having the given node as their child. */\n\tpublic listParentLinks(node: T): Link<T, T>[] {\n\t\treturn Array.from(this._childRefs.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of parent nodes for the given child node. */\n\tpublic listParents(node: T): T[] {\n\t\treturn this.listParentLinks(node).map((link) => link.getParent());\n\t}\n\n\t/** Returns a list of all links on the graph having the given node as their parent. */\n\tpublic listChildLinks(node: T): Link<T, T>[] {\n\t\treturn Array.from(this._parentRefs.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of child nodes for the given parent node. */\n\tpublic listChildren(node: T): T[] {\n\t\treturn this.listChildLinks(node).map((link) => link.getChild());\n\t}\n\n\tpublic disconnectChildren(node: T): this {\n\t\tconst links = this._parentRefs.get(node) || this._emptySet;\n\t\tlinks.forEach((link) => link.dispose());\n\t\treturn this;\n\t}\n\n\tpublic disconnectParents(node: T, filter?: (n: T) => boolean): this {\n\t\tlet links = Array.from(this._childRefs.get(node) || this._emptySet);\n\t\tif (filter) {\n\t\t\tlinks = links.filter((link) => filter(link.getParent()));\n\t\t}\n\t\tlinks.forEach((link) => link.dispose());\n\t\treturn this;\n\t}\n\n\tpublic swapChild(parent: T, prevChild: T, nextChild: T): this {\n\t\tconst links = this._parentRefs.get(parent) || this._emptySet;\n\t\tArray.from(links)\n\t\t\t.filter((link) => link.getChild() === prevChild)\n\t\t\t.forEach((link) => {\n\t\t\t\tthis._childRefs.get(prevChild)!.delete(link);\n\n\t\t\t\tlink.setChild(nextChild);\n\t\t\t\tif (!this._childRefs.has(nextChild)) this._childRefs.set(nextChild, new Set());\n\t\t\t\tthis._childRefs.get(nextChild)!.add(link);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a link between two {@link GraphNode} instances. Link is returned\n\t * for the caller to store.\n\t * @param a Owner\n\t * @param b Resource\n\t */\n\tpublic link<A extends T>(name: string, a: A, b: null): null;\n\tpublic link<A extends T, B extends T>(name: string, a: A, b: B): Link<A, B>;\n\tpublic link<A extends T, B extends T>(name: string, a: A, b: B | null): Link<A, B> | null;\n\tpublic link<A extends T, B extends T>(name: string, a: A, b: B | null): Link<A, B> | null {\n\t\t// If there's no resource, return a null link. Avoids a lot of boilerplate in node setters.\n\t\tif (!b) return null;\n\n\t\tconst link = new Link(name, a, b);\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n\n\tprotected registerLink(link: Link<T, T>): Link<T, T> {\n\t\tthis._links.add(link);\n\n\t\tconst parent = link.getParent();\n\t\tif (!this._parentRefs.has(parent)) this._parentRefs.set(parent, new Set());\n\t\tthis._parentRefs.get(parent)!.add(link);\n\n\t\tconst child = link.getChild();\n\t\tif (!this._childRefs.has(child)) this._childRefs.set(child, new Set());\n\t\tthis._childRefs.get(child)!.add(link);\n\n\t\tlink.onDispose(() => this.unlink(link));\n\t\treturn link;\n\t}\n\n\t/**\n\t * Removes the link from the graph. This method should only be invoked by\n\t * the onDispose() listener created in {@link link()}. The public method\n\t * of removing a link is {@link link.dispose()}.\n\t * @param link\n\t */\n\tprivate unlink(link: Link<T, T>): this {\n\t\tthis._links.delete(link);\n\t\tthis._parentRefs.get(link.getParent())!.delete(link);\n\t\tthis._childRefs.get(link.getChild())!.delete(link);\n\t\treturn this;\n\t}\n}\n","/*\n\teslint-disable\n\t@typescript-eslint/no-explicit-any,\n\t@typescript-eslint/no-empty-function,\n\t@typescript-eslint/no-unused-vars,\n\t@typescript-eslint/explicit-module-boundary-types\n*/\n\nconst DECORATOR_PREFIX = '__';\n\n/**\n * @hidden\n * @category Graph\n */\nexport function GraphChild(target: any, propertyKey: string): void {\n\tObject.defineProperty(target, propertyKey, {\n\t\tget: function () {\n\t\t\treturn this[DECORATOR_PREFIX + propertyKey];\n\t\t},\n\t\tset: function (value) {\n\t\t\tconst link = this[DECORATOR_PREFIX + propertyKey];\n\n\t\t\tif (link && !Array.isArray(link)) {\n\t\t\t\t// console.log('[GraphChild] Disposing link: ' + propertyKey, link, value);\n\t\t\t\tlink.dispose();\n\t\t\t}\n\n\t\t\tif (value && !Array.isArray(value)) {\n\t\t\t\t// This listener handles dispose events for property Links. The addGraphChild\n\t\t\t\t// method handles the events for arrays of Links.\n\t\t\t\tvalue.onDispose(() => {\n\t\t\t\t\t// console.log('[GraphChild] Unassigning link: ' + propertyKey, link);\n\t\t\t\t\tthis[DECORATOR_PREFIX + propertyKey] = null;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// if (value) console.log('[GraphChild] Assigning link: ' + propertyKey, value);\n\t\t\tthis[DECORATOR_PREFIX + propertyKey] = value;\n\t\t},\n\t\tenumerable: true,\n\t});\n}\n\n/**\n * @hidden\n * @category Graph\n */\nexport function GraphChildList(target: any, propertyKey: string): void {}\n","import { transformMat4 } from 'gl-matrix/vec3';\nimport { PropertyType, bbox, mat4, vec3 } from '../constants';\nimport type { Mesh, Node, Scene } from '../properties';\n\n/**\n * Computes bounding box (AABB) in world space for the given {@link Node} or {@link Scene}.\n *\n * Example:\n *\n * ```ts\n * const {min, max} = bounds(scene);\n * ```\n */\nexport function bounds(node: Node | Scene): bbox {\n\tconst resultBounds = createBounds();\n\tconst parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n\n\tfor (const parent of parents) {\n\t\tparent.traverse((node) => {\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (!mesh) return;\n\n\t\t\t// Compute mesh bounds and update result.\n\t\t\tconst meshBounds = getMeshBounds(mesh, node.getWorldMatrix());\n\t\t\texpandBounds(meshBounds.min, resultBounds);\n\t\t\texpandBounds(meshBounds.max, resultBounds);\n\t\t});\n\t}\n\n\treturn resultBounds;\n}\n\n/** Computes mesh bounds in local space. */\nfunction getMeshBounds(mesh: Mesh, worldMatrix: mat4): bbox {\n\tconst meshBounds = createBounds();\n\n\t// We can't transform a local AABB into world space and still have a tight AABB in world space,\n\t// so we need to compute the world AABB vertex by vertex here.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION');\n\t\tif (!position) continue;\n\n\t\tlet localPos: vec3 = [0, 0, 0];\n\t\tlet worldPos: vec3 = [0, 0, 0];\n\t\tfor (let i = 0; i < position.getCount(); i++) {\n\t\t\tlocalPos = position.getElement(i, localPos) as vec3;\n\t\t\tworldPos = transformMat4(worldPos, localPos, worldMatrix) as vec3;\n\t\t\texpandBounds(worldPos, meshBounds);\n\t\t}\n\t}\n\n\treturn meshBounds;\n}\n\n/** Expands bounds of target by given source. */\nfunction expandBounds(point: vec3, target: bbox): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\ttarget.min[i] = Math.min(point[i], target.min[i]);\n\t\ttarget.max[i] = Math.max(point[i], target.max[i]);\n\t}\n}\n\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds(): bbox {\n\treturn {\n\t\tmin: [Infinity, Infinity, Infinity] as vec3,\n\t\tmax: [-Infinity, -Infinity, -Infinity] as vec3,\n\t};\n}\n","/**\n * # BufferUtils\n *\n * *Common utilities for working with ArrayBuffer and Buffer objects.*\n *\n * @category Utilities\n */\nexport class BufferUtils {\n\t/** Creates an ArrayBuffer from a Data URI. */\n\tstatic createBufferFromDataURI(dataURI: string): ArrayBuffer {\n\t\tif (typeof Buffer === 'undefined') {\n\t\t\t// Browser.\n\t\t\tconst byteString = atob(dataURI.split(',')[1]);\n\t\t\tconst ia = new Uint8Array(byteString.length);\n\t\t\tfor (let i = 0; i < byteString.length; i++) {\n\t\t\t\tia[i] = byteString.charCodeAt(i);\n\t\t\t}\n\t\t\treturn ia.buffer;\n\t\t} else {\n\t\t\t// Node.js.\n\t\t\tconst data = dataURI.split(',')[1];\n\t\t\tconst isBase64 = dataURI.indexOf('base64') >= 0;\n\t\t\treturn this.trim(Buffer.from(data, isBase64 ? 'base64' : 'utf8'));\n\t\t}\n\t}\n\n\t/** Encodes text to an ArrayBuffer. */\n\tstatic encodeText(text: string): ArrayBuffer {\n\t\tif (typeof TextEncoder !== 'undefined') {\n\t\t\treturn new TextEncoder().encode(text).buffer;\n\t\t}\n\t\treturn this.trim(Buffer.from(text));\n\t}\n\n\t/** Decodes an ArrayBuffer to text. */\n\tstatic decodeText(buffer: ArrayBuffer): string {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(buffer);\n\t\t}\n\t\treturn Buffer.from(buffer).toString('utf8');\n\t}\n\n\t/** Copies an ArrayBuffer from a Buffer's content. */\n\tstatic trim(buffer: Buffer): ArrayBuffer {\n\t\tconst { byteOffset, byteLength } = buffer;\n\t\treturn buffer.buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\t/**\n\t * Concatenates N ArrayBuffers.\n\t */\n\tstatic concat(buffers: ArrayBuffer[]): ArrayBuffer {\n\t\tlet totalByteLength = 0;\n\t\tfor (const buffer of buffers) {\n\t\t\ttotalByteLength += buffer.byteLength;\n\t\t}\n\n\t\tconst result = new Uint8Array(totalByteLength);\n\t\tlet byteOffset = 0;\n\n\t\tfor (const buffer of buffers) {\n\t\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\t\tbyteOffset += buffer.byteLength;\n\t\t}\n\n\t\treturn result.buffer;\n\t}\n\n\t/**\n\t * Pads an ArrayBuffer to the next 4-byte boundary.\n\t *\n\t * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n\t */\n\tstatic pad(arrayBuffer: ArrayBuffer, paddingByte = 0): ArrayBuffer {\n\t\tconst paddedLength = this.padNumber(arrayBuffer.byteLength);\n\n\t\tif (paddedLength !== arrayBuffer.byteLength) {\n\t\t\tconst array = new Uint8Array(paddedLength);\n\t\t\tarray.set(new Uint8Array(arrayBuffer));\n\n\t\t\tif (paddingByte !== 0) {\n\t\t\t\tfor (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n\t\t\t\t\tarray[i] = paddingByte;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array.buffer;\n\t\t}\n\n\t\treturn arrayBuffer;\n\t}\n\n\t/** Pads a number to 4-byte boundaries. */\n\tstatic padNumber(v: number): number {\n\t\treturn Math.ceil(v / 4) * 4;\n\t}\n\n\t/** Returns true if given ArrayBuffer instances are equal. */\n\tstatic equals(a: ArrayBuffer, b: ArrayBuffer): boolean {\n\t\tif (a === b) return true;\n\n\t\tif (a.byteLength !== b.byteLength) return false;\n\n\t\tconst view1 = new DataView(a);\n\t\tconst view2 = new DataView(b);\n\n\t\tlet i = a.byteLength;\n\t\twhile (i--) {\n\t\t\tif (view1.getUint8(i) !== view2.getUint8(i)) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","import { vec3, vec4 } from '../constants';\n\n/**\n * # ColorUtils\n *\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nexport class ColorUtils {\n\t/**\n\t * Converts sRGB hexadecimal to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic hexToFactor<T = vec3 | vec4>(hex: number, target: T): T {\n\t\thex = Math.floor(hex);\n\t\tconst _target = target as unknown as vec3;\n\t\t_target[0] = ((hex >> 16) & 255) / 255;\n\t\t_target[1] = ((hex >> 8) & 255) / 255;\n\t\t_target[2] = (hex & 255) / 255;\n\t\treturn this.convertSRGBToLinear<T>(target, target);\n\t}\n\n\t/**\n\t * Converts linear components to sRGB hexadecimal.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic factorToHex<T = vec3 | vec4>(factor: T): number {\n\t\tconst target = [...(factor as unknown as number[])] as unknown as T;\n\t\tconst [r, g, b] = this.convertLinearToSRGB(factor, target) as unknown as number[];\n\t\treturn ((r * 255) << 16) ^ ((g * 255) << 8) ^ ((b * 255) << 0);\n\t}\n\n\t/**\n\t * Converts sRGB components to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertSRGBToLinear<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] =\n\t\t\t\t_source[i] < 0.04045\n\t\t\t\t\t? _source[i] * 0.0773993808\n\t\t\t\t\t: Math.pow(_source[i] * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Converts linear components to sRGB components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertLinearToSRGB<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] = _source[i] < 0.0031308 ? _source[i] * 12.92 : 1.055 * Math.pow(_source[i], 0.41666) - 0.055;\n\t\t}\n\t\treturn target;\n\t}\n}\n","/**\n * # FileUtils\n *\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nexport class FileUtils {\n\t/** Extracts the basename from a path, e.g. \"folder/model.glb\" -> \"model\". */\n\tstatic basename(path: string): string {\n\t\tconst fileName = path.split(/[\\\\/]/).pop()!;\n\t\treturn fileName.substr(0, fileName.lastIndexOf('.'));\n\t}\n\n\t/** Extracts the extension from a path, e.g. \"folder/model.glb\" -> \"glb\". */\n\tstatic extension(path: string): string {\n\t\tif (path.indexOf('data:') !== 0) {\n\t\t\treturn path.split(/[\\\\/]/).pop()!.split(/[.]/).pop()!;\n\t\t} else if (path.indexOf('data:image/png') === 0) {\n\t\t\treturn 'png';\n\t\t} else if (path.indexOf('data:image/jpeg') === 0) {\n\t\t\treturn 'jpeg';\n\t\t} else {\n\t\t\treturn 'bin';\n\t\t}\n\t}\n}\n","import { vec2 } from '../constants';\nimport { BufferUtils } from './buffer-utils';\n\n/** Implements support for an image format in the {@link ImageUtils} class. */\nexport interface ImageUtilsFormat {\n\tmatch(buffer: ArrayBuffer): boolean;\n\tgetSize(buffer: ArrayBuffer): vec2 | null;\n\tgetChannels(buffer: ArrayBuffer): number | null;\n\tgetGPUByteLength?(buffer: ArrayBuffer): number | null;\n}\n\n/** JPEG image support. */\nclass JPEGImageUtils implements ImageUtilsFormat {\n\tmatch(buffer: ArrayBuffer): boolean {\n\t\tconst array = new Uint8Array(buffer);\n\t\treturn array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n\t}\n\tgetSize(buffer: ArrayBuffer): vec2 {\n\t\t// Skip 4 chars, they are for signature\n\t\tlet view = new DataView(buffer, 4);\n\n\t\tlet i: number, next: number;\n\t\twhile (view.byteLength) {\n\t\t\t// read length of the next block\n\t\t\ti = view.getUint16(0, false);\n\t\t\t// i = buffer.readUInt16BE(0);\n\n\t\t\t// ensure correct format\n\t\t\tvalidateJPEGBuffer(view, i);\n\n\t\t\t// 0xFFC0 is baseline standard(SOF)\n\t\t\t// 0xFFC1 is baseline optimized(SOF)\n\t\t\t// 0xFFC2 is progressive(SOF2)\n\t\t\tnext = view.getUint8(i + 1);\n\t\t\tif (next === 0xc0 || next === 0xc1 || next === 0xc2) {\n\t\t\t\treturn [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n\t\t\t}\n\n\t\t\t// move to the next block\n\t\t\tview = new DataView(buffer, view.byteOffset + i + 2);\n\t\t}\n\n\t\tthrow new TypeError('Invalid JPG, no size found');\n\t}\n\n\tgetChannels(_buffer: ArrayBuffer): number {\n\t\treturn 3;\n\t}\n}\n\n/**\n * PNG image support.\n *\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\nclass PNGImageUtils implements ImageUtilsFormat {\n\t// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\n\tstatic PNG_FRIED_CHUNK_NAME = 'CgBI';\n\tmatch(buffer: ArrayBuffer): boolean {\n\t\tconst array = new Uint8Array(buffer);\n\t\treturn (\n\t\t\tarray.length >= 8 &&\n\t\t\tarray[0] === 0x89 &&\n\t\t\tarray[1] === 0x50 &&\n\t\t\tarray[2] === 0x4e &&\n\t\t\tarray[3] === 0x47 &&\n\t\t\tarray[4] === 0x0d &&\n\t\t\tarray[5] === 0x0a &&\n\t\t\tarray[6] === 0x1a &&\n\t\t\tarray[7] === 0x0a\n\t\t);\n\t}\n\tgetSize(buffer: ArrayBuffer): vec2 {\n\t\tconst view = new DataView(buffer);\n\t\tconst magic = BufferUtils.decodeText(buffer.slice(12, 16));\n\t\tif (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n\t\t\treturn [view.getUint32(32, false), view.getUint32(36, false)];\n\t\t}\n\t\treturn [view.getUint32(16, false), view.getUint32(20, false)];\n\t}\n\tgetChannels(_buffer: ArrayBuffer): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * # ImageUtils\n *\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\nexport class ImageUtils {\n\tstatic impls: Record<string, ImageUtilsFormat> = {\n\t\t'image/jpeg': new JPEGImageUtils(),\n\t\t'image/png': new PNGImageUtils(),\n\t};\n\n\t/** Registers support for a new image format; useful for certain extensions. */\n\tpublic static registerFormat(mimeType: string, impl: ImageUtilsFormat): void {\n\t\tthis.impls[mimeType] = impl;\n\t}\n\n\t/**\n\t * Returns detected MIME type of the given image buffer. Note that for image\n\t * formats with support provided by extensions, the extension must be\n\t * registered with an I/O class before it can be detected by ImageUtils.\n\t */\n\tpublic static getMimeType(buffer: ArrayBuffer): string | null {\n\t\tfor (const mimeType in this.impls) {\n\t\t\tif (this.impls[mimeType].match(buffer)) {\n\t\t\t\treturn mimeType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Returns the dimensions of the image. */\n\tpublic static getSize(buffer: ArrayBuffer, mimeType: string): vec2 | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getSize(buffer);\n\t}\n\n\t/**\n\t * Returns a conservative estimate of the number of channels in the image. For some image\n\t * formats, the method may return 4 indicating the possibility of an alpha channel, without\n\t * the ability to guarantee that an alpha channel is present.\n\t */\n\tpublic static getChannels(buffer: ArrayBuffer, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getChannels(buffer);\n\t}\n\n\t/** Returns a conservative estimate of the GPU memory required by this image. */\n\tpublic static getMemSize(buffer: ArrayBuffer, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\n\t\tif (this.impls[mimeType].getGPUByteLength) {\n\t\t\treturn this.impls[mimeType].getGPUByteLength!(buffer);\n\t\t}\n\n\t\tlet uncompressedBytes = 0;\n\t\tconst channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.\n\t\tconst resolution = this.getSize(buffer, mimeType);\n\t\tif (!resolution) return null;\n\n\t\twhile (resolution[0] > 1 || resolution[1] > 1) {\n\t\t\tuncompressedBytes += resolution[0] * resolution[1] * channels;\n\t\t\tresolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n\t\t\tresolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n\t\t}\n\t\tuncompressedBytes += 1 * 1 * channels;\n\t\treturn uncompressedBytes;\n\t}\n\n\t/** Returns the preferred file extension for the given MIME type. */\n\tpublic static mimeTypeToExtension(mimeType: string): string {\n\t\tif (mimeType === 'image/jpeg') return 'jpg';\n\t\treturn mimeType.split('/').pop()!;\n\t}\n\n\t/** Returns the MIME type for the given file extension. */\n\tpublic static extensionToMimeType(extension: string): string {\n\t\tif (extension === 'jpg') return 'image/jpeg';\n\t\treturn `image/${extension}`;\n\t}\n}\n\nfunction validateJPEGBuffer(view: DataView, i: number): DataView {\n\t// index should be within buffer limits\n\tif (i > view.byteLength) {\n\t\tthrow new TypeError('Corrupt JPG, exceeded buffer limits');\n\t}\n\t// Every JPEG block must begin with a 0xFF\n\tif (view.getUint8(i) !== 0xff) {\n\t\tthrow new TypeError('Invalid JPG, marker table corrupted');\n\t}\n\n\treturn view;\n}\n","import { determinant, getRotation } from 'gl-matrix/mat4';\nimport { length } from 'gl-matrix/vec3';\nimport { mat4, vec3, vec4 } from '../constants';\nimport { GLTF } from '../types/gltf';\n\n/** @hidden */\nexport class MathUtils {\n\tpublic static identity(v: number): number {\n\t\treturn v;\n\t}\n\n\tpublic static eq(a: number[], b: number[]): boolean {\n\t\tif (a.length !== b.length) return false;\n\n\t\tconst eps = 10e-6;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (Math.abs(a[i] - b[i]) > eps) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static denormalize(c: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126:\n\t\t\t\treturn c;\n\t\t\tcase 5123:\n\t\t\t\treturn c / 65535.0;\n\t\t\tcase 5121:\n\t\t\t\treturn c / 255.0;\n\t\t\tcase 5122:\n\t\t\t\treturn Math.max(c / 32767.0, -1.0);\n\t\t\tcase 5120:\n\t\t\t\treturn Math.max(c / 127.0, -1.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\tpublic static normalize(f: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126:\n\t\t\t\treturn f;\n\t\t\tcase 5123:\n\t\t\t\treturn Math.round(f * 65535.0);\n\t\t\tcase 5121:\n\t\t\t\treturn Math.round(f * 255.0);\n\t\t\tcase 5122:\n\t\t\t\treturn Math.round(f * 32767.0);\n\t\t\tcase 5120:\n\t\t\t\treturn Math.round(f * 127.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\t/**\n\t * Decompose a mat4 to TRS properties.\n\t *\n\t * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcMat Matrix element, to be decomposed to TRS properties.\n\t * @param dstTranslation Translation element, to be overwritten.\n\t * @param dstRotation Rotation element, to be overwritten.\n\t * @param dstScale Scale element, to be overwritten.\n\t */\n\tpublic static decompose(srcMat: mat4, dstTranslation: vec3, dstRotation: vec4, dstScale: vec3): void {\n\t\tlet sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n\t\tconst sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n\t\tconst sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = determinant(srcMat);\n\t\tif (det < 0) sx = -sx;\n\n\t\tdstTranslation[0] = srcMat[12];\n\t\tdstTranslation[1] = srcMat[13];\n\t\tdstTranslation[2] = srcMat[14];\n\n\t\t// scale the rotation part\n\t\tconst _m1 = srcMat.slice();\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1[0] *= invSX;\n\t\t_m1[1] *= invSX;\n\t\t_m1[2] *= invSX;\n\n\t\t_m1[4] *= invSY;\n\t\t_m1[5] *= invSY;\n\t\t_m1[6] *= invSY;\n\n\t\t_m1[8] *= invSZ;\n\t\t_m1[9] *= invSZ;\n\t\t_m1[10] *= invSZ;\n\n\t\tgetRotation(dstRotation, _m1 as mat4);\n\n\t\tdstScale[0] = sx;\n\t\tdstScale[1] = sy;\n\t\tdstScale[2] = sz;\n\t}\n\n\t/**\n\t * Compose TRS properties to a mat4.\n\t *\n\t * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcTranslation Translation element of matrix.\n\t * @param srcRotation Rotation element of matrix.\n\t * @param srcScale Scale element of matrix.\n\t * @param dstMat Matrix element, to be modified and returned.\n\t * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n\t */\n\tpublic static compose(srcTranslation: vec3, srcRotation: vec4, srcScale: vec3, dstMat: mat4): mat4 {\n\t\tconst te = dstMat;\n\n\t\tconst x = srcRotation[0],\n\t\t\ty = srcRotation[1],\n\t\t\tz = srcRotation[2],\n\t\t\tw = srcRotation[3];\n\t\tconst x2 = x + x,\n\t\t\ty2 = y + y,\n\t\t\tz2 = z + z;\n\t\tconst xx = x * x2,\n\t\t\txy = x * y2,\n\t\t\txz = x * z2;\n\t\tconst yy = y * y2,\n\t\t\tyz = y * z2,\n\t\t\tzz = z * z2;\n\t\tconst wx = w * x2,\n\t\t\twy = w * y2,\n\t\t\twz = w * z2;\n\n\t\tconst sx = srcScale[0],\n\t\t\tsy = srcScale[1],\n\t\t\tsz = srcScale[2];\n\n\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\tte[1] = (xy + wz) * sx;\n\t\tte[2] = (xz - wy) * sx;\n\t\tte[3] = 0;\n\n\t\tte[4] = (xy - wz) * sy;\n\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\tte[6] = (yz + wx) * sy;\n\t\tte[7] = 0;\n\n\t\tte[8] = (xz + wy) * sz;\n\t\tte[9] = (yz - wx) * sz;\n\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\tte[11] = 0;\n\n\t\tte[12] = srcTranslation[0];\n\t\tte[13] = srcTranslation[1];\n\t\tte[14] = srcTranslation[2];\n\t\tte[15] = 1;\n\n\t\treturn te;\n\t}\n}\n","/**\n * # Logger\n *\n * *Logger utility class.*\n *\n * @category Utilities\n */\nclass Logger {\n\t/**\n\t * Log verbosity thresholds.\n\t */\n\tstatic Verbosity = {\n\t\t/** No events are logged. */\n\t\tSILENT: 4,\n\n\t\t/** Only error events are logged. */\n\t\tERROR: 3,\n\n\t\t/** Only error and warn events are logged. */\n\t\tWARN: 2,\n\n\t\t/** Only error, warn, and info events are logged. (DEFAULT) */\n\t\tINFO: 1,\n\n\t\t/** All events are logged. */\n\t\tDEBUG: 0,\n\t};\n\n\t/** Default logger instance. */\n\tpublic static DEFAULT_INSTANCE = new Logger(Logger.Verbosity.INFO);\n\n\t/** Constructs a new Logger instance. */\n\tconstructor(private readonly verbosity: number) {}\n\n\t/** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n\tdebug(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.DEBUG) {\n\t\t\tconsole.debug(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.INFO}. */\n\tinfo(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.INFO) {\n\t\t\tconsole.info(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.WARN}. */\n\twarn(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.WARN) {\n\t\t\tconsole.warn(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n\terror(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.ERROR) {\n\t\t\tconsole.error(text);\n\t\t}\n\t}\n}\n\nexport { Logger };\n","const ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\n\nconst previousIDs = new Set();\n\nconst generateOne = function (): string {\n\tlet rtn = '';\n\tfor (let i = 0; i < ID_LENGTH; i++) {\n\t\trtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n\t}\n\treturn rtn;\n};\n\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nexport const uuid = function (): string {\n\tfor (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n\t\tconst id = generateOne();\n\t\tif (!previousIDs.has(id)) {\n\t\t\tpreviousIDs.add(id);\n\t\t\treturn id;\n\t\t}\n\t}\n\treturn '';\n};\n","import { GraphNode } from '../graph';\nimport { PropertyGraph } from './property-graph';\n\nexport type PropertyResolver<T extends Property> = (p: T) => T;\nexport const COPY_IDENTITY = <T extends Property>(t: T): T => t;\n\n/**\n * # Property\n *\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); // → [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); // → texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); // → null\n * doc.listTextures(); // → [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); // → []\n * ```\n *\n * Reference:\n * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport abstract class Property extends GraphNode {\n\t/** Property type. */\n\tpublic abstract readonly propertyType: string;\n\n\tprivate _extras: Record<string, unknown> = {};\n\tprivate _name = '';\n\n\t/** @hidden */\n\tconstructor(protected readonly graph: PropertyGraph, name = '') {\n\t\tsuper(graph);\n\t\tthis._name = name;\n\t}\n\n\t/**********************************************************************************************\n\t * Name.\n\t */\n\n\t/**\n\t * Returns the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic getName(): string {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * Sets the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic setName(name: string): this {\n\t\tthis._name = name;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extras.\n\t */\n\n\t/**\n\t * Returns a reference to the Extras object, containing application-specific data for this\n\t * Property. Extras should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic getExtras(): Record<string, unknown> {\n\t\treturn this._extras;\n\t}\n\n\t/**\n\t * Updates the Extras object, containing application-specific data for this Property. Extras\n\t * should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic setExtras(extras: Record<string, unknown>): this {\n\t\tthis._extras = extras;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Graph state.\n\t */\n\n\t/**\n\t * Makes a copy of this property, with the same resources (by reference) as the original.\n\t */\n\tpublic clone(): this {\n\t\t// NOTICE: Keep in sync with `./extension-property.ts`.\n\n\t\tconst PropertyClass = this.constructor as new (g: PropertyGraph) => this;\n\t\tconst child = new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n\n\t\t// Root needs this event to link cloned properties.\n\t\tthis.graph.emit('clone', child);\n\n\t\treturn child;\n\t}\n\n\t/**\n\t * Copies all data from another property to this one. Child properties are copied by reference,\n\t * unless a 'resolve' function is given to override that.\n\t * @param other Property to copy references from.\n\t * @param resolve Function to resolve each Property being transferred. Default is identity.\n\t */\n\tpublic copy(other: this, _resolve: PropertyResolver<Property> = COPY_IDENTITY): this {\n\t\tthis._name = other._name;\n\t\tthis._extras = JSON.parse(JSON.stringify(other._extras));\n\t\treturn this;\n\t}\n\n\tpublic detach(): this {\n\t\t// Detaching should keep properties in the same Document, and attached to its root.\n\t\tthis.graph.disconnectParents(this, (n: Property) => n.propertyType !== 'Root');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all properties that hold a reference to this property. For example, a\n\t * material may hold references to various textures, but a texture does not hold references\n\t * to the materials that use it.\n\t *\n\t * It is often necessary to filter the results for a particular type: some resources, like\n\t * {@link Accessor}s, may be referenced by different types of properties. Most properties\n\t * include the {@link Root} as a parent, which is usually not of interest.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * const materials = texture\n\t * \t.listParents()\n\t * \t.filter((p) => p instanceof Material)\n\t * ```\n\t */\n\tpublic listParents(): Property[] {\n\t\treturn this.listGraphParents() as Property[];\n\t}\n}\n","import { Graph } from './graph';\nimport { Link } from './graph-links';\n\n/**\n * Represents a node in a {@link Graph}.\n *\n * @hidden\n * @category Graph\n */\nexport abstract class GraphNode {\n\tprivate _disposed = false;\n\tconstructor(protected readonly graph: Graph<GraphNode>) {\n\t\tthis.graph = graph;\n\t}\n\n\t/**\n\t * Returns true if links between this and the given node are allowed. Validates only that the\n\t * objects are both {@link GraphNode} instances and on the same graph, not that they are\n\t * semantically compatible.\n\t *\n\t * @internal\n\t */\n\tpublic canLink(other: GraphNode): boolean {\n\t\treturn this.graph === other.graph;\n\t}\n\n\t/** Returns true if the node has been permanently removed from the graph. */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Removes both inbound references to and outbound references from this object. At the end\n\t * of the process the object holds no references, and nothing holds references to it. A\n\t * disposed object is not reusable.\n\t */\n\tpublic dispose(): void {\n\t\tthis.graph.disconnectChildren(this);\n\t\tthis.graph.disconnectParents(this);\n\t\tthis._disposed = true;\n\t\tthis.graph.emit('dispose', this);\n\t}\n\n\t/**\n\t * Removes all inbound references to this object. At the end of the process the object is\n\t * considered 'detached': it may hold references to child resources, but nothing holds\n\t * references to it. A detached object may be re-attached.\n\t */\n\tpublic detach(): this {\n\t\tthis.graph.disconnectParents(this);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transfers this object's references from the old node to the new one. The old node is fully\n\t * detached from this parent at the end of the process.\n\t *\n\t * @hidden This method works imperfectly with Root, Scene, and Node properties, which may\n\t * already hold equivalent links to the replacement object.\n\t */\n\tpublic swap(old: GraphNode, replacement: GraphNode): this {\n\t\tthis.graph.swapChild(this, old, replacement);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a Link to a managed {@link @GraphChildList}, and sets up a listener to\n\t * remove the link if it's disposed. This function is only for lists of links,\n\t * annotated with {@link @GraphChildList}. Properties are annotated and managed by\n\t * {@link @GraphChild} instead.\n\t *\n\t * @hidden\n\t */\n\tprotected addGraphChild(links: Link<GraphNode, GraphNode>[], link: Link<GraphNode, GraphNode>): this {\n\t\tlinks.push(link);\n\t\tlink.onDispose(() => {\n\t\t\tconst remaining = links.filter((l) => l !== link);\n\t\t\tlinks.length = 0;\n\t\t\tfor (const link of remaining) links.push(link);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a {@link GraphNode} from a {@link GraphChildList}.\n\t *\n\t * @hidden\n\t */\n\tprotected removeGraphChild(links: Link<GraphNode, GraphNode>[], child: GraphNode): this {\n\t\tconst pruned = links.filter((link) => link.getChild() === child);\n\t\tpruned.forEach((link) => link.dispose());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all {@link GraphNode}s from a {@link GraphChildList}.\n\t *\n\t * @hidden\n\t */\n\tprotected clearGraphChildList(links: Link<GraphNode, GraphNode>[]): this {\n\t\twhile (links.length > 0) links[0].dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all nodes that hold a reference to this node.\n\t *\n\t * Available publicly by {@link Property}'s `.listParents()`.\n\t *\n\t * @hidden\n\t */\n\tprotected listGraphParents(): GraphNode[] {\n\t\treturn this.graph.listParents(this) as GraphNode[];\n\t}\n}\n","import { GraphChildList, Link } from '../graph';\nimport { ExtensionProperty } from './extension-property';\nimport { COPY_IDENTITY, Property } from './property';\n\n// Breaking change introduced in v0.6.\nconst TOKEN_WARNING = 'Pass extension name (string) as lookup token, not a constructor.';\n\n/**\n * # ExtensibleProperty\n *\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties — excluding {@link Root} and {@link ExtensionProperty} — are extensible. See the\n * {@link Extension} documentation for information about how to use extensions.\n *\n * @category Properties\n */\nexport abstract class ExtensibleProperty extends Property {\n\t@GraphChildList protected extensions: Link<Property, ExtensionProperty>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.clearGraphChildList(this.extensions);\n\t\tother.extensions.forEach((link) => {\n\t\t\tconst extension = link.getChild();\n\t\t\tthis.setExtension(extension.extensionName, resolve(extension));\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an {@link ExtensionProperty} attached to this Property, if any. *Not available on\n\t * {@link Root} properties.*\n\t */\n\tpublic getExtension<Prop extends ExtensionProperty>(name: string): Prop | null {\n\t\tif (typeof name !== 'string') throw new Error(TOKEN_WARNING);\n\t\tconst link = this.extensions.find((link) => link.getChild().extensionName === name);\n\t\treturn link ? (link.getChild() as Prop) : null;\n\t}\n\n\t/**\n\t * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n\t * one ExtensionProperty may be attached to any one Property at a time. *Not available on\n\t * {@link Root} properties.*\n\t */\n\tpublic setExtension<Prop extends ExtensionProperty>(name: string, extensionProperty: Prop | null): this {\n\t\tif (typeof name !== 'string') throw new Error(TOKEN_WARNING);\n\n\t\t// Remove previous extension.\n\t\tconst prevExtension = this.getExtension(name);\n\t\tif (prevExtension) this.removeGraphChild(this.extensions, prevExtension);\n\n\t\t// Stop if deleting the extension.\n\t\tif (!extensionProperty) return this;\n\n\t\t// Add next extension.\n\t\textensionProperty._validateParent(this);\n\t\treturn this.addGraphChild(this.extensions, this.graph.link(name, this, extensionProperty));\n\t}\n\n\t/**\n\t * Lists all {@link ExtensionProperty} instances attached to this Property. *Not available on\n\t * {@link Root} properties.*\n\t */\n\tpublic listExtensions(): ExtensionProperty[] {\n\t\treturn this.extensions.map((link) => link.getChild());\n\t}\n}\n","import { PropertyType, TypedArray } from '../constants';\nimport { GraphChild, Link } from '../graph';\nimport { GLTF } from '../types/gltf';\nimport { MathUtils } from '../utils';\nimport { Buffer } from './buffer';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Accessor\n *\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link getType}() method, and the number of elements in the accessor determine its\n * {@link getCount}(). The number of components in an element — e.g. 9 for `\"MAT3\"` — are its\n * {@link getElementSize}(). See {@link Accessor.Type}.\n *\n * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link getComponentType} method, and the number of bytes in each component determine its\n * {@link getComponentSize}. See {@link Accessor.ComponentType}.\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(doc.listBuffers()[0]);\n *\n * accessor.getCount();        // → 4\n * accessor.getElementSize();  // → 3\n * accessor.getByteLength();   // → 48\n * accessor.getElement(1, []); // → [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link getElement} and {@link setElement} methods reads or overwrites\n * the content of the underlying typed array. These methods use element arrays intended to be\n * compatible with the [gl-matrix](https://github.com/toji/gl-matrix) library, or with the\n * `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF-Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Accessor extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.ACCESSOR;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Element type contained by the accessor (SCALAR, VEC2, ...). */\n\tpublic static Type: Record<string, GLTF.AccessorType> = {\n\t\t/** Scalar, having 1 value per element. */\n\t\tSCALAR: 'SCALAR',\n\t\t/** 2-component vector, having 2 components per element. */\n\t\tVEC2: 'VEC2',\n\t\t/** 3-component vector, having 3 components per element. */\n\t\tVEC3: 'VEC3',\n\t\t/** 4-component vector, having 4 components per element. */\n\t\tVEC4: 'VEC4',\n\t\t/** 2x2 matrix, having 4 components per element. */\n\t\tMAT2: 'MAT2',\n\t\t/** 3x3 matrix, having 9 components per element. */\n\t\tMAT3: 'MAT3',\n\t\t/** 4x3 matrix, having 16 components per element. */\n\t\tMAT4: 'MAT4',\n\t};\n\n\t/** Data type of the values composing each element in the accessor. */\n\tpublic static ComponentType: Record<string, GLTF.AccessorComponentType> = {\n\t\t/**\n\t\t * 1-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n\t\t */\n\t\tBYTE: 5120,\n\t\t/**\n\t\t * 1-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n\t\t */\n\t\tUNSIGNED_BYTE: 5121,\n\t\t/**\n\t\t * 2-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n\t\t */\n\t\tSHORT: 5122,\n\t\t/**\n\t\t * 2-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n\t\t */\n\t\tUNSIGNED_SHORT: 5123,\n\t\t/**\n\t\t * 4-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n\t\t */\n\t\tUNSIGNED_INT: 5125,\n\t\t/**\n\t\t * 4-byte floating point number, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n\t\t */\n\t\tFLOAT: 5126,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\t/** @internal Raw data of the accessor. */\n\tprivate _array: TypedArray | null = null;\n\n\t/** @internal Type of element represented. */\n\tprivate _type: GLTF.AccessorType = Accessor.Type.SCALAR;\n\n\t/** @internal Numeric type of each component in an element. */\n\tprivate _componentType: GLTF.AccessorComponentType = Accessor.ComponentType.FLOAT;\n\n\t/** @internal Whether data in the raw array should be considered normalized. */\n\tprivate _normalized = false;\n\n\t/** @internal Inbound transform to normalized representation, if applicable. */\n\tprivate _in = MathUtils.identity;\n\n\t/** @internal Outbound transform from normalized representation, if applicable. */\n\tprivate _out = MathUtils.identity;\n\n\t/** @internal The {@link Buffer} to which this accessor's data will be written. */\n\t@GraphChild private buffer: Link<Accessor, Buffer> | null = null;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._type = other._type;\n\t\tthis._componentType = other._componentType;\n\t\tthis._normalized = other._normalized;\n\t\tthis._in = other._in;\n\t\tthis._out = other._out;\n\n\t\tif (other._array) this._array = other._array.slice();\n\n\t\tthis.setBuffer(other.buffer ? resolve(other.buffer.getChild()) : null);\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Returns size of a given element type, in components. */\n\tpublic static getElementSize(type: GLTF.AccessorType): number {\n\t\tswitch (type) {\n\t\t\tcase Accessor.Type.SCALAR:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.Type.VEC2:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.Type.VEC3:\n\t\t\t\treturn 3;\n\t\t\tcase Accessor.Type.VEC4:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT2:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT3:\n\t\t\t\treturn 9;\n\t\t\tcase Accessor.Type.MAT4:\n\t\t\t\treturn 16;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected type: ' + type);\n\t\t}\n\t}\n\n\t/** Returns size of a given component type, in bytes. */\n\tpublic static getComponentSize(componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t}\n\t}\n\n\t/**********************************************************************************************\n\t * Min/max bounds.\n\t */\n\n\t/**\n\t * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMinNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMin(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Minimum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMin(target: number[]): number[] {\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = this._array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.min(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMaxNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMax(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMax(target: number[]): number[] {\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = this._array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.max(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**********************************************************************************************\n\t * Layout.\n\t */\n\n\t/**\n\t * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n\t * will have a count of 10.\n\t */\n\tpublic getCount(): number {\n\t\treturn this._array ? this._array.length / this.getElementSize() : 0;\n\t}\n\n\t/** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n\tpublic getType(): GLTF.AccessorType {\n\t\treturn this._type;\n\t}\n\n\t/**\n\t * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n\t * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n\t */\n\tpublic setType(type: GLTF.AccessorType): Accessor {\n\t\tthis._type = type;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Number of components in each element of the accessor. For example, the element size of a\n\t * `VEC2` accessor is 2. This value is determined automatically based on array length and\n\t * accessor type, specified with {@link setType}().\n\t */\n\tpublic getElementSize(): number {\n\t\treturn Accessor.getElementSize(this._type);\n\t}\n\n\t/**\n\t * Size of each component (a value in the raw array), in bytes. For example, the\n\t * `componentSize` of data backed by a `float32` array is 4 bytes.\n\t */\n\tpublic getComponentSize(): number {\n\t\treturn this._array!.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n\t * be modified by replacing the underlying array.\n\t */\n\tpublic getComponentType(): GLTF.AccessorComponentType {\n\t\treturn this._componentType;\n\t}\n\n\t/**********************************************************************************************\n\t * Normalization.\n\t */\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic getNormalized(): boolean {\n\t\treturn this._normalized;\n\t}\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic setNormalized(normalized: boolean): this {\n\t\tthis._normalized = normalized;\n\n\t\tif (normalized) {\n\t\t\tthis._out = (c: number): number => MathUtils.denormalize(c, this._componentType);\n\t\t\tthis._in = (f: number): number => MathUtils.normalize(f, this._componentType);\n\t\t} else {\n\t\t\tthis._out = MathUtils.identity;\n\t\t\tthis._in = MathUtils.identity;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Data access.\n\t */\n\n\t/**\n\t * Returns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic getScalar(index: number): number {\n\t\tconst elementSize = this.getElementSize();\n\t\treturn this._out(this._array![index * elementSize]);\n\t}\n\n\t/**\n\t * Assigns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic setScalar(index: number, x: number): this {\n\t\tthis._array![index * this.getElementSize()] = this._in(x);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic getElement(index: number, target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\ttarget[i] = this._out(this._array![index * elementSize + i]);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Assigns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic setElement(index: number, value: number[]): this {\n\t\tconst elementSize = this.getElementSize();\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tthis._array![index * elementSize + i] = this._in(value[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Raw data storage.\n\t */\n\n\t/** Returns the {@link Buffer} into which this accessor will be organized. */\n\tpublic getBuffer(): Buffer | null {\n\t\treturn this.buffer ? this.buffer.getChild() : null;\n\t}\n\n\t/** Assigns the {@link Buffer} into which this accessor will be organized. */\n\tpublic setBuffer(buffer: Buffer | null): this {\n\t\tthis.buffer = this.graph.link('buffer', this, buffer);\n\t\treturn this;\n\t}\n\n\t/** Returns the raw typed array underlying this accessor. */\n\tpublic getArray(): TypedArray | null {\n\t\treturn this._array;\n\t}\n\n\t/** Assigns the raw typed array underlying this accessor. */\n\tpublic setArray(array: TypedArray): this {\n\t\tthis._componentType = array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT;\n\t\tthis._array = array;\n\t\treturn this;\n\t}\n\n\t/** Returns the total bytelength of this accessor, exclusive of padding. */\n\tpublic getByteLength(): number {\n\t\treturn this._array ? this._array.byteLength : 0;\n\t}\n}\n\n/**************************************************************************************************\n * Accessor utilities.\n */\n\n/** @internal */\nfunction arrayToComponentType(array: TypedArray): GLTF.AccessorComponentType {\n\tswitch (array.constructor) {\n\t\tcase Float32Array:\n\t\t\treturn Accessor.ComponentType.FLOAT;\n\t\tcase Uint32Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_INT;\n\t\tcase Uint16Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_SHORT;\n\t\tcase Uint8Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_BYTE;\n\t\tcase Int16Array:\n\t\t\treturn Accessor.ComponentType.SHORT;\n\t\tcase Int8Array:\n\t\t\treturn Accessor.ComponentType.BYTE;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown accessor componentType.');\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList, Link } from '../graph';\nimport { AnimationChannel } from './animation-channel';\nimport { AnimationSampler } from './animation-sampler';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Animation\n *\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class Animation extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.ANIMATION;\n\t@GraphChildList private channels: Link<Animation, AnimationChannel>[] = [];\n\t@GraphChildList private samplers: Link<Animation, AnimationSampler>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.clearGraphChildList(this.channels);\n\t\tthis.clearGraphChildList(this.samplers);\n\n\t\tother.channels.forEach((link) => this.addChannel(resolve(link.getChild())));\n\t\tother.samplers.forEach((link) => this.addSampler(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/** Adds an {@link AnimationChannel} to this Animation. */\n\tpublic addChannel(channel: AnimationChannel): this {\n\t\tconst link = this.graph.link('channel', this, channel);\n\t\treturn this.addGraphChild(this.channels, link);\n\t}\n\n\t/** Removes an {@link AnimationChannel} from this Animation. */\n\tpublic removeChannel(channel: AnimationChannel): this {\n\t\treturn this.removeGraphChild(this.channels, channel);\n\t}\n\n\t/** Lists {@link AnimationChannel}s in this Animation. */\n\tpublic listChannels(): AnimationChannel[] {\n\t\treturn this.channels.map((link) => link.getChild());\n\t}\n\n\t/** Adds an {@link AnimationSampler} to this Animation. */\n\tpublic addSampler(sampler: AnimationSampler): this {\n\t\tconst link = this.graph.link('sampler', this, sampler);\n\t\treturn this.addGraphChild(this.samplers, link);\n\t}\n\n\t/** Removes an {@link AnimationSampler} from this Animation. */\n\tpublic removeSampler(sampler: AnimationSampler): this {\n\t\treturn this.removeGraphChild(this.samplers, sampler);\n\t}\n\n\t/** Lists {@link AnimationSampler}s in this Animation. */\n\tpublic listSamplers(): AnimationSampler[] {\n\t\treturn this.samplers.map((link) => link.getChild());\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, Link } from '../graph';\nimport { GLTF } from '../types/gltf';\nimport { AnimationSampler } from './animation-sampler';\nimport { Node } from './node';\nimport { COPY_IDENTITY, Property } from './property';\n\n/**\n * # AnimationChannel\n *\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain\n * one channel for each Node-position or Node-rotation pair. The keyframe data for an\n * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same\n * {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class AnimationChannel extends Property {\n\tpublic readonly propertyType = PropertyType.ANIMATION_CHANNEL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Name of the property to be modified by an animation channel. */\n\tpublic static TargetPath: Record<string, GLTF.AnimationChannelTargetPath> = {\n\t\t/** Channel targets {@link Node.setTranslation}. */\n\t\tTRANSLATION: 'translation',\n\t\t/** Channel targets {@link Node.setRotation}. */\n\t\tROTATION: 'rotation',\n\t\t/** Channel targets {@link Node.setScale}. */\n\t\tSCALE: 'scale',\n\t\t/** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n\t\tWEIGHTS: 'weights',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprivate _targetPath: GLTF.AnimationChannelTargetPath | null = null;\n\t@GraphChild private targetNode: Link<AnimationChannel, Node> | null = null;\n\t@GraphChild private sampler: Link<AnimationChannel, AnimationSampler> | null = null;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._targetPath = other._targetPath;\n\n\t\tthis.setTargetNode(other.targetNode ? resolve(other.targetNode.getChild()) : null);\n\t\tthis.setSampler(other.sampler ? resolve(other.sampler.getChild()) : null);\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic getTargetPath(): GLTF.AnimationChannelTargetPath | null {\n\t\treturn this._targetPath;\n\t}\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic setTargetPath(targetPath: GLTF.AnimationChannelTargetPath): this {\n\t\tthis._targetPath = targetPath;\n\t\treturn this;\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic getTargetNode(): Node | null {\n\t\treturn this.targetNode ? this.targetNode.getChild() : null;\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic setTargetNode(targetNode: Node | null): this {\n\t\tthis.targetNode = this.graph.link('target.node', this, targetNode);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic getSampler(): AnimationSampler | null {\n\t\treturn this.sampler ? this.sampler.getChild() : null;\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic setSampler(sampler: AnimationSampler | null): this {\n\t\tthis.sampler = this.graph.link('sampler', this, sampler);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, Link } from '../graph';\nimport { GLTF } from '../types/gltf';\nimport { Accessor } from './accessor';\nimport { COPY_IDENTITY, Property } from './property';\n\n/**\n * # AnimationSampler\n *\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,\n * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR);\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType(Accessor.Type.VEC3);\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class AnimationSampler extends Property {\n\tpublic readonly propertyType = PropertyType.ANIMATION_SAMPLER;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Interpolation method. */\n\tpublic static Interpolation: Record<string, GLTF.AnimationSamplerInterpolation> = {\n\t\t/** Animated values are linearly interpolated between keyframes. */\n\t\tLINEAR: 'LINEAR',\n\t\t/** Animated values remain constant from one keyframe until the next keyframe. */\n\t\tSTEP: 'STEP',\n\t\t/** Animated values are interpolated according to given cubic spline tangents. */\n\t\tCUBICSPLINE: 'CUBICSPLINE',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprivate _interpolation: GLTF.AnimationSamplerInterpolation = AnimationSampler.Interpolation.LINEAR;\n\n\t@GraphChild private input: Link<AnimationSampler, Accessor> | null = null;\n\t@GraphChild private output: Link<AnimationSampler, Accessor> | null = null;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._interpolation = other._interpolation;\n\n\t\tthis.setInput(other.input ? resolve(other.input.getChild()) : null);\n\t\tthis.setOutput(other.output ? resolve(other.output.getChild()) : null);\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic getInterpolation(): GLTF.AnimationSamplerInterpolation {\n\t\treturn this._interpolation;\n\t}\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic setInterpolation(interpolation: GLTF.AnimationSamplerInterpolation): this {\n\t\tthis._interpolation = interpolation;\n\t\treturn this;\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic getInput(): Accessor | null {\n\t\treturn this.input ? this.input.getChild() : null;\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic setInput(input: Accessor | null): this {\n\t\tthis.input = this.graph.link('input', this, input);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic getOutput(): Accessor | null {\n\t\treturn this.output ? this.output.getChild() : null;\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic setOutput(output: Accessor | null): this {\n\t\tthis.output = this.graph.link('output', this, output);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Buffer\n *\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF-Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF-Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF-Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * new NodeIO().write('scene.gltf', doc);\n * // → scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Buffer extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.BUFFER;\n\n\t/** @internal URI (or filename) of the buffer. */\n\tprivate _uri = '';\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._uri = other._uri;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic getURI(): string {\n\t\treturn this._uri;\n\t}\n\n\t/**\n\t * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis._uri = uri;\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Camera\n *\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType(GLTF.CameraType.PERSPECTIVE)\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF → Cameras](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nexport class Camera extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.CAMERA;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static Type: Record<string, GLTF.CameraType> = {\n\t\t/** A perspective camera representing a perspective projection matrix. */\n\t\tPERSPECTIVE: 'perspective',\n\t\t/** An orthographic camera representing an orthographic projection matrix. */\n\t\tORTHOGRAPHIC: 'orthographic',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\t// Common.\n\n\tprivate _type: GLTF.CameraType = Camera.Type.PERSPECTIVE;\n\tprivate _znear = 0.1;\n\tprivate _zfar = 100;\n\n\t// Perspective.\n\n\tprivate _aspectRatio: number | null = null;\n\tprivate _yfov: number = (Math.PI * 2 * 50) / 360; // 50º\n\n\t// Orthographic.\n\n\tprivate _xmag = 1;\n\tprivate _ymag = 1;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._type = other._type;\n\t\tthis._znear = other._znear;\n\t\tthis._zfar = other._zfar;\n\t\tthis._aspectRatio = other._aspectRatio;\n\t\tthis._yfov = other._yfov;\n\t\tthis._xmag = other._xmag;\n\t\tthis._ymag = other._ymag;\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Common.\n\t */\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic getType(): GLTF.CameraType {\n\t\treturn this._type;\n\t}\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic setType(type: GLTF.CameraType): this {\n\t\tthis._type = type;\n\t\treturn this;\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic getZNear(): number {\n\t\treturn this._znear;\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic setZNear(znear: number): this {\n\t\tthis._znear = znear;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic getZFar(): number {\n\t\treturn this._zfar;\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic setZFar(zfar: number): this {\n\t\tthis._zfar = zfar;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Perspective.\n\t */\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic getAspectRatio(): number | null {\n\t\treturn this._aspectRatio;\n\t}\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic setAspectRatio(aspectRatio: number | null): this {\n\t\tthis._aspectRatio = aspectRatio;\n\t\treturn this;\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic getYFov(): number {\n\t\treturn this._yfov;\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic setYFov(yfov: number): this {\n\t\tthis._yfov = yfov;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Orthographic.\n\t */\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic getXMag(): number {\n\t\treturn this._xmag;\n\t}\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic setXMag(xmag: number): this {\n\t\tthis._xmag = xmag;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic getYMag(): number {\n\t\treturn this._ymag;\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic setYMag(ymag: number): this {\n\t\tthis._ymag = ymag;\n\t\treturn this;\n\t}\n}\n","import { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY, Property } from './property';\nimport { PropertyGraph } from './property-graph';\n\n/** @hidden */\nexport interface ExtensionPropertyParent {\n\taddExtensionProperty(ext: ExtensionProperty): this;\n\tremoveExtensionProperty(ext: ExtensionProperty): this;\n}\n\n/**\n * # ExtensionProperty\n *\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#specifying-extensions)\n */\nexport abstract class ExtensionProperty extends Property {\n\tpublic static EXTENSION_NAME: string;\n\tpublic abstract readonly extensionName: string;\n\n\t/** List of supported {@link Property} types. */\n\tpublic abstract readonly parentTypes: string[];\n\n\t/** @hidden */\n\tconstructor(graph: PropertyGraph, private readonly _extension: ExtensionPropertyParent) {\n\t\tsuper(graph);\n\t\tthis._extension.addExtensionProperty(this);\n\t}\n\n\tpublic clone(): this {\n\t\t// NOTICE: Keep in sync with `./property.ts`.\n\n\t\tconst PropertyClass = this.constructor as new (g: PropertyGraph, e: ExtensionPropertyParent) => this;\n\t\tconst child = new PropertyClass(this.graph, this._extension).copy(this, COPY_IDENTITY);\n\n\t\t// Root needs this event to link cloned properties.\n\t\tthis.graph.emit('clone', child);\n\n\t\treturn child;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._extension.removeExtensionProperty(this);\n\t\tsuper.dispose();\n\t}\n\n\t/** @hidden */\n\tpublic _validateParent(parent: ExtensibleProperty): void {\n\t\tif (!this.parentTypes.includes(parent.propertyType)) {\n\t\t\tthrow new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n\t\t}\n\t}\n}\n","import { Link } from '../graph';\nimport { Accessor } from './accessor';\nimport { ExtensionProperty } from './extension-property';\nimport { Material } from './material';\nimport { Primitive } from './primitive';\nimport { Property } from './property';\nimport { Texture } from './texture';\n\n/** @hidden */\nexport class AttributeLink extends Link<Property, Accessor> {\n\tpublic semantic = '';\n\tpublic copy(other: this): this {\n\t\tthis.semantic = other.semantic;\n\t\treturn this;\n\t}\n}\n\n/** @hidden */\nexport class IndexLink extends Link<Primitive, Accessor> {\n\tpublic copy(_other: this): this {\n\t\treturn this;\n\t}\n}\n\n/** @hidden */\nexport class TextureLink extends Link<Material | ExtensionProperty, Texture> {\n\tpublic channels = 0;\n\tpublic copy(other: this): this {\n\t\tthis.channels = other.channels;\n\t\treturn this;\n\t}\n}\n","import { Graph } from '../graph';\nimport { Accessor } from './accessor';\nimport { ExtensionProperty } from './extension-property';\nimport { Material } from './material';\nimport { Primitive } from './primitive';\nimport { Property } from './property';\nimport { AttributeLink, IndexLink, TextureLink } from './property-links';\nimport { Texture } from './texture';\n\n/** @hidden */\nexport class PropertyGraph extends Graph<Property> {\n\tpublic linkAttribute(name: string, a: Property, b: null): null;\n\tpublic linkAttribute(name: string, a: Property, b: Accessor): AttributeLink;\n\tpublic linkAttribute(name: string, a: Property, b: Accessor | null): AttributeLink | null;\n\tpublic linkAttribute(name: string, a: Property, b: Accessor | null): AttributeLink | null {\n\t\tif (!b) return null;\n\t\tconst link = new AttributeLink(name, a, b);\n\t\tlink.semantic = name;\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n\n\tpublic linkIndex(name: string, a: Primitive, b: null): null;\n\tpublic linkIndex(name: string, a: Primitive, b: Accessor): IndexLink;\n\tpublic linkIndex(name: string, a: Primitive, b: Accessor | null): IndexLink | null;\n\tpublic linkIndex(name: string, a: Primitive, b: Accessor | null): IndexLink | null {\n\t\tif (!b) return null;\n\t\tconst link = new IndexLink(name, a, b);\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n\n\tpublic linkTexture(name: string, channels: number, a: Material | ExtensionProperty, b: null): null;\n\tpublic linkTexture(name: string, channels: number, a: Material | ExtensionProperty, b: Texture): TextureLink;\n\tpublic linkTexture(\n\t\tname: string,\n\t\tchannels: number,\n\t\ta: Material | ExtensionProperty,\n\t\tb: Texture | null\n\t): TextureLink | null;\n\tpublic linkTexture(\n\t\tname: string,\n\t\tchannels: number,\n\t\ta: Material | ExtensionProperty,\n\t\tb: Texture | null\n\t): TextureLink | null {\n\t\tif (!b) return null;\n\t\tconst link = new TextureLink(name, a, b);\n\t\tlink.channels = channels;\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # TextureInfo\n *\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF → Texture Info](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nexport class TextureInfo extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.TEXTURE_INFO;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** UV wrapping mode. Values correspond to WebGL enums. */\n\tpublic static WrapMode: Record<string, GLTF.TextureWrapMode> = {\n\t\t/** */\n\t\tCLAMP_TO_EDGE: 33071,\n\t\t/** */\n\t\tMIRRORED_REPEAT: 33648,\n\t\t/** */\n\t\tREPEAT: 10497,\n\t};\n\n\t/** Magnification filter. Values correspond to WebGL enums. */\n\tpublic static MagFilter: Record<string, GLTF.TextureMagFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t};\n\n\t/** Minification filter. Values correspond to WebGL enums. */\n\tpublic static MinFilter: Record<string, GLTF.TextureMinFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t\t/** */\n\t\tNEAREST_MIPMAP_NEAREST: 9984,\n\t\t/** */\n\t\tLINEAR_MIPMAP_NEAREST: 9985,\n\t\t/** */\n\t\tNEAREST_MIPMAP_LINEAR: 9986,\n\t\t/** */\n\t\tLINEAR_MIPMAP_LINEAR: 9987,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprivate _texCoord = 0;\n\n\t// Sampler properties are also attached to TextureInfo, for simplicity.\n\tprivate _magFilter: GLTF.TextureMagFilter | null = null;\n\tprivate _minFilter: GLTF.TextureMinFilter | null = null;\n\tprivate _wrapS: GLTF.TextureWrapMode = TextureInfo.WrapMode.REPEAT;\n\tprivate _wrapT: GLTF.TextureWrapMode = TextureInfo.WrapMode.REPEAT;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._texCoord = other._texCoord;\n\t\tthis._magFilter = other._magFilter;\n\t\tthis._minFilter = other._minFilter;\n\t\tthis._wrapS = other._wrapS;\n\t\tthis._wrapT = other._wrapT;\n\n\t\treturn this;\n\t}\n\n\tpublic equals(other: TextureInfo): boolean {\n\t\treturn (\n\t\t\tthis.getTexCoord() === other.getTexCoord() &&\n\t\t\tthis.getMagFilter() === other.getMagFilter() &&\n\t\t\tthis.getMinFilter() === other.getMinFilter() &&\n\t\t\tthis.getWrapS() === other.getWrapS() &&\n\t\t\tthis.getWrapT() === other.getWrapT()\n\t\t);\n\t}\n\n\t/**********************************************************************************************\n\t * Texture coordinates.\n\t */\n\n\t/** Returns the texture coordinate (UV set) index for the texture. */\n\tpublic getTexCoord(): number {\n\t\treturn this._texCoord;\n\t}\n\n\t/** Sets the texture coordinate (UV set) index for the texture. */\n\tpublic setTexCoord(texCoord: number): this {\n\t\tthis._texCoord = texCoord;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Min/mag filter.\n\t */\n\n\t/** Returns the magnification filter applied to the texture. */\n\tpublic getMagFilter(): GLTF.TextureMagFilter | null {\n\t\treturn this._magFilter;\n\t}\n\n\t/** Sets the magnification filter applied to the texture. */\n\tpublic setMagFilter(magFilter: GLTF.TextureMagFilter | null): this {\n\t\tthis._magFilter = magFilter;\n\t\treturn this;\n\t}\n\n\t/** Sets the minification filter applied to the texture. */\n\tpublic getMinFilter(): GLTF.TextureMinFilter | null {\n\t\treturn this._minFilter;\n\t}\n\n\t/** Returns the minification filter applied to the texture. */\n\tpublic setMinFilter(minFilter: GLTF.TextureMinFilter | null): this {\n\t\tthis._minFilter = minFilter;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * UV wrapping.\n\t */\n\n\t/** Returns the S (U) wrapping mode for UVs used by the texture. */\n\tpublic getWrapS(): GLTF.TextureWrapMode {\n\t\treturn this._wrapS;\n\t}\n\n\t/** Sets the S (U) wrapping mode for UVs used by the texture. */\n\tpublic setWrapS(wrapS: GLTF.TextureWrapMode): this {\n\t\tthis._wrapS = wrapS;\n\t\treturn this;\n\t}\n\n\t/** Returns the T (V) wrapping mode for UVs used by the texture. */\n\tpublic getWrapT(): GLTF.TextureWrapMode {\n\t\treturn this._wrapT;\n\t}\n\n\t/** Sets the T (V) wrapping mode for UVs used by the texture. */\n\tpublic setWrapT(wrapT: GLTF.TextureWrapMode): this {\n\t\tthis._wrapT = wrapT;\n\t\treturn this;\n\t}\n}\n","import { PropertyType, TextureChannel, vec3, vec4 } from '../constants';\nimport { GraphChild, Link } from '../graph/index';\nimport { GLTF } from '../types/gltf';\nimport { ColorUtils, MathUtils } from '../utils';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\nimport { TextureLink } from './property-links';\nimport { Texture } from './texture';\nimport { TextureInfo } from './texture-info';\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Material\n *\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nexport class Material extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.MATERIAL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static AlphaMode: Record<string, GLTF.MaterialAlphaMode> = {\n\t\t/**\n\t\t * The alpha value is ignored and the rendered output is fully opaque\n\t\t */\n\t\tOPAQUE: 'OPAQUE',\n\t\t/**\n\t\t * The rendered output is either fully opaque or fully transparent depending on the alpha\n\t\t * value and the specified alpha cutoff value\n\t\t */\n\t\tMASK: 'MASK',\n\t\t/**\n\t\t * The alpha value is used to composite the source and destination areas. The rendered\n\t\t * output is combined with the background using the normal painting operation (i.e. the\n\t\t * Porter and Duff over operator)\n\t\t */\n\t\tBLEND: 'BLEND',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\t/** @internal Mode of the material's alpha channels. (`OPAQUE`, `BLEND`, or `MASK`) */\n\tprivate _alphaMode: GLTF.MaterialAlphaMode = Material.AlphaMode.OPAQUE;\n\n\t/** @internal Visibility threshold. Applied only when `.alphaMode='MASK'`. */\n\tprivate _alphaCutoff = 0.5;\n\n\t/** @internal When true, both sides of each triangle are rendered. May decrease performance. */\n\tprivate _doubleSided = false;\n\n\t/** @internal Base color / albedo; linear multiplier. */\n\tprivate _baseColorFactor: vec4 = [1, 1, 1, 1];\n\n\t/** @internal Emissive color; linear multiplier. */\n\tprivate _emissiveFactor: vec3 = [0, 0, 0];\n\n\t/** @internal Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tprivate _normalScale = 1;\n\n\t/** @internal (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionMap`. */\n\tprivate _occlusionStrength = 1;\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`.\n\t * @internal\n\t */\n\tprivate _roughnessFactor = 1;\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects metallic channel of\n\t * `metallicRoughnessTexture`.\n\t * @internal\n\t */\n\tprivate _metallicFactor = 1;\n\n\t/** @internal Base color / albedo texture. */\n\t@GraphChild private baseColorTexture: TextureLink | null = null;\n\t@GraphChild private baseColorTextureInfo: Link<this, TextureInfo> = this.graph.link(\n\t\t'baseColorTextureInfo',\n\t\tthis,\n\t\tnew TextureInfo(this.graph)\n\t);\n\n\t/** @internal Emissive texture. */\n\t@GraphChild private emissiveTexture: TextureLink | null = null;\n\t@GraphChild private emissiveTextureInfo: Link<this, TextureInfo> = this.graph.link(\n\t\t'emissiveTextureInfo',\n\t\tthis,\n\t\tnew TextureInfo(this.graph)\n\t);\n\n\t/**\n\t * Normal (surface detail) texture. Normal maps often suffer artifacts with JPEG compression,\n\t * so PNG files are preferred.\n\t * @internal\n\t */\n\t@GraphChild private normalTexture: TextureLink | null = null;\n\t@GraphChild private normalTextureInfo: Link<this, TextureInfo> = this.graph.link(\n\t\t'normalTextureInfo',\n\t\tthis,\n\t\tnew TextureInfo(this.graph)\n\t);\n\n\t/**\n\t * (Ambient) Occlusion texture. Occlusion data is stored in the `.r` channel, allowing this\n\t * texture to be packed with `metallicRoughnessTexture`, optionally.\n\t * @internal\n\t */\n\t@GraphChild private occlusionTexture: TextureLink | null = null;\n\t@GraphChild private occlusionTextureInfo: Link<this, TextureInfo> = this.graph.link(\n\t\t'occlusionTextureInfo',\n\t\tthis,\n\t\tnew TextureInfo(this.graph)\n\t);\n\n\t/**\n\t * Metallic/roughness PBR texture. Roughness data is stored in the `.g` channel and metallic\n\t * data is stored in the `.b` channel, allowing thist exture to be packed with\n\t * `occlusionTexture`, optionally.\n\t * @internal\n\t */\n\t@GraphChild private metallicRoughnessTexture: TextureLink | null = null;\n\t@GraphChild private metallicRoughnessTextureInfo: Link<this, TextureInfo> = this.graph.link(\n\t\t'metallicRoughnessTextureInfo',\n\t\tthis,\n\t\tnew TextureInfo(this.graph)\n\t);\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._alphaMode = other._alphaMode;\n\t\tthis._alphaCutoff = other._alphaCutoff;\n\t\tthis._doubleSided = other._doubleSided;\n\t\tthis._baseColorFactor = [...other._baseColorFactor] as vec4;\n\t\tthis._emissiveFactor = [...other._emissiveFactor] as vec3;\n\t\tthis._normalScale = other._normalScale;\n\t\tthis._occlusionStrength = other._occlusionStrength;\n\t\tthis._roughnessFactor = other._roughnessFactor;\n\t\tthis._metallicFactor = other._metallicFactor;\n\n\t\tthis.setBaseColorTexture(other.baseColorTexture ? resolve(other.baseColorTexture.getChild()) : null);\n\t\tthis.baseColorTextureInfo.getChild().copy(resolve(other.baseColorTextureInfo.getChild()), resolve);\n\n\t\tthis.setEmissiveTexture(other.emissiveTexture ? resolve(other.emissiveTexture.getChild()) : null);\n\t\tthis.emissiveTextureInfo.getChild().copy(resolve(other.emissiveTextureInfo.getChild()), resolve);\n\n\t\tthis.setNormalTexture(other.normalTexture ? resolve(other.normalTexture.getChild()) : null);\n\t\tthis.normalTextureInfo.getChild().copy(resolve(other.normalTextureInfo.getChild()), resolve);\n\n\t\tthis.setOcclusionTexture(other.occlusionTexture ? resolve(other.occlusionTexture.getChild()) : null);\n\t\tthis.occlusionTextureInfo.getChild().copy(resolve(other.occlusionTextureInfo.getChild()), resolve);\n\n\t\tthis.setMetallicRoughnessTexture(\n\t\t\tother.metallicRoughnessTexture ? resolve(other.metallicRoughnessTexture.getChild()) : null\n\t\t);\n\t\tthis.metallicRoughnessTextureInfo\n\t\t\t.getChild()\n\t\t\t.copy(resolve(other.metallicRoughnessTextureInfo.getChild()), resolve);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Checks for equality of two {@link Material} properties. Textures must be\n\t * the strictly equal (===), pixel data is not compared.\n\t */\n\tpublic equals(other: Material): boolean {\n\t\t// Factors and modes.\n\n\t\tif (this.getAlphaMode() !== other.getAlphaMode()) return false;\n\t\tif (this.getAlphaCutoff() !== other.getAlphaCutoff()) return false;\n\t\tif (this.getDoubleSided() !== other.getDoubleSided()) return false;\n\t\tif (!MathUtils.eq(this.getBaseColorFactor(), other.getBaseColorFactor())) return false;\n\t\tif (!MathUtils.eq(this.getEmissiveFactor(), other.getEmissiveFactor())) return false;\n\t\tif (this.getNormalScale() !== other.getNormalScale()) return false;\n\t\tif (this.getOcclusionStrength() !== other.getOcclusionStrength()) return false;\n\t\tif (this.getRoughnessFactor() !== other.getRoughnessFactor()) return false;\n\t\tif (this.getMetallicFactor() !== other.getMetallicFactor()) return false;\n\n\t\t// Textures.\n\n\t\tif (this.getBaseColorTexture() || other.getBaseColorTexture()) {\n\t\t\tif (this.getBaseColorTexture() !== other.getBaseColorTexture()) return false;\n\t\t\tif (\n\t\t\t\tthis.getBaseColorTexture() &&\n\t\t\t\t!this.getBaseColorTextureInfo()!.equals(other.getBaseColorTextureInfo()!)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (this.getEmissiveTexture() || other.getEmissiveTexture()) {\n\t\t\tif (this.getEmissiveTexture() !== other.getEmissiveTexture()) return false;\n\t\t\tif (this.getEmissiveTexture() && !this.getEmissiveTextureInfo()!.equals(other.getEmissiveTextureInfo()!)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (this.getNormalTexture() || other.getNormalTexture()) {\n\t\t\tif (this.getNormalTexture() !== other.getNormalTexture()) return false;\n\t\t\tif (this.getNormalTexture() && !this.getNormalTextureInfo()!.equals(other.getNormalTextureInfo()!)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (this.getOcclusionTexture() || other.getOcclusionTexture()) {\n\t\t\tif (this.getOcclusionTexture() !== other.getOcclusionTexture()) return false;\n\t\t\tif (\n\t\t\t\tthis.getOcclusionTexture() &&\n\t\t\t\t!this.getOcclusionTextureInfo()!.equals(other.getOcclusionTextureInfo()!)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (this.getMetallicRoughnessTexture() || other.getMetallicRoughnessTexture()) {\n\t\t\tif (this.getMetallicRoughnessTexture() !== other.getMetallicRoughnessTexture()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.getMetallicRoughnessTexture() &&\n\t\t\t\t!this.getMetallicRoughnessTextureInfo()!.equals(other.getMetallicRoughnessTextureInfo()!)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Extensions.\n\n\t\tconst extensions = this.listExtensions();\n\t\tconst otherExtensions = other.listExtensions();\n\t\tif (extensions.length !== otherExtensions.length) return false;\n\t\tfor (let i = 0; i < extensions.length; i++) {\n\t\t\t// TODO(feat): Implement deep equality checks for material extensions.\n\t\t\tif (extensions[i] !== otherExtensions[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdispose(): void {\n\t\t// TextureInfo instances were created by this material, and should be disposed with it.\n\t\tthis.baseColorTextureInfo.getChild().dispose();\n\t\tthis.emissiveTextureInfo.getChild().dispose();\n\t\tthis.normalTextureInfo.getChild().dispose();\n\t\tthis.occlusionTextureInfo.getChild().dispose();\n\t\tthis.metallicRoughnessTextureInfo.getChild().dispose();\n\t\tsuper.dispose();\n\t}\n\n\t/**********************************************************************************************\n\t * Double-sided / culling.\n\t */\n\n\t/** Returns true when both sides of triangles should be rendered. May impact performance. */\n\tpublic getDoubleSided(): boolean {\n\t\treturn this._doubleSided;\n\t}\n\n\t/** Sets whether to render both sides of triangles. May impact performance. */\n\tpublic setDoubleSided(doubleSided: boolean): this {\n\t\tthis._doubleSided = doubleSided;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Alpha.\n\t */\n\n\t/** Returns material alpha, equivalent to baseColorFactor[3]. */\n\tpublic getAlpha(): number {\n\t\treturn this._baseColorFactor[3];\n\t}\n\n\t/** Sets material alpha, equivalent to baseColorFactor[3]. */\n\tpublic setAlpha(alpha: number): this {\n\t\tthis._baseColorFactor[3] = alpha;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n\t * and `baseColorTexture`.\n\t *\n\t * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n\t * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n\t * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n\t *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n\t * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n\t * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n\t * \tshould usually be disabled on transparent materials.\n\t * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n\t * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n\t * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n\t * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n\t * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n\t * \tinvolved with `BLEND` transparency.\n\t *\n\t * Reference:\n\t * - [glTF → material.alphaMode](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialalphamode)\n\t */\n\tpublic getAlphaMode(): GLTF.MaterialAlphaMode {\n\t\treturn this._alphaMode;\n\t}\n\n\t/** Sets the mode of the material's alpha channels. See {@link getAlphaMode} for details. */\n\tpublic setAlphaMode(alphaMode: GLTF.MaterialAlphaMode): this {\n\t\tthis._alphaMode = alphaMode;\n\t\treturn this;\n\t}\n\n\t/** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic getAlphaCutoff(): number {\n\t\treturn this._alphaCutoff;\n\t}\n\n\t/** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic setAlphaCutoff(alphaCutoff: number): this {\n\t\tthis._alphaCutoff = alphaCutoff;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Base color.\n\t */\n\n\t/** Base color / albedo factor in linear space. See {@link getBaseColorTexture}. */\n\tpublic getBaseColorFactor(): vec4 {\n\t\treturn this._baseColorFactor;\n\t}\n\n\t/** Sets the base color / albedo factor in linear space. See {@link getBaseColorTexture}. */\n\tpublic setBaseColorFactor(baseColorFactor: vec4): this {\n\t\tthis._baseColorFactor = baseColorFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Base color / albedo as hexadecimal in sRGB colorspace. Converted automatically from\n\t * baseColorFactor in linear space. See {@link getBaseColorTexture}.\n\t */\n\tpublic getBaseColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this._baseColorFactor);\n\t}\n\n\t/**\n\t * Sets base color / albedo as hexadecimal in sRGB colorspace. Converted automatically to\n\t * baseColorFactor in linear space. See {@link getBaseColorTexture}.\n\t */\n\tpublic setBaseColorHex(hex: number): this {\n\t\tColorUtils.hexToFactor(hex, this._baseColorFactor);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n\t * light would be a linear combination (multiplication) of its vertex colors, base color\n\t * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n\t * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n\t * will have varying effects, based on the setting of {@link getAlphaMode}.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n\t */\n\tpublic getBaseColorTexture(): Texture | null {\n\t\treturn this.baseColorTexture ? this.baseColorTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its base color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getBaseColorTextureInfo(): TextureInfo | null {\n\t\treturn this.baseColorTexture ? this.baseColorTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets base color / albedo texture. See {@link getBaseColorTexture}. */\n\tpublic setBaseColorTexture(texture: Texture | null): this {\n\t\tthis.baseColorTexture = this.graph.linkTexture('baseColorTexture', R | G | B | A, this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Emissive.\n\t */\n\n\t/** Emissive color; linear multiplier. See {@link getEmissiveTexture}. */\n\tpublic getEmissiveFactor(): vec3 {\n\t\treturn this._emissiveFactor;\n\t}\n\n\t/** Sets the emissive color; linear multiplier. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveFactor(emissiveFactor: vec3): this {\n\t\tthis._emissiveFactor = emissiveFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emissive as hexadecimal in sRGB colorspace. Converted automatically from\n\t * emissiveFactor in linear space. See {@link getBaseColorTexture}.\n\t */\n\tpublic getEmissiveHex(): number {\n\t\treturn ColorUtils.factorToHex(this._emissiveFactor);\n\t}\n\n\t/**\n\t * Sets emissive as hexadecimal in sRGB colorspace. Converted automatically to\n\t * emissiveFactor in linear space. See {@link getEmissiveTexture}.\n\t */\n\tpublic setEmissiveHex(hex: number): this {\n\t\tColorUtils.hexToFactor(hex, this._emissiveFactor);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emissive texture. Emissive color is added to any base color of the material, after any\n\t * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n\t * objects around it at all. To create that effect, most viewers must also enable a\n\t * post-processing effect called \"bloom\".\n\t *\n\t * Reference:\n\t * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialemissivetexture)\n\t */\n\tpublic getEmissiveTexture(): Texture | null {\n\t\treturn this.emissiveTexture ? this.emissiveTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its emissive texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getEmissiveTextureInfo(): TextureInfo | null {\n\t\treturn this.emissiveTexture ? this.emissiveTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets emissive texture. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveTexture(texture: Texture | null): this {\n\t\tthis.emissiveTexture = this.graph.linkTexture('emissiveTexture', R | G | B, this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Normal.\n\t */\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic getNormalScale(): number {\n\t\treturn this._normalScale;\n\t}\n\n\t/** Sets normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic setNormalScale(normalScale: number): this {\n\t\tthis._normalScale = normalScale;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normal (surface detail) texture.\n\t *\n\t * A tangent space normal map. The texture contains RGB components in linear space. Each texel\n\t * represents the XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X\n\t * [-1 to 1]. Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1].\n\t * The normal vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward\n\t * the viewer.\n\t *\n\t * Reference:\n\t * - [glTF → material.normalTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialnormaltexture)\n\t */\n\tpublic getNormalTexture(): Texture | null {\n\t\treturn this.normalTexture ? this.normalTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its normal texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.normalTexture ? this.normalTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets normal (surface detail) texture. See {@link getNormalTexture}. */\n\tpublic setNormalTexture(texture: Texture | null): this {\n\t\tthis.normalTexture = this.graph.linkTexture('normalTexture', R | G | B, this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Occlusion.\n\t */\n\n\t/** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic getOcclusionStrength(): number {\n\t\treturn this._occlusionStrength;\n\t}\n\n\t/** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic setOcclusionStrength(occlusionStrength: number): this {\n\t\tthis._occlusionStrength = occlusionStrength;\n\t\treturn this;\n\t}\n\n\t/**\n\t * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n\t * independent of an object's position, such as shading in inset areas and corners. Direct\n\t * lighting is not affected by occlusion, so at least one indirect light source must be present\n\t * in the scene for occlusion effects to be visible.\n\t *\n\t * The occlusion values are sampled from the R channel. Higher values indicate areas that\n\t * should receive full indirect lighting and lower values indicate no indirect lighting.\n\t *\n\t * Reference:\n\t * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialocclusiontexture)\n\t */\n\tpublic getOcclusionTexture(): Texture | null {\n\t\treturn this.occlusionTexture ? this.occlusionTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getOcclusionTextureInfo(): TextureInfo | null {\n\t\treturn this.occlusionTexture ? this.occlusionTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets (ambient) occlusion texture. See {@link getOcclusionTexture}. */\n\tpublic setOcclusionTexture(texture: Texture | null): this {\n\t\tthis.occlusionTexture = this.graph.linkTexture('occlusionTexture', R, this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Metallic / roughness.\n\t */\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic getRoughnessFactor(): number {\n\t\treturn this._roughnessFactor;\n\t}\n\n\t/**\n\t * Sets roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic setRoughnessFactor(roughnessFactor: number): this {\n\t\tthis._roughnessFactor = roughnessFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic getMetallicFactor(): number {\n\t\treturn this._metallicFactor;\n\t}\n\n\t/**\n\t * Sets metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicFactor(metallicFactor: number): this {\n\t\tthis._metallicFactor = metallicFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Metallic roughness texture. The metalness values are sampled from the B channel. The\n\t * roughness values are sampled from the G channel. When a material is fully metallic,\n\t * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n\t * illumination to appear well-lit.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n\t */\n\tpublic getMetallicRoughnessTexture(): Texture | null {\n\t\treturn this.metallicRoughnessTexture ? this.metallicRoughnessTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getMetallicRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.metallicRoughnessTexture ? this.metallicRoughnessTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets metallic/roughness texture. See {@link getMetallicRoughnessTexture}. */\n\tpublic setMetallicRoughnessTexture(texture: Texture | null): this {\n\t\tthis.metallicRoughnessTexture = this.graph.linkTexture('metallicRoughnessTexture', G | B, this, texture);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList } from '../graph/index';\nimport { Link } from '../graph/index';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Primitive } from './primitive';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Mesh\n *\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives — materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Mesh extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.MESH;\n\n\tprivate _weights: number[] = [];\n\n\t/** @internal Primitive GPU draw call list. */\n\t@GraphChildList private primitives: Link<Mesh, Primitive>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._weights = [...other._weights];\n\n\t\tthis.clearGraphChildList(this.primitives);\n\t\tother.primitives.forEach((link) => this.addPrimitive(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/** Adds a {@link Primitive} to the mesh's draw call list. */\n\tpublic addPrimitive(primitive: Primitive): this {\n\t\treturn this.addGraphChild(this.primitives, this.graph.link('primitive', this, primitive));\n\t}\n\n\t/** Removes a {@link Primitive} from the mesh's draw call list. */\n\tpublic removePrimitive(primitive: Primitive): this {\n\t\treturn this.removeGraphChild(this.primitives, primitive);\n\t}\n\n\t/** Lists {@link Primitive} draw calls of the mesh. */\n\tpublic listPrimitives(): Primitive[] {\n\t\treturn this.primitives.map((p) => p.getChild());\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this._weights;\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\tthis._weights = weights;\n\t\treturn this;\n\t}\n}\n","import { multiply } from 'gl-matrix/mat4';\nimport { PropertyType, mat4, vec3, vec4 } from '../constants';\nimport { GraphChild, GraphChildList } from '../graph/graph-decorators';\nimport { Link } from '../graph/graph-links';\nimport { MathUtils } from '../utils';\nimport { Camera } from './camera';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Mesh } from './mesh';\nimport { COPY_IDENTITY } from './property';\nimport { Skin } from './skin';\n\n/**\n * # Node\n *\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A node cannot be\n * part of more than one {@link Scene}.\n *\n * A node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nexport class Node extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.NODE;\n\tprivate _translation: vec3 = [0, 0, 0];\n\tprivate _rotation: vec4 = [0, 0, 0, 1];\n\tprivate _scale: vec3 = [1, 1, 1];\n\tprivate _weights: number[] = [];\n\n\t/** @internal Internal reference to node's parent, omitted from {@link Graph}. */\n\tpublic _parent: SceneNode | null = null;\n\n\t@GraphChild private camera: Link<Node, Camera> | null = null;\n\t@GraphChild private mesh: Link<Node, Mesh> | null = null;\n\t@GraphChild private skin: Link<Node, Skin> | null = null;\n\t@GraphChildList private children: Link<Node, Node>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._translation = [...other._translation] as vec3;\n\t\tthis._rotation = [...other._rotation] as vec4;\n\t\tthis._scale = [...other._scale] as vec3;\n\t\tthis._weights = [...other._weights];\n\n\t\tthis.setCamera(other.camera ? resolve(other.camera.getChild()) : null);\n\t\tthis.setMesh(other.mesh ? resolve(other.mesh.getChild()) : null);\n\t\tthis.setSkin(other.skin ? resolve(other.skin.getChild()) : null);\n\n\t\tif (resolve !== COPY_IDENTITY) {\n\t\t\tthis.clearGraphChildList(this.children);\n\t\t\tother.children.forEach((link) => this.addChild(resolve(link.getChild())));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Local transform.\n\t */\n\n\t/** Returns the translation (position) of this node in local space. */\n\tpublic getTranslation(): vec3 {\n\t\treturn this._translation;\n\t}\n\n\t/** Returns the rotation (quaternion) of this node in local space. */\n\tpublic getRotation(): vec4 {\n\t\treturn this._rotation;\n\t}\n\n\t/** Returns the scale of this node in local space. */\n\tpublic getScale(): vec3 {\n\t\treturn this._scale;\n\t}\n\n\t/** Sets the translation (position) of this node in local space. */\n\tpublic setTranslation(translation: vec3): this {\n\t\tthis._translation = translation;\n\t\treturn this;\n\t}\n\n\t/** Sets the rotation (quaternion) of this node in local space. */\n\tpublic setRotation(rotation: vec4): this {\n\t\tthis._rotation = rotation;\n\t\treturn this;\n\t}\n\n\t/** Sets the scale of this node in local space. */\n\tpublic setScale(scale: vec3): this {\n\t\tthis._scale = scale;\n\t\treturn this;\n\t}\n\n\t/** Returns the local matrix of this node. */\n\tpublic getMatrix(): mat4 {\n\t\treturn MathUtils.compose(this._translation, this._rotation, this._scale, [] as unknown as mat4);\n\t}\n\n\t/** Sets the local matrix of this node. Matrix will be decomposed to TRS properties. */\n\tpublic setMatrix(matrix: mat4): this {\n\t\tMathUtils.decompose(matrix, this._translation, this._rotation, this._scale);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * World transform.\n\t */\n\n\t/** Returns the translation (position) of this node in world space. */\n\tpublic getWorldTranslation(): vec3 {\n\t\tconst t = [0, 0, 0] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n\t\treturn t;\n\t}\n\n\t/** Returns the rotation (quaternion) of this node in world space. */\n\tpublic getWorldRotation(): vec4 {\n\t\tconst r = [0, 0, 0, 1] as vec4;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n\t\treturn r;\n\t}\n\n\t/** Returns the scale of this node in world space. */\n\tpublic getWorldScale(): vec3 {\n\t\tconst s = [1, 1, 1] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n\t\treturn s;\n\t}\n\n\t/** Returns the world matrix of this node. */\n\tpublic getWorldMatrix(): mat4 {\n\t\t// Build ancestor chain.\n\t\tconst ancestors: Node[] = [];\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tfor (let node: SceneNode | null = this; node instanceof Node; node = node._parent) {\n\t\t\tancestors.push(node);\n\t\t}\n\n\t\t// Compute world matrix.\n\t\tlet ancestor: Node | undefined;\n\t\tconst worldMatrix = ancestors.pop()!.getMatrix();\n\t\twhile ((ancestor = ancestors.pop())) {\n\t\t\tmultiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n\t\t}\n\n\t\treturn worldMatrix;\n\t}\n\n\t/**********************************************************************************************\n\t * Scene hierarchy.\n\t */\n\n\t/** Adds another node as a child of this one. Nodes cannot have multiple parents. */\n\tpublic addChild(child: Node): this {\n\t\t// Remove existing parent.\n\t\tif (child._parent) child._parent.removeChild(child);\n\n\t\t// Link in graph.\n\t\tconst link = this.graph.link('child', this, child);\n\t\tthis.addGraphChild(this.children, link);\n\n\t\t// Set new parent.\n\t\tchild._parent = this;\n\t\tlink.onDispose(() => (child._parent = null));\n\t\treturn this;\n\t}\n\n\t/** Removes a node from this node's child node list. */\n\tpublic removeChild(child: Node): this {\n\t\treturn this.removeGraphChild(this.children, child);\n\t}\n\n\t/** Lists all child nodes of this node. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.children.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Returns the unique parent ({@link Scene}, {@link Node}, or null) of this node in the scene\n\t * hierarchy. Unrelated to {@link Property.listParents}, which lists all resource references.\n\t */\n\tpublic getParent(): SceneNode | null {\n\t\treturn this._parent;\n\t}\n\n\t/**********************************************************************************************\n\t * Attachments.\n\t */\n\n\t/** Returns the {@link Mesh}, if any, instantiated at this node. */\n\tpublic getMesh(): Mesh | null {\n\t\treturn this.mesh ? this.mesh.getChild() : null;\n\t}\n\n\t/**\n\t * Sets a {@link Mesh} to be instantiated at this node. A single mesh may be instatiated by\n\t * multiple nodes; reuse of this sort is strongly encouraged.\n\t */\n\tpublic setMesh(mesh: Mesh | null): this {\n\t\tthis.mesh = this.graph.link('mesh', this, mesh);\n\t\treturn this;\n\t}\n\n\t/** Returns the {@link Camera}, if any, instantiated at this node. */\n\tpublic getCamera(): Camera | null {\n\t\treturn this.camera ? this.camera.getChild() : null;\n\t}\n\n\t/** Sets a {@link Camera} to be instantiated at this node. */\n\tpublic setCamera(camera: Camera | null): this {\n\t\tthis.camera = this.graph.link('camera', this, camera);\n\t\treturn this;\n\t}\n\n\t/** Returns the {@link Skin}, if any, instantiated at this node. */\n\tpublic getSkin(): Skin | null {\n\t\treturn this.skin ? this.skin.getChild() : null;\n\t}\n\n\t/** Sets a {@link Skin} to be instantiated at this node. */\n\tpublic setSkin(skin: Skin | null): this {\n\t\tthis.skin = this.graph.link('skin', this, skin);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this._weights;\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\tthis._weights = weights;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Helpers.\n\t */\n\n\t/** Visits this {@link Node} and its descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfn(this);\n\t\tfor (const child of this.listChildren()) child.traverse(fn);\n\t\treturn this;\n\t}\n}\n\ninterface SceneNode {\n\tpropertyType: PropertyType;\n\t_parent?: SceneNode | null;\n\taddChild(node: Node): this;\n\tremoveChild(node: Node): this;\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, GraphChildList } from '../graph/index';\nimport { Link } from '../graph/index';\nimport { GLTF } from '../types/gltf';\nimport { Accessor } from './accessor';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Material } from './material';\nimport { PrimitiveTarget } from './primitive-target';\nimport { COPY_IDENTITY } from './property';\nimport { AttributeLink } from './property-links';\n\n/**\n * # Primitive\n *\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not affected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Primitive extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.PRIMITIVE;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Type of primitives to render. All valid values correspond to WebGL enums. */\n\tpublic static Mode: Record<string, GLTF.MeshPrimitiveMode> = {\n\t\t/** Draw single points. */\n\t\tPOINTS: 0,\n\t\t/** Draw lines. Each vertex connects to the one after it. */\n\t\tLINES: 1,\n\t\t/**\n\t\t * Draw lines. Each set of two vertices is treated as a separate line segment.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tLINE_LOOP: 2,\n\t\t/** Draw a connected group of line segments from the first vertex to the last,  */\n\t\tLINE_STRIP: 3,\n\t\t/** Draw triangles. Each set of three vertices creates a separate triangle. */\n\t\tTRIANGLES: 4,\n\t\t/** Draw a connected strip of triangles. */\n\t\tTRIANGLE_STRIP: 5,\n\t\t/**\n\t\t * Draw a connected group of triangles. Each vertex connects to the previous and the first\n\t\t * vertex in the fan.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tTRIANGLE_FAN: 6,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\t/** @internal GPU draw mode. */\n\tprivate _mode: GLTF.MeshPrimitiveMode = Primitive.Mode.TRIANGLES;\n\n\t@GraphChild private material: Link<Primitive, Material> | null = null;\n\t@GraphChild private indices: Link<Primitive, Accessor> | null = null;\n\t@GraphChildList private attributes: AttributeLink[] = [];\n\t@GraphChildList private targets: Link<Primitive, PrimitiveTarget>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._mode = other._mode;\n\n\t\tthis.setIndices(other.indices ? resolve(other.indices.getChild()) : null);\n\t\tthis.setMaterial(other.material ? resolve(other.material.getChild()) : null);\n\n\t\tthis.clearGraphChildList(this.attributes);\n\t\tother.listSemantics().forEach((semantic) => {\n\t\t\tthis.setAttribute(semantic, resolve(other.getAttribute(semantic)!));\n\t\t});\n\n\t\tthis.clearGraphChildList(this.targets);\n\t\tother.targets.forEach((link) => this.addTarget(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Primitive data.\n\t */\n\n\t/** Returns an {@link Accessor} with indices of vertices to be drawn. */\n\tpublic getIndices(): Accessor | null {\n\t\treturn this.indices ? this.indices.getChild() : null;\n\t}\n\n\t/**\n\t * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n\t * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n\t * winding order.\n\t */\n\tpublic setIndices(indices: Accessor | null): this {\n\t\tthis.indices = this.graph.linkIndex('indices', this, indices);\n\t\treturn this;\n\t}\n\n\t/** Returns a vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\tconst link = this.attributes.find((link) => link.semantic === semantic);\n\t\treturn link ? link.getChild() : null;\n\t}\n\n\t/**\n\t * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n\t * count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\t// Remove previous attribute.\n\t\tconst prevAccessor = this.getAttribute(semantic);\n\t\tif (prevAccessor) this.removeGraphChild(this.attributes, prevAccessor);\n\n\t\t// Stop if deleting the attribute.\n\t\tif (!accessor) return this;\n\n\t\t// Add next attribute.\n\t\tconst link = this.graph.linkAttribute(semantic, this, accessor);\n\t\treturn this.addGraphChild(this.attributes, link);\n\t}\n\n\t/**\n\t * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n\t * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n\t * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.attributes.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n\t * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.attributes.map((link) => link.semantic);\n\t}\n\n\t/** Returns the material used to render the primitive. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.material ? this.material.getChild() : null;\n\t}\n\n\t/** Sets the material used to render the primitive. */\n\tpublic setMaterial(material: Material | null): this {\n\t\tthis.material = this.graph.link('material', this, material);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Mode.\n\t */\n\n\t/**\n\t * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic getMode(): GLTF.MeshPrimitiveMode {\n\t\treturn this._mode;\n\t}\n\n\t/**\n\t * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic setMode(mode: GLTF.MeshPrimitiveMode): this {\n\t\tthis._mode = mode;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Morph targets.\n\t */\n\n\t/** Lists all morph targets associated with the primitive. */\n\tpublic listTargets(): PrimitiveTarget[] {\n\t\treturn this.targets.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic addTarget(target: PrimitiveTarget): this {\n\t\tthis.addGraphChild(this.targets, this.graph.link('target', this, target));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic removeTarget(target: PrimitiveTarget): this {\n\t\treturn this.removeGraphChild(this.targets, target);\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList } from '../graph/index';\nimport { Accessor } from './accessor';\nimport { COPY_IDENTITY, Property } from './property';\nimport { AttributeLink } from './property-links';\n\n/**\n * # PrimitiveTarget\n *\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF → Morph Targets](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets)\n */\nexport class PrimitiveTarget extends Property {\n\tpublic readonly propertyType = PropertyType.PRIMITIVE_TARGET;\n\n\t/** @internal Vertex attributes. */\n\t@GraphChildList private attributes: AttributeLink[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.clearGraphChildList(this.attributes);\n\t\tother.listSemantics().forEach((semantic) => {\n\t\t\tthis.setAttribute(semantic, resolve(other.getAttribute(semantic)!));\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** Returns a morph target vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\tconst link = this.attributes.find((link) => link.semantic === semantic);\n\t\treturn link ? link.getChild() : null;\n\t}\n\n\t/**\n\t * Sets a morph target vertex attribute to an {@link Accessor}.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\t// Remove previous attribute.\n\t\tconst prevAccessor = this.getAttribute(semantic);\n\t\tif (prevAccessor) this.removeGraphChild(this.attributes, prevAccessor);\n\n\t\t// Stop if deleting the attribute.\n\t\tif (!accessor) return this;\n\n\t\t// Add next attribute.\n\t\tconst link = this.graph.linkAttribute(semantic, this, accessor);\n\t\tlink.semantic = semantic;\n\t\treturn this.addGraphChild(this.attributes, link);\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n\t * consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.attributes.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute semantics associated. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.attributes.map((link) => link.semantic);\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList, Link } from '../graph/index';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Scene\n *\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single node cannot be a member of more than\n * one scene.\n *\n * References:\n * - [glTF → Scenes](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#scenes)\n * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nexport class Scene extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.SCENE;\n\n\t@GraphChildList private children: Link<Scene, Node>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tif (resolve !== COPY_IDENTITY) {\n\t\t\tthis.clearGraphChildList(this.children);\n\t\t\tother.children.forEach((link) => this.addChild(resolve(link.getChild())));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** Adds a {@link Node} to the scene. */\n\tpublic addChild(node: Node): this {\n\t\t// Remove existing parent.\n\t\tif (node._parent) node._parent.removeChild(node);\n\n\t\t// Link in graph.\n\t\tconst link = this.graph.link('child', this, node);\n\t\tthis.addGraphChild(this.children, link);\n\n\t\t// Set new parent.\n\t\tnode._parent = this;\n\t\tlink.onDispose(() => (node._parent = null));\n\t\treturn this;\n\t}\n\n\t/** Removes a {@link Node} from the scene. */\n\tpublic removeChild(node: Node): this {\n\t\treturn this.removeGraphChild(this.children, node);\n\t}\n\n\t/** Lists all root {@link Node}s in the scene. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.children.map((p) => p.getChild());\n\t}\n\n\t/** Visits each {@link Node} in the scene, including descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfor (const node of this.listChildren()) node.traverse(fn);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, GraphChildList, Link } from '../graph';\nimport { Accessor } from './accessor';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Skin\n *\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF → Skins](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nexport class Skin extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.SKIN;\n\n\t@GraphChild private skeleton: Link<Skin, Node> | null = null;\n\t@GraphChild private inverseBindMatrices: Link<Skin, Accessor> | null = null;\n\t@GraphChildList private joints: Link<Skin, Node>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.setSkeleton(other.skeleton ? resolve(other.skeleton.getChild()) : null);\n\t\tthis.setInverseBindMatrices(other.inverseBindMatrices ? resolve(other.inverseBindMatrices.getChild()) : null);\n\n\t\tthis.clearGraphChildList(this.joints);\n\t\tother.joints.forEach((link) => this.addJoint(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic getSkeleton(): Node | null {\n\t\treturn this.skeleton ? this.skeleton.getChild() : null;\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic setSkeleton(skeleton: Node | null): this {\n\t\tthis.skeleton = this.graph.link('skeleton', this, skeleton);\n\t\treturn this;\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic getInverseBindMatrices(): Accessor | null {\n\t\treturn this.inverseBindMatrices ? this.inverseBindMatrices.getChild() : null;\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic setInverseBindMatrices(inverseBindMatrices: Accessor | null): this {\n\t\tthis.inverseBindMatrices = this.graph.link('inverseBindMatrices', this, inverseBindMatrices);\n\t\treturn this;\n\t}\n\n\t/** Adds a joint {@link Node} to this {@link Skin}. */\n\tpublic addJoint(joint: Node): this {\n\t\tconst link = this.graph.link('joint', this, joint);\n\t\treturn this.addGraphChild(this.joints, link);\n\t}\n\n\t/** Removes a joint {@link Node} from this {@link Skin}. */\n\tpublic removeJoint(joint: Node): this {\n\t\treturn this.removeGraphChild(this.joints, joint);\n\t}\n\n\t/** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n\tpublic listJoints(): Node[] {\n\t\treturn this.joints.map((link) => link.getChild());\n\t}\n}\n","import { PropertyType, vec2 } from '../constants';\nimport { FileUtils, ImageUtils } from '../utils';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Texture\n *\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF-Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link getImage}() data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF → Textures](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#textures)\n * - [glTF → Images](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nexport class Texture extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.TEXTURE;\n\n\t/** @internal Raw image data for this texture. */\n\tprivate _image: ArrayBuffer | null = null;\n\n\t/** @internal Image MIME type. Required if URI is not set. */\n\tprivate _mimeType = '';\n\n\t/** @internal Image URI. Required if MIME type is not set. */\n\tprivate _uri = '';\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._mimeType = other._mimeType;\n\t\tthis._uri = other._uri;\n\n\t\tif (other._image) this._image = other._image.slice(0);\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * MIME type / format.\n\t */\n\n\t/** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n\tpublic getMimeType(): string {\n\t\treturn this._mimeType || ImageUtils.extensionToMimeType(FileUtils.extension(this._uri));\n\t}\n\n\t/**\n\t * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n\t * have a URI, a MIME type is required for correct export.\n\t */\n\tpublic setMimeType(mimeType: string): this {\n\t\tthis._mimeType = mimeType;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * URI / filename.\n\t */\n\n\t/** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n\tpublic getURI(): string {\n\t\treturn this._uri;\n\t}\n\n\t/**\n\t * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n\t * type, a URI is required for correct export.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis._uri = uri;\n\t\tthis._mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Image data.\n\t */\n\n\t/** Returns the raw image data for this texture. */\n\tpublic getImage(): ArrayBuffer | null {\n\t\treturn this._image;\n\t}\n\n\t/** Sets the raw image data for this texture. */\n\tpublic setImage(image: ArrayBuffer): this {\n\t\tthis._image = image;\n\t\treturn this;\n\t}\n\n\t/** Returns the size, in pixels, of this texture. */\n\tpublic getSize(): vec2 | null {\n\t\tif (!this._image) return null;\n\t\treturn ImageUtils.getSize(this._image, this.getMimeType());\n\t}\n}\n","import { PropertyType, VERSION } from '../constants';\nimport { Extension } from '../extension';\nimport { GraphChild, GraphChildList, Link } from '../graph';\nimport { GLTF } from '../types/gltf';\nimport { Accessor } from './accessor';\nimport { Animation } from './animation';\nimport { Buffer } from './buffer';\nimport { Camera } from './camera';\nimport { Material } from './material';\nimport { Mesh } from './mesh';\nimport { Node } from './node';\nimport { COPY_IDENTITY, Property } from './property';\nimport { PropertyGraph } from './property-graph';\nimport { Scene } from './scene';\nimport { Skin } from './skin';\nimport { Texture } from './texture';\n\n/**\n * # Root\n *\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link .getAsset}().\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); // → [scene x 1]\n * ```\n *\n * Reference: [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport class Root extends Property {\n\tpublic readonly propertyType = PropertyType.ROOT;\n\n\tprivate readonly _asset: GLTF.IAsset = {\n\t\tgenerator: `glTF-Transform ${VERSION}`,\n\t\tversion: '2.0',\n\t};\n\n\tprivate readonly _extensions: Set<Extension> = new Set();\n\n\t@GraphChild private defaultScene: Link<Root, Scene> | null = null;\n\n\t@GraphChildList private accessors: Link<Root, Accessor>[] = [];\n\t@GraphChildList private animations: Link<Root, Animation>[] = [];\n\t@GraphChildList private buffers: Link<Root, Buffer>[] = [];\n\t@GraphChildList private cameras: Link<Root, Camera>[] = [];\n\t@GraphChildList private materials: Link<Root, Material>[] = [];\n\t@GraphChildList private meshes: Link<Root, Mesh>[] = [];\n\t@GraphChildList private nodes: Link<Root, Node>[] = [];\n\t@GraphChildList private scenes: Link<Root, Scene>[] = [];\n\t@GraphChildList private skins: Link<Root, Skin>[] = [];\n\t@GraphChildList private textures: Link<Root, Texture>[] = [];\n\n\t/** @internal */\n\tconstructor(graph: PropertyGraph) {\n\t\tsuper(graph);\n\t\tgraph.on('clone', (target) => this._addChildOfRoot(target));\n\t}\n\n\tpublic clone(): this {\n\t\tthrow new Error('Root cannot be cloned.');\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\t// Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n\t\t// the Document during cloning. The Root, and only the Root, should avoid calling\n\t\t// .clearGraphChildList() while copying to avoid overwriting existing links during a merge.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');\n\n\t\tObject.assign(this._asset, other._asset);\n\n\t\tother.accessors.forEach((link) => this._addAccessor(resolve(link.getChild())));\n\t\tother.animations.forEach((link) => this._addAnimation(resolve(link.getChild())));\n\t\tother.buffers.forEach((link) => this._addBuffer(resolve(link.getChild())));\n\t\tother.cameras.forEach((link) => this._addCamera(resolve(link.getChild())));\n\t\tother.materials.forEach((link) => this._addMaterial(resolve(link.getChild())));\n\t\tother.meshes.forEach((link) => this._addMesh(resolve(link.getChild())));\n\t\tother.nodes.forEach((link) => this._addNode(resolve(link.getChild())));\n\t\tother.scenes.forEach((link) => this._addScene(resolve(link.getChild())));\n\t\tother.skins.forEach((link) => this._addSkin(resolve(link.getChild())));\n\t\tother.textures.forEach((link) => this._addTexture(resolve(link.getChild())));\n\n\t\tthis.setDefaultScene(other.defaultScene ? resolve(other.defaultScene.getChild()) : null);\n\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tpublic _addChildOfRoot(child: unknown): this {\n\t\t// TODO(cleanup): Extra private helpers could probably be removed, here.\n\t\tif (child instanceof Scene) {\n\t\t\tthis._addScene(child as Scene);\n\t\t} else if (child instanceof Node) {\n\t\t\tthis._addNode(child as Node);\n\t\t} else if (child instanceof Camera) {\n\t\t\tthis._addCamera(child as Camera);\n\t\t} else if (child instanceof Skin) {\n\t\t\tthis._addSkin(child as Skin);\n\t\t} else if (child instanceof Mesh) {\n\t\t\tthis._addMesh(child as Mesh);\n\t\t} else if (child instanceof Material) {\n\t\t\tthis._addMaterial(child as Material);\n\t\t} else if (child instanceof Texture) {\n\t\t\tthis._addTexture(child as Texture);\n\t\t} else if (child instanceof Animation) {\n\t\t\tthis._addAnimation(child as Animation);\n\t\t} else if (child instanceof Accessor) {\n\t\t\tthis._addAccessor(child as Accessor);\n\t\t} else if (child instanceof Buffer) {\n\t\t\tthis._addBuffer(child as Buffer);\n\t\t}\n\t\t// No error for untracked property types.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n\t * metadata can be stored in optional properties such as `generator` or `copyright`.\n\t *\n\t * Reference: [glTF → Asset](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#asset)\n\t */\n\tpublic getAsset(): GLTF.IAsset {\n\t\treturn this._asset;\n\t}\n\n\t/**********************************************************************************************\n\t * Extensions.\n\t */\n\n\t/** Lists all {@link Extension} properties enabled for this root. */\n\tpublic listExtensionsUsed(): Extension[] {\n\t\treturn Array.from(this._extensions);\n\t}\n\n\t/** Lists all {@link Extension} properties enabled and required for this root. */\n\tpublic listExtensionsRequired(): Extension[] {\n\t\treturn this.listExtensionsUsed().filter((extension) => extension.isRequired());\n\t}\n\n\t/** @internal */\n\tpublic _enableExtension(extension: Extension): this {\n\t\tthis._extensions.add(extension);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tpublic _disableExtension(extension: Extension): this {\n\t\tthis._extensions.delete(extension);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Scenes.\n\t */\n\n\t/**\n\t * Adds a new {@link Scene} to the root list.\n\t * @internal\n\t */\n\tpublic _addScene(scene: Scene): this {\n\t\treturn this.addGraphChild(this.scenes, this.graph.link('scene', this, scene));\n\t}\n\n\t/** Lists all {@link Scene} properties associated with this root. */\n\tpublic listScenes(): Scene[] {\n\t\treturn this.scenes.map((p) => p.getChild());\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic setDefaultScene(defaultScene: Scene | null): this {\n\t\tthis.defaultScene = this.graph.link('scene', this, defaultScene);\n\t\treturn this;\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic getDefaultScene(): Scene | null {\n\t\treturn this.defaultScene ? this.defaultScene.getChild() : null;\n\t}\n\n\t/**********************************************************************************************\n\t * Nodes.\n\t */\n\n\t/**\n\t * Adds a new {@link Node} to the root list.\n\t * @internal\n\t */\n\tpublic _addNode(node: Node): this {\n\t\treturn this.addGraphChild(this.nodes, this.graph.link('node', this, node));\n\t}\n\n\t/** Lists all {@link Node} properties associated with this root. */\n\tpublic listNodes(): Node[] {\n\t\treturn this.nodes.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Cameras.\n\t */\n\n\t/**\n\t * Adds a new {@link Camera} to the root list.\n\t * @internal\n\t */\n\tpublic _addCamera(camera: Camera): this {\n\t\treturn this.addGraphChild(this.cameras, this.graph.link('camera', this, camera));\n\t}\n\n\t/** Lists all {@link Camera} properties associated with this root. */\n\tpublic listCameras(): Camera[] {\n\t\treturn this.cameras.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Skins.\n\t */\n\n\t/**\n\t * Adds a new {@link Skin} to the root list.\n\t * @internal\n\t */\n\tpublic _addSkin(skin: Skin): this {\n\t\treturn this.addGraphChild(this.skins, this.graph.link('skin', this, skin));\n\t}\n\n\t/** Lists all {@link Skin} properties associated with this root. */\n\tpublic listSkins(): Skin[] {\n\t\treturn this.skins.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Meshes.\n\t */\n\n\t/**\n\t * Adds a new {@link Mesh} to the root list.\n\t * @internal\n\t */\n\tpublic _addMesh(mesh: Mesh): this {\n\t\treturn this.addGraphChild(this.meshes, this.graph.link('mesh', this, mesh));\n\t}\n\n\t/** Lists all {@link Mesh} properties associated with this root. */\n\tpublic listMeshes(): Mesh[] {\n\t\treturn this.meshes.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Materials.\n\t */\n\n\t/**\n\t * Adds a new {@link Material} to the root list.\n\t * @internal\n\t */\n\tpublic _addMaterial(material: Material): this {\n\t\treturn this.addGraphChild(this.materials, this.graph.link('material', this, material));\n\t}\n\n\t/** Lists all {@link Material} properties associated with this root. */\n\tpublic listMaterials(): Material[] {\n\t\treturn this.materials.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Textures.\n\t */\n\n\t/**\n\t * Adds a new {@link Texture} to the root list.\n\t * @internal\n\t */\n\tpublic _addTexture(texture: Texture): this {\n\t\treturn this.addGraphChild(this.textures, this.graph.link('texture', this, texture));\n\t}\n\n\t/** Lists all {@link Texture} properties associated with this root. */\n\tpublic listTextures(): Texture[] {\n\t\treturn this.textures.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Animations.\n\t */\n\n\t/**\n\t * Adds a new {@link Animation} to the root list.\n\t * @internal\n\t */\n\tpublic _addAnimation(animation: Animation): this {\n\t\treturn this.addGraphChild(this.animations, this.graph.link('animation', this, animation));\n\t}\n\n\t/** Lists all {@link Animation} properties associated with this root. */\n\tpublic listAnimations(): Animation[] {\n\t\treturn this.animations.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Accessors.\n\t */\n\n\t/**\n\t * Adds a new {@link Accessor} to the root list.\n\t * @internal\n\t */\n\tpublic _addAccessor(accessor: Accessor): this {\n\t\treturn this.addGraphChild(this.accessors, this.graph.link('accessor', this, accessor));\n\t}\n\n\t/** Lists all {@link Accessor} properties associated with this root. */\n\tpublic listAccessors(): Accessor[] {\n\t\treturn this.accessors.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Buffers.\n\t */\n\n\t/**\n\t * Adds a new {@link Buffer} to the root list.\n\t * @internal\n\t */\n\tpublic _addBuffer(buffer: Buffer): this {\n\t\treturn this.addGraphChild(this.buffers, this.graph.link('buffer', this, buffer));\n\t}\n\n\t/** Lists all {@link Buffer} properties associated with this root. */\n\tpublic listBuffers(): Buffer[] {\n\t\treturn this.buffers.map((p) => p.getChild());\n\t}\n}\n","import { PropertyType } from './constants';\nimport { Extension } from './extension';\nimport {\n\tAccessor,\n\tAnimation,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBuffer,\n\tCamera,\n\tExtensionProperty,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tPropertyGraph,\n\tRoot,\n\tScene,\n\tSkin,\n\tTexture,\n} from './properties';\nimport { Logger } from './utils';\n\nexport interface TransformContext {\n\tstack: string[];\n}\n\nexport type Transform = (doc: Document, context?: TransformContext) => void;\n\n/**\n * # Document\n *\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/functions';\n *\n * const doc = new Document();\n *\n * const texture1 = doc.createTexture('myTexture')\n * \t.setImage(arrayBuffer)\n * \t.setMimeType('image/png');\n * const texture2 = doc.createTexture('myTexture2')\n * \t.setImage(arrayBuffer)\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * doc.getRoot().listTextures(); // → [texture x 2]\n *\n * await doc.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * doc.getRoot().listTextures(); // → [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF → Basics](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#gltf-basics)\n * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nexport class Document {\n\tprivate _graph: PropertyGraph = new PropertyGraph();\n\tprivate _root: Root = new Root(this._graph);\n\tprivate _logger = Logger.DEFAULT_INSTANCE;\n\n\t/** Returns the glTF {@link Root} property. */\n\tpublic getRoot(): Root {\n\t\treturn this._root;\n\t}\n\n\t/**\n\t * Returns the {@link Graph} representing connectivity of resources within this document.\n\t *\n\t * @hidden\n\t */\n\tpublic getGraph(): PropertyGraph {\n\t\treturn this._graph;\n\t}\n\n\t/** Returns the {@link Logger} instance used for any operations performed on this document. */\n\tpublic getLogger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Overrides the {@link Logger} instance used for any operations performed on this document.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * doc\n\t * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n\t * \t.transform(dedup(), weld());\n\t * ```\n\t */\n\tpublic setLogger(logger: Logger): Document {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Clones this Document, copying all resources within it. */\n\tpublic clone(): Document {\n\t\treturn new Document().merge(this).setLogger(this._logger);\n\t}\n\n\t/** Merges the content of another Document into this one, without affecting the original. */\n\tpublic merge(other: Document): this {\n\t\t// 1. Attach extensions.\n\t\tconst thisExtensions: { [key: string]: Extension } = {};\n\t\tfor (const otherExtension of other.getRoot().listExtensionsUsed()) {\n\t\t\tconst thisExtension = this.createExtension(otherExtension.constructor as new (doc: Document) => Extension);\n\t\t\tif (otherExtension.isRequired()) thisExtension.setRequired(true);\n\t\t\tthisExtensions[thisExtension.extensionName] = thisExtension;\n\t\t}\n\n\t\t// 2. Preconfigure the Root and merge history.\n\t\tconst visited = new Set<Property>();\n\t\tconst propertyMap = new Map<Property, Property>();\n\t\tvisited.add(other._root);\n\t\tpropertyMap.set(other._root, this._root);\n\n\t\t// 3. Create stub classes for every Property in other Document.\n\t\tfor (const link of other._graph.getLinks()) {\n\t\t\tfor (const thisProp of [link.getParent() as Property, link.getChild() as Property]) {\n\t\t\t\tif (visited.has(thisProp)) continue;\n\n\t\t\t\tlet otherProp: Property;\n\t\t\t\tif (thisProp.propertyType === PropertyType.TEXTURE_INFO) {\n\t\t\t\t\t// TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n\t\t\t\t\t// TODO(cleanup): Should the lifecycle be decoupled? Maybe just create\n\t\t\t\t\t// TextureInfo automatically when appending a Texture to a Material or\n\t\t\t\t\t// ExtensionProperty that doesn't have one? More work for extensions.\n\t\t\t\t\totherProp = thisProp as Property;\n\t\t\t\t} else {\n\t\t\t\t\t// For other property types, create stub classes.\n\t\t\t\t\tconst PropertyClass = thisProp.constructor as new (g: PropertyGraph, e?: Extension) => Property;\n\t\t\t\t\totherProp =\n\t\t\t\t\t\tthisProp instanceof ExtensionProperty\n\t\t\t\t\t\t\t? new PropertyClass(this._graph, thisExtensions[thisProp.extensionName])\n\t\t\t\t\t\t\t: new PropertyClass(this._graph);\n\t\t\t\t}\n\n\t\t\t\tpropertyMap.set(thisProp as Property, otherProp);\n\t\t\t\tvisited.add(thisProp);\n\t\t\t}\n\t\t}\n\n\t\t// 4. Assemble the links between Properties.\n\t\tconst resolve = (p: Property): Property => {\n\t\t\tconst resolved = propertyMap.get(p);\n\t\t\tif (!resolved) throw new Error('Could resolve property.');\n\t\t\treturn resolved;\n\t\t};\n\t\tfor (const otherProp of visited) {\n\t\t\tconst thisProp = propertyMap.get(otherProp);\n\t\t\tif (!thisProp) throw new Error('Could resolve property.');\n\t\t\tthisProp.copy(otherProp, resolve);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a series of modifications to this document. Each transformation is asynchronous,\n\t * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n\t * order given, which may affect the final result.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * await doc.transform(\n\t * \tdedup(),\n\t * \tprune()\n\t * );\n\t * ```\n\t *\n\t * @param transforms List of synchronous transformation functions to apply.\n\t */\n\tpublic async transform(...transforms: Transform[]): Promise<this> {\n\t\tconst stack = transforms.map((fn) => fn.name);\n\t\tfor (const transform of transforms) {\n\t\t\tawait transform(this, { stack });\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extension factory method.\n\t */\n\n\t/**\n\t * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n\t * extension is already enabled for this Document, the previous Extension reference is reused.\n\t */\n\tcreateExtension<T extends Extension>(ctor: new (doc: Document) => T): T {\n\t\tconst extensionName = (ctor as unknown as { EXTENSION_NAME: 'string' }).EXTENSION_NAME;\n\t\tconst prevExtension = this.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.find((ext) => ext.extensionName === extensionName);\n\t\treturn (prevExtension || new ctor(this)) as T;\n\t}\n\n\t/**********************************************************************************************\n\t * Property factory methods.\n\t */\n\n\t/** Creates a new {@link Scene} attached to this document's {@link Root}. */\n\tcreateScene(name = ''): Scene {\n\t\tconst scene = new Scene(this._graph, name);\n\t\tthis._root._addScene(scene);\n\t\treturn scene;\n\t}\n\n\t/** Creates a new {@link Node} attached to this document's {@link Root}. */\n\tcreateNode(name = ''): Node {\n\t\tconst node = new Node(this._graph, name);\n\t\tthis._root._addNode(node);\n\t\treturn node;\n\t}\n\n\t/** Creates a new {@link Camera} attached to this document's {@link Root}. */\n\tcreateCamera(name = ''): Camera {\n\t\tconst camera = new Camera(this._graph, name);\n\t\tthis._root._addCamera(camera);\n\t\treturn camera;\n\t}\n\n\t/** Creates a new {@link Skin} attached to this document's {@link Root}. */\n\tcreateSkin(name = ''): Skin {\n\t\tconst skin = new Skin(this._graph, name);\n\t\tthis._root._addSkin(skin);\n\t\treturn skin;\n\t}\n\n\t/** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n\tcreateMesh(name = ''): Mesh {\n\t\tconst mesh = new Mesh(this._graph, name);\n\t\tthis._root._addMesh(mesh);\n\t\treturn mesh;\n\t}\n\n\t/**\n\t * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitive(): Primitive {\n\t\treturn new Primitive(this._graph);\n\t}\n\n\t/**\n\t * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n\t * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitiveTarget(name = ''): PrimitiveTarget {\n\t\treturn new PrimitiveTarget(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Material} attached to this document's {@link Root}. */\n\tcreateMaterial(name = ''): Material {\n\t\tconst material = new Material(this._graph, name);\n\t\tthis._root._addMaterial(material);\n\t\treturn material;\n\t}\n\n\t/** Creates a new {@link Texture} attached to this document's {@link Root}. */\n\tcreateTexture(name = ''): Texture {\n\t\tconst texture = new Texture(this._graph, name);\n\t\tthis._root._addTexture(texture);\n\t\treturn texture;\n\t}\n\n\t/** Creates a new {@link Animation} attached to this document's {@link Root}. */\n\tcreateAnimation(name = ''): Animation {\n\t\tconst animation = new Animation(this._graph, name);\n\t\tthis._root._addAnimation(animation);\n\t\treturn animation;\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationChannel(name = ''): AnimationChannel {\n\t\treturn new AnimationChannel(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationSampler(name = ''): AnimationSampler {\n\t\treturn new AnimationSampler(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n\tcreateAccessor(name = '', buffer: Buffer | null = null): Accessor {\n\t\tif (!buffer) {\n\t\t\tbuffer = this.getRoot().listBuffers()[0];\n\t\t}\n\t\tconst accessor = new Accessor(this._graph, name).setBuffer(buffer);\n\t\tthis._root._addAccessor(accessor);\n\t\treturn accessor;\n\t}\n\n\t/** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n\tcreateBuffer(name = ''): Buffer {\n\t\tconst buffer = new Buffer(this._graph, name);\n\t\tthis._root._addBuffer(buffer);\n\t\treturn buffer;\n\t}\n}\n","import { PropertyType } from './constants';\nimport { Document } from './document';\nimport { ReaderContext, WriterContext } from './io';\nimport { ExtensionProperty, ExtensionPropertyParent } from './properties';\n\n/**\n * # Extension\n *\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/glTF/blob/master/extensions)\n *\n * @category Extensions\n */\nexport abstract class Extension implements ExtensionPropertyParent {\n\t/** Official name of the extension. */\n\tpublic static EXTENSION_NAME: string;\n\t/** Official name of the extension. */\n\tpublic readonly extensionName: string = '';\n\t/**\n\t * Before reading, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t */\n\tpublic readonly prereadTypes: PropertyType[] = [];\n\t/**\n\t * Before writing, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t */\n\tpublic readonly prewriteTypes: PropertyType[] = [];\n\n\t/** Dependency IDs needed by this extension, to be installed before I/O. */\n\tpublic readonly readDependencies: string[] = [];\n\tpublic readonly writeDependencies: string[] = [];\n\n\tprotected required = false;\n\tprotected properties: Set<ExtensionProperty> = new Set();\n\n\t/** @hidden */\n\tconstructor(protected readonly doc: Document) {\n\t\tdoc.getRoot()._enableExtension(this);\n\t}\n\n\t/** Disables and removes the extension from the Document. */\n\tpublic dispose(): void {\n\t\tthis.doc.getRoot()._disableExtension(this);\n\t\tfor (const property of this.properties) {\n\t\t\tproperty.dispose();\n\t\t}\n\t}\n\n\t/** Performs first-time setup for the extension. Must be idempotent. */\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tpublic static register(): void {}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic isRequired(): boolean {\n\t\treturn this.required;\n\t}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic setRequired(required: boolean): this {\n\t\tthis.required = required;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * ExtensionPropertyParent implementation.\n\t */\n\n\t/** @hidden */\n\tpublic addExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.add(property);\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic removeExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.delete(property);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * I/O implementation.\n\t */\n\n\t/** Installs dependencies required by the extension. */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic install(key: string, dependency: unknown): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n\t * be given a ReaderContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t */\n\tpublic preread(_readerContext: ReaderContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n\t * be given a WriterContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t */\n\tpublic prewrite(_writerContext: WriterContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method must be\n\t * implemented by each extension in order to support reading files. The extension will be\n\t * given a ReaderContext instance, and should update the current {@link Document} accordingly.\n\t */\n\tpublic abstract read(readerContext: ReaderContext): this;\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method must be\n\t * implemented by each extension in order to support writing files. The extension will be\n\t * given a WriterContext instance, and should modify the {@link JSONDocument} output\n\t * accordingly. Adding the extension name to the `extensionsUsed` and `extensionsRequired` list\n\t * is done automatically, and should not be included here.\n\t */\n\tpublic abstract write(writerContext: WriterContext): this;\n}\n","import { JSONDocument } from '../json-document';\nimport {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties';\nimport { GLTF } from '../types/gltf';\n\n/**\n * Model class providing glTF-Transform objects representing each definition in the glTF file, used\n * by a {@link Writer} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n *\n * @hidden\n */\nexport class ReaderContext {\n\tpublic buffers: Buffer[] = [];\n\tpublic bufferViews: Uint8Array[] = [];\n\tpublic bufferViewBuffers: Buffer[] = [];\n\tpublic accessors: Accessor[] = [];\n\tpublic textures: Texture[] = [];\n\tpublic textureInfos: Map<TextureInfo, GLTF.ITextureInfo> = new Map();\n\tpublic materials: Material[] = [];\n\tpublic meshes: Mesh[] = [];\n\tpublic cameras: Camera[] = [];\n\tpublic nodes: Node[] = [];\n\tpublic skins: Skin[] = [];\n\tpublic animations: Animation[] = [];\n\tpublic scenes: Scene[] = [];\n\n\tconstructor(public readonly jsonDoc: JSONDocument) {}\n\n\tpublic setTextureInfo(textureInfo: TextureInfo, textureInfoDef: GLTF.ITextureInfo): void {\n\t\tthis.textureInfos.set(textureInfo, textureInfoDef);\n\n\t\tif (textureInfoDef.texCoord !== undefined) {\n\t\t\ttextureInfo.setTexCoord(textureInfoDef.texCoord);\n\t\t}\n\n\t\tconst textureDef = this.jsonDoc.json.textures![textureInfoDef.index];\n\n\t\tif (textureDef.sampler === undefined) return;\n\n\t\tconst samplerDef = this.jsonDoc.json.samplers![textureDef.sampler];\n\n\t\tif (samplerDef.magFilter !== undefined) {\n\t\t\ttextureInfo.setMagFilter(samplerDef.magFilter);\n\t\t}\n\t\tif (samplerDef.minFilter !== undefined) {\n\t\t\ttextureInfo.setMinFilter(samplerDef.minFilter);\n\t\t}\n\t\tif (samplerDef.wrapS !== undefined) {\n\t\t\ttextureInfo.setWrapS(samplerDef.wrapS);\n\t\t}\n\t\tif (samplerDef.wrapT !== undefined) {\n\t\t\ttextureInfo.setWrapT(samplerDef.wrapT);\n\t\t}\n\t}\n}\n","import { GLB_BUFFER, PropertyType, TypedArray, mat4, vec3, vec4 } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { JSONDocument } from '../json-document';\nimport { Accessor, AnimationSampler, Camera } from '../properties';\nimport { GLTF } from '../types/gltf';\nimport { FileUtils, ImageUtils, Logger, MathUtils } from '../utils';\nimport { ReaderContext } from './reader-context';\n\nconst ComponentTypeToTypedArray = {\n\t'5120': Int8Array,\n\t'5121': Uint8Array,\n\t'5122': Int16Array,\n\t'5123': Uint16Array,\n\t'5125': Uint32Array,\n\t'5126': Float32Array,\n};\n\nexport interface ReaderOptions {\n\tlogger?: Logger;\n\textensions: typeof Extension[];\n\tdependencies: { [key: string]: unknown };\n}\n\nconst DEFAULT_OPTIONS: ReaderOptions = {\n\tlogger: Logger.DEFAULT_INSTANCE,\n\textensions: [],\n\tdependencies: {},\n};\n\n/** @internal */\nexport class GLTFReader {\n\tpublic static read(jsonDoc: JSONDocument, _options: ReaderOptions = DEFAULT_OPTIONS): Document {\n\t\tconst options = { ...DEFAULT_OPTIONS, ..._options } as Required<ReaderOptions>;\n\t\tconst { json } = jsonDoc;\n\t\tconst doc = new Document();\n\n\t\tthis.validate(jsonDoc, options);\n\n\t\t/* Reader context. */\n\n\t\tconst context = new ReaderContext(jsonDoc);\n\n\t\t/** Asset. */\n\n\t\tconst assetDef = json.asset;\n\t\tconst asset = doc.getRoot().getAsset();\n\n\t\tif (assetDef.copyright) asset.copyright = assetDef.copyright;\n\t\tif (assetDef.extras) asset.extras = assetDef.extras;\n\n\t\tif (json.extras !== undefined) {\n\t\t\tdoc.getRoot().setExtras({ ...json.extras });\n\t\t}\n\n\t\t/** Extensions (1/2). */\n\n\t\tconst extensionsUsed = json.extensionsUsed || [];\n\t\tconst extensionsRequired = json.extensionsRequired || [];\n\t\tfor (const Extension of options.extensions) {\n\t\t\tif (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n\t\t\t\tconst extension = doc\n\t\t\t\t\t.createExtension(Extension as unknown as new (doc: Document) => Extension)\n\t\t\t\t\t.setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n\n\t\t\t\tfor (const key of extension.readDependencies) {\n\t\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Buffers. */\n\n\t\tconst bufferDefs = json.buffers || [];\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.BUFFER));\n\t\tcontext.buffers = bufferDefs.map((bufferDef) => {\n\t\t\tconst buffer = doc.createBuffer(bufferDef.name);\n\n\t\t\tif (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n\n\t\t\tif (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n\t\t\t\tbuffer.setURI(bufferDef.uri);\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t});\n\n\t\t/** Buffer views. */\n\n\t\tconst bufferViewDefs = json.bufferViews || [];\n\t\tcontext.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n\t\t\tif (!context.bufferViews[index]) {\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tconst bufferView = new Uint8Array(resource, byteOffset, bufferViewDef.byteLength);\n\t\t\t\tcontext.bufferViews[index] = bufferView;\n\t\t\t}\n\n\t\t\treturn context.buffers[bufferViewDef.buffer];\n\t\t});\n\n\t\t/** Accessors. */\n\n\t\t// Accessor .count and .componentType properties are inferred dynamically.\n\t\tconst accessorDefs = json.accessors || [];\n\t\tcontext.accessors = accessorDefs.map((accessorDef) => {\n\t\t\tconst buffer = context.bufferViewBuffers[accessorDef.bufferView!];\n\t\t\tconst accessor = doc.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n\n\t\t\tif (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n\n\t\t\tif (accessorDef.normalized !== undefined) {\n\t\t\t\taccessor.setNormalized(accessorDef.normalized);\n\t\t\t}\n\n\t\t\t// KHR_draco_mesh_compression and EXT_meshopt_compression.\n\t\t\tif (accessorDef.bufferView === undefined && !accessorDef.sparse) return accessor;\n\n\t\t\tlet array: TypedArray;\n\n\t\t\tif (accessorDef.sparse !== undefined) {\n\t\t\t\tarray = getSparseArray(accessorDef, context);\n\t\t\t} else {\n\t\t\t\tarray = getAccessorArray(accessorDef, context);\n\t\t\t}\n\n\t\t\taccessor.setArray(array);\n\t\t\treturn accessor;\n\t\t});\n\n\t\t/** Textures. */\n\n\t\t// glTF-Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tconst imageDefs = json.images || [];\n\t\tconst textureDefs = json.textures || [];\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.TEXTURE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.TEXTURE));\n\t\tcontext.textures = imageDefs.map((imageDef) => {\n\t\t\tconst texture = doc.createTexture(imageDef.name);\n\n\t\t\t// glTF Image corresponds 1:1 with glTF-Transform Texture. See `writer.ts`.\n\t\t\tif (imageDef.extras) texture.setExtras(imageDef.extras);\n\n\t\t\tif (imageDef.bufferView !== undefined) {\n\t\t\t\tconst bufferViewDef = json.bufferViews![imageDef.bufferView];\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\tconst imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n\t\t\t\ttexture.setImage(imageData);\n\t\t\t} else if (imageDef.uri !== undefined) {\n\t\t\t\ttexture.setImage(jsonDoc.resources[imageDef.uri]);\n\t\t\t\tif (imageDef.uri.indexOf('__') !== 0) {\n\t\t\t\t\ttexture.setURI(imageDef.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (imageDef.mimeType !== undefined) {\n\t\t\t\ttexture.setMimeType(imageDef.mimeType);\n\t\t\t} else if (imageDef.uri) {\n\t\t\t\tconst extension = FileUtils.extension(imageDef.uri);\n\t\t\t\ttexture.setMimeType(ImageUtils.extensionToMimeType(extension));\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t});\n\n\t\t/** Materials. */\n\n\t\tconst materialDefs = json.materials || [];\n\t\tcontext.materials = materialDefs.map((materialDef) => {\n\t\t\tconst material = doc.createMaterial(materialDef.name);\n\n\t\t\tif (materialDef.extras) material.setExtras(materialDef.extras);\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (materialDef.alphaMode !== undefined) {\n\t\t\t\tmaterial.setAlphaMode(materialDef.alphaMode);\n\t\t\t}\n\n\t\t\tif (materialDef.alphaCutoff !== undefined) {\n\t\t\t\tmaterial.setAlphaCutoff(materialDef.alphaCutoff);\n\t\t\t}\n\n\t\t\tif (materialDef.doubleSided !== undefined) {\n\t\t\t\tmaterial.setDoubleSided(materialDef.doubleSided);\n\t\t\t}\n\n\t\t\t// Factors.\n\n\t\t\tconst pbrDef = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tif (pbrDef.baseColorFactor !== undefined) {\n\t\t\t\tmaterial.setBaseColorFactor(pbrDef.baseColorFactor as vec4);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveFactor !== undefined) {\n\t\t\t\tmaterial.setEmissiveFactor(materialDef.emissiveFactor as vec3);\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicFactor !== undefined) {\n\t\t\t\tmaterial.setMetallicFactor(pbrDef.metallicFactor);\n\t\t\t}\n\n\t\t\tif (pbrDef.roughnessFactor !== undefined) {\n\t\t\t\tmaterial.setRoughnessFactor(pbrDef.roughnessFactor);\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (pbrDef.baseColorTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.baseColorTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setBaseColorTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getBaseColorTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.emissiveTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setEmissiveTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getEmissiveTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.normalTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.normalTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setNormalTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getNormalTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\t\t\t\t\tmaterial.setNormalScale(materialDef.normalTexture.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (materialDef.occlusionTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.occlusionTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setOcclusionTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getOcclusionTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\t\t\t\t\tmaterial.setOcclusionStrength(materialDef.occlusionTexture.strength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicRoughnessTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.metallicRoughnessTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setMetallicRoughnessTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getMetallicRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\treturn material;\n\t\t});\n\n\t\t/** Meshes. */\n\n\t\tconst meshDefs = json.meshes || [];\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.PRIMITIVE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.PRIMITIVE));\n\t\tcontext.meshes = meshDefs.map((meshDef) => {\n\t\t\tconst mesh = doc.createMesh(meshDef.name);\n\n\t\t\tif (meshDef.extras) mesh.setExtras(meshDef.extras);\n\n\t\t\tif (meshDef.weights !== undefined) {\n\t\t\t\tmesh.setWeights(meshDef.weights);\n\t\t\t}\n\n\t\t\tconst primitiveDefs = meshDef.primitives || [];\n\t\t\tprimitiveDefs.forEach((primitiveDef) => {\n\t\t\t\tconst primitive = doc.createPrimitive();\n\n\t\t\t\tif (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n\n\t\t\t\tif (primitiveDef.material !== undefined) {\n\t\t\t\t\tprimitive.setMaterial(context.materials[primitiveDef.material]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.mode !== undefined) {\n\t\t\t\t\tprimitive.setMode(primitiveDef.mode);\n\t\t\t\t}\n\n\t\t\t\tfor (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n\t\t\t\t\tprimitive.setAttribute(semantic, context.accessors[index]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.indices !== undefined) {\n\t\t\t\t\tprimitive.setIndices(context.accessors[primitiveDef.indices]);\n\t\t\t\t}\n\n\t\t\t\tconst targetNames: string[] = (meshDef.extras && (meshDef.extras.targetNames as string[])) || [];\n\t\t\t\tconst targetDefs = primitiveDef.targets || [];\n\t\t\t\ttargetDefs.forEach((targetDef, targetIndex) => {\n\t\t\t\t\tconst targetName = targetNames[targetIndex] || targetIndex.toString();\n\t\t\t\t\tconst target = doc.createPrimitiveTarget(targetName);\n\n\t\t\t\t\tfor (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n\t\t\t\t\t\ttarget.setAttribute(semantic, context.accessors[accessorIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitive.addTarget(target);\n\t\t\t\t});\n\n\t\t\t\tmesh.addPrimitive(primitive);\n\t\t\t});\n\n\t\t\treturn mesh;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tconst cameraDefs = json.cameras || [];\n\t\tcontext.cameras = cameraDefs.map((cameraDef) => {\n\t\t\tconst camera = doc.createCamera(cameraDef.name).setType(cameraDef.type);\n\n\t\t\tif (cameraDef.extras) camera.setExtras(cameraDef.extras);\n\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tconst perspectiveDef = cameraDef.perspective!;\n\t\t\t\tcamera.setYFov(perspectiveDef.yfov);\n\t\t\t\tcamera.setZNear(perspectiveDef.znear);\n\t\t\t\tif (perspectiveDef.zfar !== undefined) {\n\t\t\t\t\tcamera.setZFar(perspectiveDef.zfar);\n\t\t\t\t}\n\t\t\t\tif (perspectiveDef.aspectRatio !== undefined) {\n\t\t\t\t\tcamera.setAspectRatio(perspectiveDef.aspectRatio);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst orthoDef = cameraDef.orthographic!;\n\t\t\t\tcamera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n\t\t\t}\n\t\t\treturn camera;\n\t\t});\n\n\t\t/** Nodes. */\n\n\t\tconst nodeDefs = json.nodes || [];\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.NODE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.NODE));\n\n\t\tcontext.nodes = nodeDefs.map((nodeDef) => {\n\t\t\tconst node = doc.createNode(nodeDef.name);\n\n\t\t\tif (nodeDef.extras) node.setExtras(nodeDef.extras);\n\n\t\t\tif (nodeDef.translation !== undefined) {\n\t\t\t\tnode.setTranslation(nodeDef.translation as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.rotation !== undefined) {\n\t\t\t\tnode.setRotation(nodeDef.rotation as vec4);\n\t\t\t}\n\n\t\t\tif (nodeDef.scale !== undefined) {\n\t\t\t\tnode.setScale(nodeDef.scale as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\t\t\t\tconst translation = [0, 0, 0] as vec3;\n\t\t\t\tconst rotation = [0, 0, 0, 1] as vec4;\n\t\t\t\tconst scale = [1, 1, 1] as vec3;\n\n\t\t\t\tMathUtils.decompose(nodeDef.matrix as mat4, translation, rotation, scale);\n\n\t\t\t\tnode.setTranslation(translation);\n\t\t\t\tnode.setRotation(rotation);\n\t\t\t\tnode.setScale(scale);\n\t\t\t}\n\n\t\t\tif (nodeDef.weights !== undefined) {\n\t\t\t\tnode.setWeights(nodeDef.weights);\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in reading process.\n\n\t\t\treturn node;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tconst skinDefs = json.skins || [];\n\t\tcontext.skins = skinDefs.map((skinDef) => {\n\t\t\tconst skin = doc.createSkin(skinDef.name);\n\n\t\t\tif (skinDef.extras) skin.setExtras(skinDef.extras);\n\n\t\t\tif (skinDef.inverseBindMatrices !== undefined) {\n\t\t\t\tskin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n\t\t\t}\n\n\t\t\tif (skinDef.skeleton !== undefined) {\n\t\t\t\tskin.setSkeleton(context.nodes[skinDef.skeleton]);\n\t\t\t}\n\n\t\t\tfor (const nodeIndex of skinDef.joints) {\n\t\t\t\tskin.addJoint(context.nodes[nodeIndex]);\n\t\t\t}\n\n\t\t\treturn skin;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\tnodeDefs.map((nodeDef, nodeIndex) => {\n\t\t\tconst node = context.nodes[nodeIndex];\n\n\t\t\tconst children = nodeDef.children || [];\n\t\t\tchildren.forEach((childIndex) => node.addChild(context.nodes[childIndex]));\n\n\t\t\tif (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n\n\t\t\tif (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n\n\t\t\tif (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tconst animationDefs = json.animations || [];\n\t\tcontext.animations = animationDefs.map((animationDef) => {\n\t\t\tconst animation = doc.createAnimation(animationDef.name);\n\n\t\t\tif (animationDef.extras) animation.setExtras(animationDef.extras);\n\n\t\t\tconst samplerDefs = animationDef.samplers || [];\n\t\t\tconst samplers = samplerDefs.map((samplerDef) => {\n\t\t\t\tconst sampler = doc\n\t\t\t\t\t.createAnimationSampler()\n\t\t\t\t\t.setInput(context.accessors[samplerDef.input])\n\t\t\t\t\t.setOutput(context.accessors[samplerDef.output])\n\t\t\t\t\t.setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n\n\t\t\t\tif (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n\n\t\t\t\tanimation.addSampler(sampler);\n\t\t\t\treturn sampler;\n\t\t\t});\n\n\t\t\tconst channels = animationDef.channels || [];\n\t\t\tchannels.forEach((channelDef) => {\n\t\t\t\tconst channel = doc\n\t\t\t\t\t.createAnimationChannel()\n\t\t\t\t\t.setSampler(samplers[channelDef.sampler])\n\t\t\t\t\t.setTargetNode(context.nodes[channelDef.target.node])\n\t\t\t\t\t.setTargetPath(channelDef.target.path);\n\n\t\t\t\tif (channelDef.extras) channel.setExtras(channelDef.extras);\n\n\t\t\t\tanimation.addChannel(channel);\n\t\t\t});\n\n\t\t\treturn animation;\n\t\t});\n\n\t\t/** Scenes. */\n\n\t\tconst sceneDefs = json.scenes || [];\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.SCENE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.SCENE));\n\n\t\tcontext.scenes = sceneDefs.map((sceneDef) => {\n\t\t\tconst scene = doc.createScene(sceneDef.name);\n\n\t\t\tif (sceneDef.extras) scene.setExtras(sceneDef.extras);\n\n\t\t\tconst children = sceneDef.nodes || [];\n\n\t\t\tchildren.map((nodeIndex) => context.nodes[nodeIndex]).forEach((node) => scene.addChild(node));\n\n\t\t\treturn scene;\n\t\t});\n\n\t\tif (json.scene !== undefined) {\n\t\t\tdoc.getRoot().setDefaultScene(context.scenes[json.scene]);\n\t\t}\n\n\t\t/** Extensions (2/2). */\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.forEach((extension) => extension.read(context));\n\n\t\treturn doc;\n\t}\n\n\tprivate static validate(jsonDoc: JSONDocument, options: Required<ReaderOptions>): void {\n\t\tconst json = jsonDoc.json;\n\n\t\tif (json.asset.version !== '2.0') {\n\t\t\tthrow new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n\t\t}\n\n\t\tif (json.extensionsRequired) {\n\t\t\tfor (const extensionName of json.extensionsRequired) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\tthrow new Error(`Missing required extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (json.extensionsUsed) {\n\t\t\tfor (const extensionName of json.extensionsUsed) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\toptions.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @internal\n */\nfunction getInterleavedArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst accessorByteOffset = accessorDef.byteOffset || 0;\n\n\tconst array = new TypedArray(accessorDef.count * elementSize);\n\tconst view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\tconst byteStride = bufferViewDef.byteStride!;\n\n\tfor (let i = 0; i < accessorDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tconst byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n\t\t\tlet value: number;\n\t\t\tswitch (accessorDef.componentType) {\n\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\tvalue = view.getFloat32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\tvalue = view.getUint32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\tvalue = view.getUint16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\tvalue = view.getUint8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\tvalue = view.getInt16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\tvalue = view.getInt8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n\t\t\t}\n\t\t\tarray[i * elementSize + j] = value;\n\t\t}\n\t}\n\n\treturn array;\n}\n\n/**\n * Returns the contents of an accessor, as a typed array.\n * @internal\n */\nfunction getAccessorArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst elementStride = elementSize * componentSize;\n\n\t// Interleaved buffer view.\n\tif (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {\n\t\treturn getInterleavedArray(accessorDef, context);\n\t}\n\n\tconst byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n\tconst byteLength = accessorDef.count * elementSize * componentSize;\n\n\t// Might optimize this to avoid deep copy later, but it's useful for now and not a known\n\t// bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.\n\treturn new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\n\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @internal\n */\nfunction getSparseArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\n\tlet array: TypedArray;\n\tif (accessorDef.bufferView !== undefined) {\n\t\tarray = getAccessorArray(accessorDef, context);\n\t} else {\n\t\tarray = new TypedArray(accessorDef.count * elementSize);\n\t}\n\n\tconst sparseDef = accessorDef.sparse!;\n\tconst count = sparseDef.count;\n\tconst indicesDef = { ...accessorDef, ...sparseDef.indices, count, type: 'SCALAR' };\n\tconst valuesDef = { ...accessorDef, ...sparseDef.values, count };\n\tconst indices = getAccessorArray(indicesDef as GLTF.IAccessor, context);\n\tconst values = getAccessorArray(valuesDef, context);\n\n\t// Override indices given in the sparse data.\n\tfor (let i = 0; i < indicesDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tarray[indices[i] * elementSize + j] = values[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn array;\n}\n","import { Format } from '../constants';\nimport { Document } from '../document';\nimport { JSONDocument } from '../json-document';\nimport {\n\tAccessor,\n\tAttributeLink,\n\tBuffer,\n\tCamera,\n\tIndexLink,\n\tMaterial,\n\tMesh,\n\tNode,\n\tProperty,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties';\nimport { GLTF } from '../types/gltf';\nimport { ImageUtils, Logger } from '../utils';\nimport { WriterOptions } from './writer';\n\ntype PropertyDef = GLTF.IScene | GLTF.INode | GLTF.IMaterial | GLTF.ISkin | GLTF.ITexture;\n\nenum BufferViewTarget {\n\tARRAY_BUFFER = 34962,\n\tELEMENT_ARRAY_BUFFER = 34963,\n}\nenum BufferViewUsage {\n\tARRAY_BUFFER = 'ARRAY_BUFFER',\n\tELEMENT_ARRAY_BUFFER = 'ELEMENT_ARRAY_BUFFER',\n\tINVERSE_BIND_MATRICES = 'INVERSE_BIND_MATRICES',\n\tOTHER = 'OTHER',\n}\n\n/**\n * Model class providing writing state to a {@link Writer} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nexport class WriterContext {\n\t/** Explicit buffer view targets defined by glTF specification. */\n\tpublic static readonly BufferViewTarget = BufferViewTarget;\n\t/**\n\t * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for\n\t * proper grouping of accessors into buffer views. Additional usages are defined by extensions,\n\t * like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic static readonly BufferViewUsage = BufferViewUsage;\n\t/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */\n\tpublic static readonly USAGE_TO_TARGET: { [key: string]: BufferViewTarget | undefined } = {\n\t\t[BufferViewUsage.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n\t\t[BufferViewUsage.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER,\n\t};\n\n\tpublic readonly accessorIndexMap = new Map<Accessor, number>();\n\tpublic readonly bufferIndexMap = new Map<Buffer, number>();\n\tpublic readonly cameraIndexMap = new Map<Camera, number>();\n\tpublic readonly skinIndexMap = new Map<Skin, number>();\n\tpublic readonly materialIndexMap = new Map<Material, number>();\n\tpublic readonly meshIndexMap = new Map<Mesh, number>();\n\tpublic readonly nodeIndexMap = new Map<Node, number>();\n\tpublic readonly imageIndexMap = new Map<Texture, number>();\n\tpublic readonly textureDefIndexMap = new Map<string, number>(); // textureDef JSON -> index\n\tpublic readonly textureInfoDefMap = new Map<TextureInfo, GLTF.ITextureInfo>();\n\tpublic readonly samplerDefIndexMap = new Map<string, number>(); // samplerDef JSON -> index\n\n\tpublic readonly imageBufferViews: ArrayBuffer[] = [];\n\tpublic readonly otherBufferViews = new Map<Buffer, ArrayBuffer[]>();\n\tpublic readonly otherBufferViewsIndexMap = new Map<ArrayBuffer, number>();\n\tpublic readonly extensionData: { [key: string]: unknown } = {};\n\n\tpublic bufferURIGenerator: UniqueURIGenerator;\n\tpublic imageURIGenerator: UniqueURIGenerator;\n\tpublic logger: Logger;\n\n\tprivate readonly _accessorUsageMap = new Map<Accessor, BufferViewUsage | string>();\n\tpublic readonly accessorUsageGroupedByParent = new Set<string>(['ARRAY_BUFFER']);\n\tpublic readonly accessorParents = new Map<Property, Set<Accessor>>();\n\n\tconstructor(\n\t\tprivate readonly _doc: Document,\n\t\tpublic readonly jsonDoc: JSONDocument,\n\t\tpublic readonly options: Required<WriterOptions>\n\t) {\n\t\tconst root = _doc.getRoot();\n\t\tconst numBuffers = root.listBuffers().length;\n\t\tconst numImages = root.listTextures().length;\n\t\tthis.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, options.basename);\n\t\tthis.imageURIGenerator = new UniqueURIGenerator(numImages > 1, options.basename);\n\t\tthis.logger = _doc.getLogger();\n\t}\n\n\t/**\n\t * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n\t * possible, Texture and Sampler definitions are shared.\n\t */\n\tpublic createTextureInfoDef(texture: Texture, textureInfo: TextureInfo): GLTF.ITextureInfo {\n\t\tconst samplerDef = {\n\t\t\tmagFilter: textureInfo.getMagFilter() || undefined,\n\t\t\tminFilter: textureInfo.getMinFilter() || undefined,\n\t\t\twrapS: textureInfo.getWrapS(),\n\t\t\twrapT: textureInfo.getWrapT(),\n\t\t} as GLTF.ISampler;\n\n\t\tconst samplerKey = JSON.stringify(samplerDef);\n\t\tif (!this.samplerDefIndexMap.has(samplerKey)) {\n\t\t\tthis.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers!.length);\n\t\t\tthis.jsonDoc.json.samplers!.push(samplerDef);\n\t\t}\n\n\t\tconst textureDef = {\n\t\t\tsource: this.imageIndexMap.get(texture),\n\t\t\tsampler: this.samplerDefIndexMap.get(samplerKey),\n\t\t} as GLTF.ITexture;\n\n\t\tconst textureKey = JSON.stringify(textureDef);\n\t\tif (!this.textureDefIndexMap.has(textureKey)) {\n\t\t\tthis.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures!.length);\n\t\t\tthis.jsonDoc.json.textures!.push(textureDef);\n\t\t}\n\n\t\tconst textureInfoDef = {\n\t\t\tindex: this.textureDefIndexMap.get(textureKey),\n\t\t} as GLTF.ITextureInfo;\n\n\t\tif (textureInfo.getTexCoord() !== 0) {\n\t\t\ttextureInfoDef.texCoord = textureInfo.getTexCoord();\n\t\t}\n\n\t\tthis.textureInfoDefMap.set(textureInfo, textureInfoDef);\n\n\t\treturn textureInfoDef;\n\t}\n\n\tpublic createPropertyDef(property: Property): PropertyDef {\n\t\tconst def = {} as PropertyDef;\n\t\tif (property.getName()) {\n\t\t\tdef.name = property.getName();\n\t\t}\n\t\tif (Object.keys(property.getExtras()).length > 0) {\n\t\t\tdef.extras = property.getExtras();\n\t\t}\n\t\treturn def;\n\t}\n\n\tpublic createAccessorDef(accessor: Accessor): GLTF.IAccessor {\n\t\tconst accessorDef = this.createPropertyDef(accessor) as GLTF.IAccessor;\n\t\taccessorDef.type = accessor.getType();\n\t\taccessorDef.componentType = accessor.getComponentType();\n\t\taccessorDef.count = accessor.getCount();\n\n\t\tconst needsBounds = this._doc\n\t\t\t.getGraph()\n\t\t\t.listParentLinks(accessor)\n\t\t\t.some((link) => link.getName() === 'POSITION' || link.getName() === 'input');\n\t\tif (needsBounds) {\n\t\t\taccessorDef.max = accessor.getMax([]).map(Math.fround);\n\t\t\taccessorDef.min = accessor.getMin([]).map(Math.fround);\n\t\t}\n\n\t\tif (accessor.getNormalized()) {\n\t\t\taccessorDef.normalized = accessor.getNormalized();\n\t\t}\n\n\t\treturn accessorDef;\n\t}\n\n\tpublic createImageData(imageDef: GLTF.IImage, data: ArrayBuffer, texture: Texture): void {\n\t\tif (this.options.format === Format.GLB) {\n\t\t\tthis.imageBufferViews.push(data);\n\t\t\timageDef.bufferView = this.jsonDoc.json.bufferViews!.length;\n\t\t\tthis.jsonDoc.json.bufferViews!.push({\n\t\t\t\tbuffer: 0,\n\t\t\t\tbyteOffset: -1, // determined while iterating buffers, in Writer.ts.\n\t\t\t\tbyteLength: data.byteLength,\n\t\t\t});\n\t\t} else {\n\t\t\tconst extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n\t\t\timageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n\t\t\tthis.jsonDoc.resources[imageDef.uri] = data;\n\t\t}\n\t}\n\n\t/**\n\t * Returns implicit usage type of the given accessor, related to grouping accessors into\n\t * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n\t * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n\t * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic getAccessorUsage(accessor: Accessor): BufferViewUsage | string {\n\t\tconst cachedUsage = this._accessorUsageMap.get(accessor);\n\t\tif (cachedUsage) return cachedUsage;\n\n\t\tfor (const link of this._doc.getGraph().listParentLinks(accessor)) {\n\t\t\tif (link.getName() === 'inverseBindMatrices') {\n\t\t\t\treturn WriterContext.BufferViewUsage.INVERSE_BIND_MATRICES;\n\t\t\t}\n\t\t\tif (link instanceof AttributeLink) {\n\t\t\t\treturn WriterContext.BufferViewUsage.ARRAY_BUFFER;\n\t\t\t}\n\t\t\tif (link instanceof IndexLink) {\n\t\t\t\treturn WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER;\n\t\t\t}\n\t\t}\n\n\t\t// Group accessors with no specified usage into a miscellaneous buffer view.\n\t\treturn WriterContext.BufferViewUsage.OTHER;\n\t}\n\n\t/**\n\t * Sets usage for the given accessor. Some accessor types must be grouped into\n\t * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n\t * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n\t * will be grouped with other accessors of unspecified usage.\n\t */\n\tpublic addAccessorToUsageGroup(accessor: Accessor, usage: BufferViewUsage | string): this {\n\t\tconst prevUsage = this._accessorUsageMap.get(accessor);\n\t\tif (prevUsage && prevUsage !== usage) {\n\t\t\tthrow new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n\t\t}\n\t\tthis._accessorUsageMap.set(accessor, usage);\n\t\treturn this;\n\t}\n\n\t/** Lists accessors grouped by usage. Accessors with unspecified usage are not included. */\n\tpublic listAccessorUsageGroups(): { [key: string]: Accessor[] } {\n\t\tconst result = {} as { [key: string]: Accessor[] };\n\t\tfor (const [accessor, usage] of Array.from(this._accessorUsageMap.entries())) {\n\t\t\tresult[usage] = result[usage] || [];\n\t\t\tresult[usage].push(accessor);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport class UniqueURIGenerator {\n\tprivate counter = 1;\n\n\tconstructor(private readonly multiple: boolean, private readonly basename: string) {}\n\n\tpublic createURI(object: Texture | Buffer, extension: string): string {\n\t\tif (object.getURI()) {\n\t\t\treturn object.getURI();\n\t\t} else if (!this.multiple) {\n\t\t\treturn `${this.basename}.${extension}`;\n\t\t} else {\n\t\t\treturn `${this.basename}_${this.counter++}.${extension}`;\n\t\t}\n\t}\n}\n","import { Format, GLB_BUFFER, PropertyType, VERSION, VertexLayout } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { Link } from '../graph';\nimport { JSONDocument } from '../json-document';\nimport { Accessor, AnimationSampler, Camera, Material, Property } from '../properties';\nimport { GLTF } from '../types/gltf';\nimport { BufferUtils, Logger, MathUtils } from '../utils';\nimport { WriterContext } from './writer-context';\n\nconst { BufferViewUsage } = WriterContext;\n\nexport interface WriterOptions {\n\tformat: Format;\n\tlogger?: Logger;\n\tbasename?: string;\n\tvertexLayout?: VertexLayout;\n\tdependencies?: { [key: string]: unknown };\n\textensions?: typeof Extension[];\n}\n\n/** @internal */\nexport class GLTFWriter {\n\tpublic static write(doc: Document, options: Required<WriterOptions>): JSONDocument {\n\t\tconst root = doc.getRoot();\n\t\tconst json = {\n\t\t\tasset: { generator: `glTF-Transform ${VERSION}`, ...root.getAsset() },\n\t\t\textras: { ...root.getExtras() },\n\t\t} as GLTF.IGLTF;\n\t\tconst jsonDoc = { json, resources: {} } as JSONDocument;\n\n\t\tconst context = new WriterContext(doc, jsonDoc, options);\n\t\tconst logger = options.logger || Logger.DEFAULT_INSTANCE;\n\n\t\t/* Extensions (1/2). */\n\n\t\t// Extensions present on the Document are not written unless they are also registered with\n\t\t// the I/O class. This ensures that setup in `extension.register()` is completed, and\n\t\t// allows a Document to be written with specific extensions disabled.\n\t\tconst extensionsRegistered = new Set(options.extensions.map((ext) => ext.EXTENSION_NAME));\n\t\tconst extensionsUsed = doc.getRoot().listExtensionsUsed()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName));\n\t\tconst extensionsRequired = doc.getRoot().listExtensionsRequired()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName));\n\n\t\tif (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n\t\t\tlogger.debug('Some extensions were not registered for I/O, and will not be written.');\n\t\t}\n\n\t\tfor (const extension of extensionsUsed) {\n\t\t\tfor (const key of extension.writeDependencies) {\n\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t}\n\t\t}\n\n\t\t/* Utilities. */\n\n\t\tinterface BufferViewResult {\n\t\t\tbyteLength: number;\n\t\t\tbuffers: ArrayBuffer[];\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n\t\t * definitions to the root JSON lists.\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t * @param bufferViewTarget (Optional) target use of the buffer view.\n\t\t */\n\t\tfunction concatAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number,\n\t\t\tbufferViewTarget?: number\n\t\t): BufferViewResult {\n\t\t\tconst buffers: ArrayBuffer[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\t// Create accessor definitions, determining size of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\n\t\t\t\tconst data = BufferUtils.pad(accessor.getArray()!.buffer);\n\t\t\t\taccessorDef.byteOffset = byteLength;\n\t\t\t\tbyteLength += data.byteLength;\n\t\t\t\tbuffers.push(data);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewData = BufferUtils.concat(buffers);\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: bufferViewData.byteLength,\n\t\t\t};\n\t\t\tif (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { buffers, byteLength };\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer\n\t\t * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n\t\t *\n\t\t * References:\n\t\t * - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n\t\t * - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.\n\t\t */\n\t\tfunction interleaveAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number\n\t\t): BufferViewResult {\n\t\t\tconst vertexCount = accessors[0].getCount();\n\t\t\tlet byteStride = 0;\n\n\t\t\t// Create accessor definitions, determining size and stride of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\t\t\t\taccessorDef.byteOffset = byteStride;\n\n\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\tbyteStride += BufferUtils.padNumber(elementSize * componentSize);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Allocate interleaved buffer view.\n\t\t\tconst byteLength = vertexCount * byteStride;\n\t\t\tconst buffer = new ArrayBuffer(byteLength);\n\t\t\tconst view = new DataView(buffer);\n\n\t\t\t// Write interleaved accessor data to the buffer view.\n\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\tlet vertexByteOffset = 0;\n\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\t\tconst componentType = accessor.getComponentType();\n\t\t\t\t\tconst array = accessor.getArray()!;\n\t\t\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\t\t\tconst viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n\t\t\t\t\t\tconst value = array[i * elementSize + j];\n\t\t\t\t\t\tswitch (componentType) {\n\t\t\t\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\t\t\t\tview.setFloat32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\t\t\t\tview.setInt8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\t\t\t\tview.setInt16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\t\t\t\tview.setUint8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\t\t\t\tview.setUint16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\t\t\t\tview.setUint32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: byteLength,\n\t\t\t\tbyteStride: byteStride,\n\t\t\t\ttarget: WriterContext.BufferViewTarget.ARRAY_BUFFER,\n\t\t\t};\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { byteLength, buffers: [buffer] };\n\t\t}\n\n\t\t/* Data use pre-processing. */\n\n\t\tconst accessorLinks = new Map<Accessor, Link<Property, Accessor>[]>();\n\n\t\t// Gather all accessors, creating a map to look up their uses.\n\t\tfor (const link of doc.getGraph().getLinks()) {\n\t\t\tif (link.getParent() === root) continue;\n\n\t\t\tconst child = link.getChild();\n\n\t\t\tif (child instanceof Accessor) {\n\t\t\t\tconst uses = accessorLinks.get(child) || [];\n\t\t\t\tuses.push(link as Link<Property, Accessor>);\n\t\t\t\taccessorLinks.set(child, uses);\n\t\t\t}\n\t\t}\n\n\t\tjson.accessors = [];\n\t\tjson.bufferViews = [];\n\n\t\t/* Textures. */\n\n\t\t// glTF-Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tjson.samplers = [];\n\t\tjson.textures = [];\n\t\tjson.images = root.listTextures().map((texture, textureIndex) => {\n\t\t\tconst imageDef = context.createPropertyDef(texture) as GLTF.IImage;\n\n\t\t\tif (texture.getMimeType()) {\n\t\t\t\timageDef.mimeType = texture.getMimeType();\n\t\t\t}\n\n\t\t\tconst image = texture.getImage();\n\t\t\tif (image) {\n\t\t\t\tcontext.createImageData(imageDef, image, texture);\n\t\t\t}\n\n\t\t\tcontext.imageIndexMap.set(texture, textureIndex);\n\t\t\treturn imageDef;\n\t\t});\n\n\t\t/* Accessors. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.ACCESSOR))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.ACCESSOR));\n\t\troot.listAccessors().forEach((accessor) => {\n\t\t\t// Attributes are grouped and interleaved in one buffer view per mesh primitive.\n\t\t\t// Indices for all primitives are grouped into a single buffer view. IBMs are grouped\n\t\t\t// into a single buffer view. Other usage (if specified by extensions) also goes into\n\t\t\t// a dedicated buffer view. Everything else goes into a miscellaneous buffer view.\n\n\t\t\t// Certain accessor usage should group data into buffer views by the accessor parent.\n\t\t\t// The `accessorParents` map uses the first parent of each accessor for this purpose.\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\t// Skip if already written by an extension.\n\t\t\tif (context.accessorIndexMap.has(accessor)) return;\n\n\t\t\t// Assign usage for core accessor usage types (explicit targets and implicit usage).\n\t\t\tconst accessorRefs = accessorLinks.get(accessor) || [];\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tcontext.addAccessorToUsageGroup(accessor, usage);\n\n\t\t\t// For accessor usage that requires grouping by parent (vertex and instance\n\t\t\t// attributes) organize buffer views accordingly.\n\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\tconst parent = accessorRefs[0].getParent();\n\t\t\t\tconst parentAccessors = accessorParents.get(parent) || new Set<Accessor>();\n\t\t\t\tparentAccessors.add(accessor);\n\t\t\t\taccessorParents.set(parent, parentAccessors);\n\t\t\t}\n\t\t});\n\n\t\t/* Buffers, buffer views. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.BUFFER));\n\n\t\tconst hasBinaryResources =\n\t\t\troot.listAccessors().length > 0 || root.listTextures().length > 0 || context.otherBufferViews.size > 0;\n\t\tif (hasBinaryResources && root.listBuffers().length === 0) {\n\t\t\tthrow new Error('Buffer required for Document resources, but none was found.');\n\t\t}\n\n\t\tjson.buffers = [];\n\t\troot.listBuffers().forEach((buffer, index) => {\n\t\t\tconst bufferDef = context.createPropertyDef(buffer) as GLTF.IBuffer;\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\tconst bufferAccessors = buffer\n\t\t\t\t.listParents()\n\t\t\t\t.filter((property) => property instanceof Accessor) as Accessor[];\n\t\t\tconst bufferAccessorsSet = new Set(bufferAccessors);\n\n\t\t\t// Write accessor groups to buffer views.\n\n\t\t\tconst buffers: ArrayBuffer[] = [];\n\t\t\tconst bufferIndex = json.buffers!.length;\n\t\t\tlet bufferByteLength = 0;\n\n\t\t\tconst usageGroups = context.listAccessorUsageGroups();\n\n\t\t\tfor (const usage in usageGroups) {\n\t\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\t\t// Accessors grouped by (first) parent, including vertex and instance\n\t\t\t\t\t// attributes.\n\t\t\t\t\tfor (const parentAccessors of Array.from(accessorParents.values())) {\n\t\t\t\t\t\tconst accessors = Array.from(parentAccessors)\n\t\t\t\t\t\t\t.filter((a) => bufferAccessorsSet.has(a))\n\t\t\t\t\t\t\t.filter((a) => context.getAccessorUsage(a) === usage);\n\t\t\t\t\t\tif (!accessors.length) continue;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tusage !== BufferViewUsage.ARRAY_BUFFER ||\n\t\t\t\t\t\t\toptions.vertexLayout === VertexLayout.INTERLEAVED\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// Case 1: Non-vertex data OR interleaved vertex data.\n\n\t\t\t\t\t\t\t// Instanced data is not interleaved, see:\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/pull/1888\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\tusage === BufferViewUsage.ARRAY_BUFFER\n\t\t\t\t\t\t\t\t\t? interleaveAccessors(accessors, bufferIndex, bufferByteLength)\n\t\t\t\t\t\t\t\t\t: concatAccessors(accessors, bufferIndex, bufferByteLength);\n\t\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Case 2: Non-interleaved vertex data.\n\n\t\t\t\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\t\t\t\t// We 'interleave' a single accessor because the method pads to\n\t\t\t\t\t\t\t\t// 4-byte boundaries, which concatAccessors() does not.\n\t\t\t\t\t\t\t\tconst result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n\t\t\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Accessors concatenated end-to-end, including indices, IBMs, and other data.\n\t\t\t\t\tconst accessors = usageGroups[usage].filter((a) => bufferAccessorsSet.has(a));\n\t\t\t\t\tif (!accessors.length) continue;\n\n\t\t\t\t\tconst target =\n\t\t\t\t\t\tusage === BufferViewUsage.ELEMENT_ARRAY_BUFFER\n\t\t\t\t\t\t\t? WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\tconst result = concatAccessors(accessors, bufferIndex, bufferByteLength, target);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We only support embedded images in GLB, where the embedded buffer must be the first.\n\t\t\t// Additional buffers are currently left empty (see EXT_meshopt_compression fallback).\n\t\t\tif (context.imageBufferViews.length && index === 0) {\n\t\t\t\tfor (let i = 0; i < context.imageBufferViews.length; i++) {\n\t\t\t\t\tjson.bufferViews![json.images![i].bufferView!].byteOffset = bufferByteLength;\n\t\t\t\t\tbufferByteLength += context.imageBufferViews[i].byteLength;\n\t\t\t\t\tbuffers.push(context.imageBufferViews[i]);\n\n\t\t\t\t\tif (bufferByteLength % 8) {\n\t\t\t\t\t\t// See: https://github.com/KhronosGroup/glTF/issues/1935\n\t\t\t\t\t\tconst imagePadding = 8 - (bufferByteLength % 8);\n\t\t\t\t\t\tbufferByteLength += imagePadding;\n\t\t\t\t\t\tbuffers.push(new ArrayBuffer(imagePadding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.otherBufferViews.has(buffer)) {\n\t\t\t\tfor (const data of context.otherBufferViews.get(buffer)!) {\n\t\t\t\t\tjson.bufferViews!.push({\n\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\tbyteOffset: bufferByteLength,\n\t\t\t\t\t\tbyteLength: data.byteLength,\n\t\t\t\t\t});\n\t\t\t\t\tcontext.otherBufferViewsIndexMap.set(data, json.bufferViews!.length - 1);\n\t\t\t\t\tbufferByteLength += data.byteLength;\n\t\t\t\t\tbuffers.push(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bufferByteLength) {\n\t\t\t\t// Assign buffer URI.\n\t\t\t\tlet uri: string;\n\t\t\t\tif (options.format === Format.GLB) {\n\t\t\t\t\turi = GLB_BUFFER;\n\t\t\t\t} else {\n\t\t\t\t\turi = context.bufferURIGenerator.createURI(buffer, 'bin');\n\t\t\t\t\tbufferDef.uri = uri;\n\t\t\t\t}\n\n\t\t\t\t// Write buffer views to buffer.\n\t\t\t\tbufferDef.byteLength = bufferByteLength;\n\t\t\t\tjsonDoc.resources[uri] = BufferUtils.concat(buffers);\n\t\t\t}\n\n\t\t\tjson.buffers!.push(bufferDef);\n\t\t\tcontext.bufferIndexMap.set(buffer, index);\n\t\t});\n\n\t\tif (root.listAccessors().find((a) => !a.getBuffer())) {\n\t\t\tlogger.warn('Skipped writing one or more Accessors: no Buffer assigned.');\n\t\t}\n\n\t\t/* Materials. */\n\n\t\tjson.materials = root.listMaterials().map((material, index) => {\n\t\t\tconst materialDef = context.createPropertyDef(material) as GLTF.IMaterial;\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n\t\t\t\tmaterialDef.alphaMode = material.getAlphaMode();\n\t\t\t}\n\t\t\tif (material.getAlphaMode() === Material.AlphaMode.MASK) {\n\t\t\t\tmaterialDef.alphaCutoff = material.getAlphaCutoff();\n\t\t\t}\n\t\t\tif (material.getDoubleSided()) materialDef.doubleSided = true;\n\n\t\t\t// Factors.\n\n\t\t\tmaterialDef.pbrMetallicRoughness = {};\n\t\t\tif (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n\t\t\t}\n\t\t\tif (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n\t\t\t\tmaterialDef.emissiveFactor = material.getEmissiveFactor();\n\t\t\t}\n\t\t\tif (material.getRoughnessFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n\t\t\t}\n\t\t\tif (material.getMetallicFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (material.getBaseColorTexture()) {\n\t\t\t\tconst texture = material.getBaseColorTexture()!;\n\t\t\t\tconst textureInfo = material.getBaseColorTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getEmissiveTexture()) {\n\t\t\t\tconst texture = material.getEmissiveTexture()!;\n\t\t\t\tconst textureInfo = material.getEmissiveTextureInfo()!;\n\t\t\t\tmaterialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getNormalTexture()) {\n\t\t\t\tconst texture = material.getNormalTexture()!;\n\t\t\t\tconst textureInfo = material.getNormalTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t) as GLTF.IMaterialNormalTextureInfo;\n\t\t\t\tif (material.getNormalScale() !== 1) {\n\t\t\t\t\ttextureInfoDef.scale = material.getNormalScale();\n\t\t\t\t}\n\t\t\t\tmaterialDef.normalTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getOcclusionTexture()) {\n\t\t\t\tconst texture = material.getOcclusionTexture()!;\n\t\t\t\tconst textureInfo = material.getOcclusionTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t) as GLTF.IMaterialOcclusionTextureInfo;\n\t\t\t\tif (material.getOcclusionStrength() !== 1) {\n\t\t\t\t\ttextureInfoDef.strength = material.getOcclusionStrength();\n\t\t\t\t}\n\t\t\t\tmaterialDef.occlusionTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getMetallicRoughnessTexture()) {\n\t\t\t\tconst texture = material.getMetallicRoughnessTexture()!;\n\t\t\t\tconst textureInfo = material.getMetallicRoughnessTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.materialIndexMap.set(material, index);\n\t\t\treturn materialDef;\n\t\t});\n\n\t\t/* Meshes. */\n\n\t\tjson.meshes = root.listMeshes().map((mesh, index) => {\n\t\t\tconst meshDef = context.createPropertyDef(mesh) as GLTF.IMesh;\n\n\t\t\tlet targetNames: string[] | null = null;\n\n\t\t\tmeshDef.primitives = mesh.listPrimitives().map((primitive) => {\n\t\t\t\tconst primitiveDef: GLTF.IMeshPrimitive = { attributes: {} };\n\n\t\t\t\tprimitiveDef.mode = primitive.getMode();\n\n\t\t\t\tconst material = primitive.getMaterial();\n\t\t\t\tif (material) {\n\t\t\t\t\tprimitiveDef.material = context.materialIndexMap.get(material);\n\t\t\t\t}\n\n\t\t\t\tif (Object.keys(primitive.getExtras()).length) {\n\t\t\t\t\tprimitiveDef.extras = primitive.getExtras();\n\t\t\t\t}\n\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tprimitiveDef.indices = context.accessorIndexMap.get(indices);\n\t\t\t\t}\n\n\t\t\t\tfor (const semantic of primitive.listSemantics()) {\n\t\t\t\t\tprimitiveDef.attributes[semantic] = context.accessorIndexMap.get(\n\t\t\t\t\t\tprimitive.getAttribute(semantic)!\n\t\t\t\t\t)!;\n\t\t\t\t}\n\n\t\t\t\tfor (const target of primitive.listTargets()) {\n\t\t\t\t\tconst targetDef = {} as { [name: string]: number };\n\n\t\t\t\t\tfor (const semantic of target.listSemantics()) {\n\t\t\t\t\t\ttargetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic)!)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitiveDef.targets = primitiveDef.targets || [];\n\t\t\t\t\tprimitiveDef.targets.push(targetDef);\n\t\t\t\t}\n\n\t\t\t\tif (primitive.listTargets().length && !targetNames) {\n\t\t\t\t\ttargetNames = primitive.listTargets().map((target) => target.getName());\n\t\t\t\t}\n\n\t\t\t\treturn primitiveDef;\n\t\t\t});\n\n\t\t\tif (mesh.getWeights().length) {\n\t\t\t\tmeshDef.weights = mesh.getWeights();\n\t\t\t}\n\n\t\t\tif (targetNames) {\n\t\t\t\tmeshDef.extras = meshDef.extras || {};\n\t\t\t\tmeshDef.extras['targetNames'] = targetNames;\n\t\t\t}\n\n\t\t\tcontext.meshIndexMap.set(mesh, index);\n\t\t\treturn meshDef;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tjson.cameras = root.listCameras().map((camera, index) => {\n\t\t\tconst cameraDef = context.createPropertyDef(camera) as GLTF.ICamera;\n\t\t\tcameraDef.type = camera.getType();\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tcameraDef.perspective = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\tyfov: camera.getYFov(),\n\t\t\t\t};\n\t\t\t\tconst aspectRatio = camera.getAspectRatio();\n\t\t\t\tif (aspectRatio !== null) {\n\t\t\t\t\tcameraDef.perspective.aspectRatio = aspectRatio;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcameraDef.orthographic = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\txmag: camera.getXMag(),\n\t\t\t\t\tymag: camera.getYMag(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcontext.cameraIndexMap.set(camera, index);\n\t\t\treturn cameraDef;\n\t\t});\n\n\t\t/* Nodes. */\n\n\t\tjson.nodes = root.listNodes().map((node, index) => {\n\t\t\tconst nodeDef = context.createPropertyDef(node) as GLTF.INode;\n\n\t\t\tif (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n\t\t\t\tnodeDef.translation = node.getTranslation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n\t\t\t\tnodeDef.rotation = node.getRotation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n\t\t\t\tnodeDef.scale = node.getScale();\n\t\t\t}\n\n\t\t\tif (node.getWeights().length) {\n\t\t\t\tnodeDef.weights = node.getWeights();\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in writing process.\n\n\t\t\tcontext.nodeIndexMap.set(node, index);\n\t\t\treturn nodeDef;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tjson.skins = root.listSkins().map((skin, index) => {\n\t\t\tconst skinDef = context.createPropertyDef(skin) as GLTF.ISkin;\n\n\t\t\tconst inverseBindMatrices = skin.getInverseBindMatrices();\n\t\t\tif (inverseBindMatrices) {\n\t\t\t\tskinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n\t\t\t}\n\n\t\t\tconst skeleton = skin.getSkeleton();\n\t\t\tif (skeleton) {\n\t\t\t\tskinDef.skeleton = context.nodeIndexMap.get(skeleton);\n\t\t\t}\n\n\t\t\tskinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint)!);\n\n\t\t\tcontext.skinIndexMap.set(skin, index);\n\t\t\treturn skinDef;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\troot.listNodes().forEach((node, index) => {\n\t\t\tconst nodeDef = json.nodes![index];\n\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (mesh) {\n\t\t\t\tnodeDef.mesh = context.meshIndexMap.get(mesh);\n\t\t\t}\n\n\t\t\tconst camera = node.getCamera();\n\t\t\tif (camera) {\n\t\t\t\tnodeDef.camera = context.cameraIndexMap.get(camera);\n\t\t\t}\n\n\t\t\tconst skin = node.getSkin();\n\t\t\tif (skin) {\n\t\t\t\tnodeDef.skin = context.skinIndexMap.get(skin);\n\t\t\t}\n\n\t\t\tif (node.listChildren().length > 0) {\n\t\t\t\tnodeDef.children = node.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\t}\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tjson.animations = root.listAnimations().map((animation) => {\n\t\t\tconst animationDef = context.createPropertyDef(animation) as GLTF.IAnimation;\n\n\t\t\tconst samplerIndexMap: Map<AnimationSampler, number> = new Map();\n\n\t\t\tanimationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {\n\t\t\t\tconst samplerDef = context.createPropertyDef(sampler) as GLTF.IAnimationSampler;\n\t\t\t\tsamplerDef.input = context.accessorIndexMap.get(sampler.getInput()!)!;\n\t\t\t\tsamplerDef.output = context.accessorIndexMap.get(sampler.getOutput()!)!;\n\t\t\t\tsamplerDef.interpolation = sampler.getInterpolation();\n\t\t\t\tsamplerIndexMap.set(sampler, samplerIndex);\n\t\t\t\treturn samplerDef;\n\t\t\t});\n\n\t\t\tanimationDef.channels = animation.listChannels().map((channel) => {\n\t\t\t\tconst channelDef = context.createPropertyDef(channel) as GLTF.IAnimationChannel;\n\t\t\t\tchannelDef.sampler = samplerIndexMap.get(channel.getSampler()!)!;\n\t\t\t\tchannelDef.target = {\n\t\t\t\t\tnode: context.nodeIndexMap.get(channel.getTargetNode()!)!,\n\t\t\t\t\tpath: channel.getTargetPath()!,\n\t\t\t\t};\n\t\t\t\treturn channelDef;\n\t\t\t});\n\n\t\t\treturn animationDef;\n\t\t});\n\n\t\t/* Scenes. */\n\n\t\tjson.scenes = root.listScenes().map((scene) => {\n\t\t\tconst sceneDef = context.createPropertyDef(scene) as GLTF.IScene;\n\t\t\tsceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\treturn sceneDef;\n\t\t});\n\n\t\tconst defaultScene = root.getDefaultScene();\n\t\tif (defaultScene) {\n\t\t\tjson.scene = root.listScenes().indexOf(defaultScene);\n\t\t}\n\n\t\t/* Extensions (2/2). */\n\n\t\tjson.extensionsUsed = extensionsUsed.map((ext) => ext.extensionName);\n\t\tjson.extensionsRequired = extensionsRequired.map((ext) => ext.extensionName);\n\t\textensionsUsed.forEach((extension) => extension.write(context));\n\n\t\t//\n\n\t\tclean(json as unknown as Record<string, unknown>);\n\n\t\treturn jsonDoc;\n\t}\n}\n\n/**\n * Removes empty and null values from an object.\n * @param object\n * @internal\n */\nfunction clean(object: Record<string, unknown>): void {\n\tconst unused: string[] = [];\n\n\tfor (const key in object) {\n\t\tconst value = object[key];\n\t\tif (Array.isArray(value) && value.length === 0) {\n\t\t\tunused.push(key);\n\t\t} else if (value === null || value === '') {\n\t\t\tunused.push(key);\n\t\t} else if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n\t\t\tunused.push(key);\n\t\t}\n\t}\n\n\tfor (const key of unused) {\n\t\tdelete object[key];\n\t}\n}\n","import { Format, GLB_BUFFER, VertexLayout } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { JSONDocument } from '../json-document';\nimport { GLTF } from '../types/gltf';\nimport { BufferUtils, FileUtils, Logger, uuid } from '../utils/';\nimport { GLTFReader } from './reader';\nimport { GLTFWriter, WriterOptions } from './writer';\n\nenum ChunkType {\n\tJSON = 0x4e4f534a,\n\tBIN = 0x004e4942,\n}\n\ntype PublicWriterOptions = Partial<Pick<WriterOptions, 'format' | 'basename'>>;\n\n/**\n * # PlatformIO\n *\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*ArrayBuffer*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO} and {@link WebIO}.\n *\n * @category I/O\n */\nexport abstract class PlatformIO {\n\tprotected _logger = Logger.DEFAULT_INSTANCE;\n\tprivate _extensions = new Set<typeof Extension>();\n\tprivate _dependencies: { [key: string]: unknown } = {};\n\tprivate _vertexLayout = VertexLayout.INTERLEAVED;\n\n\t/** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n\tpublic setLogger(logger: Logger): this {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n\tpublic registerExtensions(extensions: typeof Extension[]): this {\n\t\tfor (const extension of extensions) {\n\t\t\tthis._extensions.add(extension);\n\t\t\textension.register();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Registers dependencies used (e.g. by extensions) in the I/O process. */\n\tpublic registerDependencies(dependencies: { [key: string]: unknown }): this {\n\t\tObject.assign(this._dependencies, dependencies);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the vertex layout method used by this I/O instance. Defaults to\n\t * VertexLayout.INTERLEAVED.\n\t */\n\tpublic setVertexLayout(layout: VertexLayout): this {\n\t\tthis._vertexLayout = layout;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Common.\n\t */\n\n\t/** @internal */\n\tprotected _readResourcesInternal(jsonDoc: JSONDocument): void {\n\t\t// NOTICE: This method may be called more than once during the loading\n\t\t// process (e.g. WebIO.read) and should handle that safely.\n\n\t\tfunction resolveResource(resource: GLTF.IBuffer | GLTF.IImage) {\n\t\t\tif (!resource.uri || resource.uri in jsonDoc.resources) return;\n\n\t\t\tif (resource.uri.match(/data:/)) {\n\t\t\t\t// Rewrite Data URIs to something short and unique.\n\t\t\t\tconst resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n\t\t\t\tjsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n\t\t\t\tresource.uri = resourceUUID;\n\t\t\t}\n\t\t}\n\n\t\t// Unpack images.\n\t\tconst images = jsonDoc.json.images || [];\n\t\timages.forEach((image: GLTF.IImage) => {\n\t\t\tif (image.bufferView === undefined && image.uri === undefined) {\n\t\t\t\tthrow new Error('Missing resource URI or buffer view.');\n\t\t\t}\n\n\t\t\tresolveResource(image);\n\t\t});\n\n\t\t// Unpack buffers.\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tbuffers.forEach(resolveResource);\n\t}\n\n\t/**********************************************************************************************\n\t * JSON.\n\t */\n\n\t/** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n\tpublic readJSON(jsonDoc: JSONDocument): Document {\n\t\tjsonDoc = this._copyJSON(jsonDoc);\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn GLTFReader.read(jsonDoc, {\n\t\t\textensions: Array.from(this._extensions),\n\t\t\tdependencies: this._dependencies,\n\t\t\tlogger: this._logger,\n\t\t});\n\t}\n\n\t/** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n\tpublic writeJSON(doc: Document, _options: PublicWriterOptions = {}): JSONDocument {\n\t\tif (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n\t\t\tthrow new Error('GLB must have 0–1 buffers.');\n\t\t}\n\t\treturn GLTFWriter.write(doc, {\n\t\t\tformat: _options.format || Format.GLTF,\n\t\t\tbasename: _options.basename || '',\n\t\t\tlogger: this._logger,\n\t\t\tvertexLayout: this._vertexLayout,\n\t\t\tdependencies: { ...this._dependencies },\n\t\t\textensions: Array.from(this._extensions),\n\t\t} as Required<WriterOptions>);\n\t}\n\n\t/**\n\t * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n\t *\n\t * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n\t * modify them during the parsing process. Other properties are shallow copies, and buffers\n\t * are passed by reference.\n\t */\n\tprivate _copyJSON(jsonDoc: JSONDocument): JSONDocument {\n\t\tconst { images, buffers } = jsonDoc.json;\n\n\t\tjsonDoc = { json: { ...jsonDoc.json }, resources: { ...jsonDoc.resources } };\n\n\t\tif (images) {\n\t\t\tjsonDoc.json.images = images.map((image) => ({ ...image }));\n\t\t}\n\t\tif (buffers) {\n\t\t\tjsonDoc.json.buffers = buffers.map((buffer) => ({ ...buffer }));\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/**********************************************************************************************\n\t * Binary -> JSON.\n\t */\n\n\t/** Converts a GLB-formatted ArrayBuffer to a {@link JSONDocument}. */\n\tpublic binaryToJSON(glb: ArrayBuffer): JSONDocument {\n\t\tconst jsonDoc = this._binaryToJSON(glb);\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\tconst json = jsonDoc.json;\n\n\t\t// Check for external references, which can't be resolved by this method.\n\t\tif (json.buffers && json.buffers.some((bufferDef) => isExternalBuffer(jsonDoc, bufferDef))) {\n\t\t\tthrow new Error('Cannot resolve external buffers with binaryToJSON().');\n\t\t} else if (json.images && json.images.some((imageDef) => isExternalImage(jsonDoc, imageDef))) {\n\t\t\tthrow new Error('Cannot resolve external images with binaryToJSON().');\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** @internal For internal use by WebIO and NodeIO. Does not warn about external resources. */\n\tprotected _binaryToJSON(glb: ArrayBuffer): JSONDocument {\n\t\t// Decode and verify GLB header.\n\t\tconst header = new Uint32Array(glb, 0, 3);\n\t\tif (header[0] !== 0x46546c67) {\n\t\t\tthrow new Error('Invalid glTF asset.');\n\t\t} else if (header[1] !== 2) {\n\t\t\tthrow new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n\t\t}\n\n\t\t// Decode JSON chunk.\n\n\t\tconst jsonChunkHeader = new Uint32Array(glb, 12, 2);\n\t\tif (jsonChunkHeader[1] !== ChunkType.JSON) {\n\t\t\tthrow new Error('Missing required GLB JSON chunk.');\n\t\t}\n\n\t\tconst jsonByteOffset = 20;\n\t\tconst jsonByteLength = jsonChunkHeader[0];\n\t\tconst jsonText = BufferUtils.decodeText(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n\t\tconst json = JSON.parse(jsonText) as GLTF.IGLTF;\n\n\t\t// Decode BIN chunk.\n\n\t\tconst binByteOffset = jsonByteOffset + jsonByteLength;\n\t\tif (glb.byteLength <= binByteOffset) {\n\t\t\treturn { json, resources: {} };\n\t\t}\n\n\t\tconst binChunkHeader = new Uint32Array(glb, binByteOffset, 2);\n\t\tif (binChunkHeader[1] !== ChunkType.BIN) {\n\t\t\tthrow new Error('Expected GLB BIN in second chunk.');\n\t\t}\n\n\t\tconst binByteLength = binChunkHeader[0];\n\t\tconst binBuffer = glb.slice(binByteOffset + 8, binByteOffset + 8 + binByteLength);\n\n\t\treturn { json, resources: { [GLB_BUFFER]: binBuffer } };\n\t}\n\n\t/**********************************************************************************************\n\t * Binary.\n\t */\n\n\t/** Converts a GLB-formatted ArrayBuffer to a {@link Document}. */\n\tpublic readBinary(glb: ArrayBuffer): Document {\n\t\treturn this.readJSON(this.binaryToJSON(glb));\n\t}\n\n\t/** Converts a {@link Document} to a GLB-formatted ArrayBuffer. */\n\tpublic writeBinary(doc: Document): ArrayBuffer {\n\t\tconst { json, resources } = this.writeJSON(doc, { format: Format.GLB });\n\n\t\tconst header = new Uint32Array([0x46546c67, 2, 12]);\n\n\t\tconst jsonText = JSON.stringify(json);\n\t\tconst jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);\n\t\tconst jsonChunkHeader = new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]).buffer;\n\t\tconst jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n\t\theader[header.length - 1] += jsonChunk.byteLength;\n\n\t\tconst binBuffer = Object.values(resources)[0];\n\t\tif (!binBuffer || !binBuffer.byteLength) {\n\t\t\treturn BufferUtils.concat([header.buffer, jsonChunk]);\n\t\t}\n\n\t\tconst binChunkData = BufferUtils.pad(binBuffer, 0x00);\n\t\tconst binChunkHeader = new Uint32Array([binChunkData.byteLength, 0x004e4942]).buffer;\n\t\tconst binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n\t\theader[header.length - 1] += binChunk.byteLength;\n\n\t\treturn BufferUtils.concat([header.buffer, jsonChunk, binChunk]);\n\t}\n}\n\nfunction isExternalBuffer(jsonDocument: JSONDocument, bufferDef: GLTF.IBuffer): boolean {\n\treturn bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);\n}\n\nfunction isExternalImage(jsonDocument: JSONDocument, imageDef: GLTF.IImage): boolean {\n\treturn imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;\n}\n","import { Format } from '../constants';\nimport { Document } from '../document';\nimport { JSONDocument } from '../json-document';\nimport { GLTF } from '../types/gltf';\nimport { BufferUtils, FileUtils } from '../utils/';\nimport { PlatformIO } from './platform-io';\nimport { GLTFReader } from './reader';\nimport { GLTFWriter } from './writer';\n\n/**\n * # NodeIO\n *\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*ArrayBuffer*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * const fs = require('fs');\n * const path = require('path');\n * const { NodeIO } = require('@gltf-transform/core');\n *\n * const io = new NodeIO();\n *\n * // Read.\n * io.read('model.glb');             // → Document\n * io.readBinary(ArrayBuffer);       // → Document\n *\n * // Write.\n * io.write('model.glb', doc); // → void\n * io.writeBinary(doc);        // → ArrayBuffer\n * ```\n *\n * @category I/O\n */\nexport class NodeIO extends PlatformIO {\n\tprivate _fs;\n\tprivate _path;\n\n\t/** @hidden */\n\tpublic lastReadBytes = 0;\n\n\t/** @hidden */\n\tpublic lastWriteBytes = 0;\n\n\t/** Constructs a new NodeIO service. Instances are reusable. */\n\tconstructor() {\n\t\tsuper();\n\t\t// Excluded from browser builds with 'package.browser' field.\n\t\tthis._fs = require('fs');\n\t\tthis._path = require('path');\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Loads a local path and returns a {@link Document} instance. */\n\tpublic read(uri: string): Document {\n\t\treturn this.readJSON(this.readAsJSON(uri));\n\t}\n\n\t/** Loads a local path and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic readAsJSON(uri: string): JSONDocument {\n\t\tconst isGLB = !!(uri.match(/\\.glb$/) || uri.match(/^data:application\\/octet-stream;/));\n\t\treturn isGLB ? this._readGLB(uri) : this._readGLTF(uri);\n\t}\n\n\t/** Writes a {@link Document} instance to a local path. */\n\tpublic write(uri: string, doc: Document): void {\n\t\tconst isGLB = !!uri.match(/\\.glb$/);\n\t\tisGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc);\n\t}\n\n\t/**********************************************************************************************\n\t * Protected.\n\t */\n\n\t/** @internal */\n\tprotected _readResourcesExternal(jsonDoc: JSONDocument, dir: string): void {\n\t\tconst images = jsonDoc.json.images || [];\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\t[...images, ...buffers].forEach((resource: GLTF.IBuffer | GLTF.IImage) => {\n\t\t\tif (resource.uri && !resource.uri.match(/data:/)) {\n\t\t\t\tconst absURI = this._path.resolve(dir, resource.uri);\n\t\t\t\tjsonDoc.resources[resource.uri] = BufferUtils.trim(this._fs.readFileSync(absURI));\n\t\t\t\tthis.lastReadBytes += jsonDoc.resources[resource.uri].byteLength;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @internal */\n\tprivate _readGLB(uri: string): JSONDocument {\n\t\tconst buffer: Buffer = this._fs.readFileSync(uri);\n\t\tconst arrayBuffer = BufferUtils.trim(buffer);\n\t\tthis.lastReadBytes = arrayBuffer.byteLength;\n\t\tconst jsonDoc = this._binaryToJSON(arrayBuffer);\n\t\t// Read external resources first, before Data URIs are replaced.\n\t\tthis._readResourcesExternal(jsonDoc, this._path.dirname(uri));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn jsonDoc;\n\t}\n\n\t/** @internal */\n\tprivate _readGLTF(uri: string): JSONDocument {\n\t\tthis.lastReadBytes = 0;\n\t\tconst jsonContent = this._fs.readFileSync(uri, 'utf8');\n\t\tthis.lastReadBytes += jsonContent.length;\n\t\tconst jsonDoc = { json: JSON.parse(jsonContent), resources: {} } as JSONDocument;\n\t\t// Read external resources first, before Data URIs are replaced.\n\t\tthis._readResourcesExternal(jsonDoc, this._path.dirname(uri));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn jsonDoc;\n\t}\n\n\t/** @internal */\n\tprivate _writeGLTF(uri: string, doc: Document): void {\n\t\tthis.lastWriteBytes = 0;\n\t\tconst { json, resources } = this.writeJSON(doc, {\n\t\t\tformat: Format.GLTF,\n\t\t\tbasename: FileUtils.basename(uri),\n\t\t});\n\t\tconst { _fs: fs, _path: path } = this;\n\t\tconst dir = path.dirname(uri);\n\t\tconst jsonContent = JSON.stringify(json, null, 2);\n\t\tthis.lastWriteBytes += jsonContent.length;\n\t\tfs.writeFileSync(uri, jsonContent);\n\t\tObject.keys(resources).forEach((resourceName) => {\n\t\t\tconst resource = Buffer.from(resources[resourceName]);\n\t\t\tfs.writeFileSync(path.join(dir, resourceName), resource);\n\t\t\tthis.lastWriteBytes += resource.byteLength;\n\t\t});\n\t}\n\n\t/** @internal */\n\tprivate _writeGLB(uri: string, doc: Document): void {\n\t\tconst buffer = Buffer.from(this.writeBinary(doc));\n\t\tthis._fs.writeFileSync(uri, buffer);\n\t\tthis.lastWriteBytes = buffer.byteLength;\n\t}\n}\n","import { Document } from '../document';\nimport { JSONDocument } from '../json-document';\nimport { GLTF } from '../types/gltf';\nimport { PlatformIO } from './platform-io';\n\nconst DEFAULT_INIT: RequestInit = {};\n\n/**\n * # WebIO\n *\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*ArrayBuffer*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * const doc = await io.read('model.glb');  // → Document\n * const doc = io.readBinary(ArrayBuffer);  // → Document\n *\n * // Write.\n * const arrayBuffer = io.writeBinary(doc); // → ArrayBuffer\n * ```\n *\n * @category I/O\n */\nexport class WebIO extends PlatformIO {\n\t/**\n\t * Constructs a new WebIO service. Instances are reusable.\n\t * @param _fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(private readonly _fetchConfig: RequestInit = DEFAULT_INIT) {\n\t\tsuper();\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Loads a URI and returns a {@link Document} instance. */\n\tpublic read(uri: string): Promise<Document> {\n\t\treturn this.readAsJSON(uri).then((jsonDoc) => this.readJSON(jsonDoc));\n\t}\n\n\t/** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic readAsJSON(uri: string): Promise<JSONDocument> {\n\t\tconst isGLB =\n\t\t\turi.match(/^data:application\\/octet-stream;/) ||\n\t\t\tnew URL(uri, window.location.href).pathname.match(/\\.glb$/);\n\t\treturn isGLB ? this._readGLB(uri) : this._readGLTF(uri);\n\t}\n\n\t/**********************************************************************************************\n\t * Protected.\n\t */\n\n\t/** @internal */\n\tprivate _readResourcesExternal(jsonDoc: JSONDocument, dir: string): Promise<void> {\n\t\tconst images = jsonDoc.json.images || [];\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tconst pendingResources: Array<Promise<void>> = [...images, ...buffers].map(\n\t\t\t(resource: GLTF.IBuffer | GLTF.IImage): Promise<void> => {\n\t\t\t\tconst uri = resource.uri;\n\t\t\t\tif (!uri || uri.match(/data:/)) return Promise.resolve();\n\n\t\t\t\treturn fetch(_resolve(dir, uri), this._fetchConfig)\n\t\t\t\t\t.then((response) => response.arrayBuffer())\n\t\t\t\t\t.then((arrayBuffer) => {\n\t\t\t\t\t\tjsonDoc.resources[uri] = arrayBuffer;\n\t\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\treturn Promise.all(pendingResources).then(() => undefined);\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @internal */\n\tprivate _readGLTF(uri: string): Promise<JSONDocument> {\n\t\tconst jsonDoc = { json: {}, resources: {} } as JSONDocument;\n\t\treturn fetch(uri, this._fetchConfig)\n\t\t\t.then((response) => response.json())\n\t\t\t.then(async (json: GLTF.IGLTF) => {\n\t\t\t\tjsonDoc.json = json;\n\t\t\t\t// Read external resources first, before Data URIs are replaced.\n\t\t\t\tawait this._readResourcesExternal(jsonDoc, _dirname(uri));\n\t\t\t\tthis._readResourcesInternal(jsonDoc);\n\t\t\t\treturn jsonDoc;\n\t\t\t});\n\t}\n\n\t/** @internal */\n\tprivate _readGLB(uri: string): Promise<JSONDocument> {\n\t\treturn fetch(uri, this._fetchConfig)\n\t\t\t.then((response) => response.arrayBuffer())\n\t\t\t.then(async (arrayBuffer) => {\n\t\t\t\tconst jsonDoc = this._binaryToJSON(arrayBuffer);\n\t\t\t\t// Read external resources first, before Data URIs are replaced.\n\t\t\t\tawait this._readResourcesExternal(jsonDoc, _dirname(uri));\n\t\t\t\tthis._readResourcesInternal(jsonDoc);\n\t\t\t\treturn jsonDoc;\n\t\t\t});\n\t}\n}\n\nfunction _dirname(path: string): string {\n\tconst index = path.lastIndexOf('/');\n\tif (index === -1) return './';\n\treturn path.substr(0, index + 1);\n}\n\nfunction _resolve(base: string, path: string) {\n\tif (!_isRelative(path)) return path;\n\n\tconst stack = base.split('/');\n\tconst parts = path.split('/');\n\tstack.pop();\n\tfor (let i = 0; i < parts.length; i++) {\n\t\tif (parts[i] === '.') continue;\n\t\tif (parts[i] === '..') {\n\t\t\tstack.pop();\n\t\t} else {\n\t\t\tstack.push(parts[i]);\n\t\t}\n\t}\n\treturn stack.join('/');\n}\n\nfunction _isRelative(path: string): boolean {\n\treturn !/^(?:[a-zA-Z]+:)?\\//.test(path);\n}\n"],"names":["VERSION","GLB_BUFFER","PropertyType","VertexLayout","TextureChannel","Format","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Link","constructor","_name","_parent","_child","_disposed","_listeners","this","canLink","Error","getName","getParent","getChild","setChild","child","dispose","forEach","fn","onDispose","push","isDisposed","Graph","_emptySet","Set","_links","_parentRefs","Map","_childRefs","on","type","emit","getLinks","Array","from","listParentLinks","node","get","listParents","map","link","listChildLinks","listChildren","disconnectChildren","disconnectParents","filter","links","swapChild","parent","prevChild","nextChild","delete","has","set","add","name","a","b","registerLink","unlink","GraphChild","propertyKey","value","isArray","enumerable","GraphChildList","bounds","resultBounds","min","Infinity","max","parents","propertyType","NODE","traverse","mesh","getMesh","meshBounds","getMeshBounds","getWorldMatrix","expandBounds","worldMatrix","prim","listPrimitives","position","getAttribute","localPos","worldPos","getCount","getElement","transformMat4","point","Math","BufferUtils","[object Object]","dataURI","Buffer","byteString","atob","split","ia","Uint8Array","charCodeAt","buffer","data","isBase64","indexOf","trim","text","TextEncoder","encode","TextDecoder","decode","toString","byteOffset","byteLength","slice","buffers","totalByteLength","result","arrayBuffer","paddingByte","paddedLength","padNumber","array","v","ceil","view1","DataView","view2","getUint8","ColorUtils","hex","floor","_target","convertSRGBToLinear","factor","g","convertLinearToSRGB","source","_source","pow","FileUtils","path","fileName","pop","substr","lastIndexOf","PNGImageUtils","match","getSize","view","decodeText","PNG_FRIED_CHUNK_NAME","getUint32","getChannels","_buffer","ImageUtils","mimeType","impl","impls","getGPUByteLength","uncompressedBytes","resolution","extension","validateJPEGBuffer","TypeError","image/jpeg","next","getUint16","image/png","MathUtils","abs","componentType","f","round","srcMat","dstTranslation","dstRotation","dstScale","sx","sy","sz","determinant","_m1","invSX","invSY","invSZ","getRotation","srcTranslation","srcRotation","srcScale","dstMat","te","x","y","z","w","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","Logger","verbosity","debug","Verbosity","DEBUG","console","info","INFO","warn","WARN","error","ERROR","SILENT","DEFAULT_INSTANCE","ALPHABET","previousIDs","generateOne","rtn","charAt","random","uuid","retries","id","COPY_IDENTITY","t","Property","graph","other","detach","swap","old","replacement","addGraphChild","remaining","l","removeGraphChild","clearGraphChildList","listGraphParents","super","_extras","setName","getExtras","setExtras","extras","clone","PropertyClass","copy","_resolve","JSON","parse","stringify","n","TOKEN_WARNING","ExtensibleProperty","extensions","resolve","setExtension","extensionName","getExtension","find","extensionProperty","prevExtension","_validateParent","listExtensions","Accessor","ACCESSOR","_array","_type","Type","SCALAR","_componentType","ComponentType","FLOAT","_normalized","_in","identity","_out","setBuffer","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","UNSIGNED_INT","getMinNormalized","elementSize","getElementSize","getMin","j","count","Number","isFinite","getMaxNormalized","getMax","getType","setType","getComponentSize","BYTES_PER_ELEMENT","getComponentType","getNormalized","setNormalized","normalized","denormalize","normalize","getScalar","index","setScalar","setElement","getBuffer","getArray","setArray","Float32Array","Uint32Array","Uint16Array","Int16Array","Int8Array","arrayToComponentType","getByteLength","Animation","ANIMATION","channels","samplers","addChannel","addSampler","channel","removeChannel","listChannels","sampler","removeSampler","listSamplers","AnimationChannel","ANIMATION_CHANNEL","_targetPath","targetNode","setTargetNode","setSampler","getTargetPath","setTargetPath","targetPath","getTargetNode","getSampler","TargetPath","TRANSLATION","ROTATION","SCALE","WEIGHTS","AnimationSampler","ANIMATION_SAMPLER","_interpolation","Interpolation","LINEAR","input","output","setInput","setOutput","getInterpolation","setInterpolation","interpolation","getInput","getOutput","STEP","CUBICSPLINE","BUFFER","_uri","getURI","setURI","uri","Camera","CAMERA","PERSPECTIVE","_znear","_zfar","_aspectRatio","_yfov","PI","_xmag","_ymag","getZNear","setZNear","znear","getZFar","setZFar","zfar","getAspectRatio","setAspectRatio","aspectRatio","getYFov","setYFov","yfov","getXMag","setXMag","xmag","getYMag","setYMag","ymag","ORTHOGRAPHIC","ExtensionProperty","_extension","addExtensionProperty","removeExtensionProperty","parentTypes","includes","EXTENSION_NAME","AttributeLink","semantic","IndexLink","_other","TextureLink","PropertyGraph","linkAttribute","linkIndex","linkTexture","TextureInfo","TEXTURE_INFO","_texCoord","_magFilter","_minFilter","_wrapS","WrapMode","REPEAT","_wrapT","equals","getTexCoord","getMagFilter","getMinFilter","getWrapS","getWrapT","setTexCoord","texCoord","setMagFilter","magFilter","setMinFilter","minFilter","setWrapS","wrapS","setWrapT","wrapT","CLAMP_TO_EDGE","MIRRORED_REPEAT","MagFilter","NEAREST","MinFilter","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","R","G","B","A","Material","MATERIAL","_alphaMode","AlphaMode","OPAQUE","_alphaCutoff","_doubleSided","_baseColorFactor","_emissiveFactor","_normalScale","_occlusionStrength","_roughnessFactor","_metallicFactor","baseColorTexture","baseColorTextureInfo","emissiveTexture","emissiveTextureInfo","normalTexture","normalTextureInfo","occlusionTexture","occlusionTextureInfo","metallicRoughnessTexture","metallicRoughnessTextureInfo","setBaseColorTexture","setEmissiveTexture","setNormalTexture","setOcclusionTexture","setMetallicRoughnessTexture","getAlphaMode","getAlphaCutoff","getDoubleSided","eq","getBaseColorFactor","getEmissiveFactor","getNormalScale","getOcclusionStrength","getRoughnessFactor","getMetallicFactor","getBaseColorTexture","getBaseColorTextureInfo","getEmissiveTexture","getEmissiveTextureInfo","getNormalTexture","getNormalTextureInfo","getOcclusionTexture","getOcclusionTextureInfo","getMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","otherExtensions","setDoubleSided","doubleSided","getAlpha","setAlpha","alpha","setAlphaMode","alphaMode","setAlphaCutoff","alphaCutoff","setBaseColorFactor","baseColorFactor","getBaseColorHex","factorToHex","setBaseColorHex","hexToFactor","texture","setEmissiveFactor","emissiveFactor","getEmissiveHex","setEmissiveHex","setNormalScale","normalScale","setOcclusionStrength","occlusionStrength","setRoughnessFactor","roughnessFactor","setMetallicFactor","metallicFactor","MASK","BLEND","Mesh","MESH","_weights","primitives","addPrimitive","primitive","removePrimitive","p","getWeights","setWeights","weights","Node","_translation","_rotation","_scale","camera","skin","children","setCamera","setMesh","setSkin","addChild","getTranslation","getScale","setTranslation","translation","setRotation","rotation","setScale","scale","getMatrix","compose","setMatrix","matrix","decompose","getWorldTranslation","getWorldRotation","getWorldScale","s","ancestors","ancestor","multiply","removeChild","getCamera","getSkin","Primitive","PRIMITIVE","_mode","Mode","TRIANGLES","material","indices","attributes","targets","setIndices","setMaterial","listSemantics","setAttribute","addTarget","getIndices","accessor","prevAccessor","listAttributes","getMaterial","getMode","setMode","mode","listTargets","removeTarget","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLE_STRIP","TRIANGLE_FAN","PrimitiveTarget","PRIMITIVE_TARGET","Scene","SCENE","Skin","SKIN","skeleton","inverseBindMatrices","joints","setSkeleton","setInverseBindMatrices","addJoint","getSkeleton","getInverseBindMatrices","joint","removeJoint","listJoints","Texture","TEXTURE","_image","_mimeType","getMimeType","extensionToMimeType","setMimeType","getImage","setImage","image","Root","ROOT","_asset","generator","version","_extensions","defaultScene","accessors","animations","cameras","materials","meshes","nodes","scenes","skins","textures","_addChildOfRoot","assign","_addAccessor","_addAnimation","_addBuffer","_addCamera","_addMaterial","_addMesh","_addNode","_addScene","_addSkin","_addTexture","setDefaultScene","getAsset","listExtensionsUsed","listExtensionsRequired","isRequired","_enableExtension","_disableExtension","scene","listScenes","getDefaultScene","listNodes","listCameras","listSkins","listMeshes","listMaterials","listTextures","animation","listAnimations","listAccessors","listBuffers","Document","_graph","_root","_logger","getRoot","getGraph","getLogger","setLogger","logger","merge","thisExtensions","otherExtension","thisExtension","createExtension","setRequired","visited","propertyMap","thisProp","otherProp","resolved","transforms","stack","transform","ctor","ext","createScene","createNode","createCamera","createSkin","createMesh","createPrimitive","createPrimitiveTarget","createMaterial","createTexture","createAnimation","createAnimationChannel","createAnimationSampler","createAccessor","createBuffer","Extension","doc","prereadTypes","prewriteTypes","readDependencies","writeDependencies","required","properties","property","install","dependency","preread","_readerContext","_propertyType","prewrite","_writerContext","ReaderContext","jsonDoc","bufferViews","bufferViewBuffers","textureInfos","setTextureInfo","textureInfo","textureInfoDef","undefined","textureDef","json","samplerDef","ComponentTypeToTypedArray","5120","5121","5122","5123","5125","5126","DEFAULT_OPTIONS","dependencies","getAccessorArray","accessorDef","context","bufferView","bufferViewDef","TypedArray","componentSize","byteStride","accessorByteOffset","getFloat32","getInt16","getInt8","getInterleavedArray","BufferViewTarget","BufferViewUsage","WriterContext","_doc","options","accessorIndexMap","bufferIndexMap","cameraIndexMap","skinIndexMap","materialIndexMap","meshIndexMap","nodeIndexMap","imageIndexMap","textureDefIndexMap","textureInfoDefMap","samplerDefIndexMap","imageBufferViews","otherBufferViews","otherBufferViewsIndexMap","extensionData","bufferURIGenerator","imageURIGenerator","_accessorUsageMap","accessorUsageGroupedByParent","accessorParents","root","numBuffers","numImages","UniqueURIGenerator","basename","createTextureInfoDef","samplerKey","textureKey","createPropertyDef","def","keys","createAccessorDef","some","fround","createImageData","imageDef","format","GLB","mimeTypeToExtension","createURI","resources","getAccessorUsage","cachedUsage","INVERSE_BIND_MATRICES","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","OTHER","addAccessorToUsageGroup","usage","prevUsage","listAccessorUsageGroups","entries","USAGE_TO_TARGET","multiple","counter","object","ChunkType","PlatformIO","_dependencies","_vertexLayout","INTERLEAVED","registerExtensions","register","registerDependencies","setVertexLayout","layout","_readResourcesInternal","resolveResource","resource","resourceUUID","createBufferFromDataURI","images","readJSON","_copyJSON","_options","validate","assetDef","asset","copyright","extensionsUsed","extensionsRequired","bufferDefs","bufferDef","sparse","sparseDef","indicesDef","valuesDef","values","getSparseArray","imageDefs","textureDefs","imageData","materialDef","pbrDef","pbrMetallicRoughness","strength","meshDefs","meshDef","primitiveDef","targetNames","targetDef","targetIndex","targetName","accessorIndex","cameraDef","perspectiveDef","perspective","orthoDef","orthographic","nodeDefs","nodeDef","skinDef","nodeIndex","childIndex","animationDef","channelDef","sceneDefs","sceneDef","read","writeJSON","extensionsRegistered","concatAccessors","bufferIndex","bufferByteOffset","bufferViewTarget","pad","concat","interleaveAccessors","vertexCount","ArrayBuffer","vertexByteOffset","viewByteOffset","setFloat32","setInt8","setInt16","setUint8","setUint16","setUint32","accessorLinks","uses","textureIndex","groupByParent","accessorRefs","parentAccessors","size","bufferAccessors","bufferAccessorsSet","bufferByteLength","usageGroups","vertexLayout","imagePadding","samplerIndexMap","samplerIndex","write","unused","clean","GLTF","binaryToJSON","glb","_binaryToJSON","jsonDocument","isExternalBuffer","isExternalImage","header","jsonChunkHeader","jsonByteLength","jsonText","binByteOffset","binChunkHeader","BIN","@glb.bin","readBinary","writeBinary","jsonChunkData","encodeText","jsonChunk","binBuffer","binChunkData","binChunk","NodeIO","_fs","_path","lastReadBytes","lastWriteBytes","require","readAsJSON","_readGLB","_readGLTF","_writeGLB","_writeGLTF","_readResourcesExternal","dir","absURI","readFileSync","dirname","jsonContent","fs","writeFileSync","resourceName","join","DEFAULT_INIT","WebIO","_fetchConfig","then","URL","window","location","href","pathname","pendingResources","Promise","fetch","base","test","_isRelative","parts","response","all","async","_this","_dirname","_this2"],"mappings":"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"}