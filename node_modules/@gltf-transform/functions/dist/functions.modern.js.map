{"version":3,"file":"functions.modern.js","sources":["../src/utils.ts","../src/center.ts","../src/colorspace.ts","../src/dedup.ts","../src/dequantize.ts","../src/inspect.ts","../src/instance.ts","../src/metal-rough.ts","../src/prune.ts","../src/partition.ts","../src/quantize.ts","../src/resample.ts","../src/reorder.ts","../src/sequence.ts","../src/tangents.ts","../src/texture-resize.ts","../src/unweld.ts","../src/weld.ts"],"sourcesContent":["import { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { Primitive, Texture, Transform, TransformContext } from '@gltf-transform/core';\n\n/**\n * Prepares a function used in an {@link Document.transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n */\nexport function createTransform(name: string, fn: Transform): Transform {\n\tObject.defineProperty(fn, 'name', { value: name });\n\treturn fn;\n}\n\nexport function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean {\n\tif (!context) return false;\n\tconst initialIndex = context.stack.lastIndexOf(initial);\n\tconst pendingIndex = context.stack.lastIndexOf(pending);\n\treturn initialIndex < pendingIndex;\n}\n\n/** Maps pixels from source to target textures, with a per-pixel callback. */\nexport async function rewriteTexture(\n\t\tsource: Texture,\n\t\ttarget: Texture,\n\t\tfn: (pixels: NdArray, i: number, j: number) => void): Promise<Texture|null> {\n\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(new Uint8Array(srcImage), source.getMimeType());\n\n\tfor(let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor(let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = (await savePixels(pixels, 'image/png')).buffer;\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices\n\t\t\t\t? indices.getCount() / 2\n\t\t\t\t: position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices\n\t\t\t\t? indices.getCount() / 3\n\t\t\t\t: position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n","import { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { bounds } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = {pivot: 'center'};\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n */\nexport function center (_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = {...CENTER_DEFAULTS, ..._options} as Required<CenterOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot().listScenes().forEach((scene, index) => {\n\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\tlet pivot: vec3;\n\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\tconst bbox = bounds(scene);\n\t\t\t\tpivot = [\n\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t];\n\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t} else {\n\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\tif (isAnimated) {\n\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\tscene.addChild(offsetNode);\n\t\t\t} else {\n\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\tchild.setTranslation([\n\t\t\t\t\t\tt[0] + offset[0],\n\t\t\t\t\t\tt[1] + offset[1],\n\t\t\t\t\t\tt[2] + offset[2],\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n\n};\n","import { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'colorspace';\n\n/** Options for the {@link colorspace} function. */\nexport interface ColorspaceOptions {\n\t/** Must be `\"sRGB\"`. Required. */\n    inputEncoding: string;\n}\n\n/**\n * Vertex color colorspace correction. The glTF format requires vertex colors to be stored\n * as linear values, and this function provides a way to correct vertex colors that are\n * (incorrectly) sRGB.\n */\nexport function colorspace (options: ColorspaceOptions): Transform {\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.inputEncoding === 'linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.inputEncoding !== 'sRGB') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input encoding \"${options.inputEncoding}\" – should be \"sRGB\" or `\n\t\t\t\t+ '\"linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear( c: number ): number {\n\n\t\t\treturn ( c < 0.04045 )\n\t\t\t\t? c * 0.0773993808\n\t\t\t\t: Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t});\n\n};\n","import { Accessor, BufferUtils, Document, Logger, Material, Mesh, Primitive, PrimitiveTarget, PropertyType, Root, Texture, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.MESH,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.MATERIAL,\n\t],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); // → [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); // → [Mesh]\n * ```\n */\nexport const dedup = function (_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = {...DEDUP_DEFAULTS, ..._options} as Required<DedupOptions>;\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn createTransform(NAME, (doc: Document): void =>  {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(logger, doc);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n\n};\n\nfunction dedupAccessors(logger: Logger, doc: Document): void {\n\t// Find all accessors used for mesh data.\n\tconst indicesAccessors: Set<Accessor> = new Set();\n\tconst attributeAccessors: Set<Accessor> = new Set();\n\tconst inputAccessors: Set<Accessor> = new Set();\n\tconst outputAccessors: Set<Accessor> = new Set();\n\n\tconst meshes = doc.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => (attributeAccessors.add(accessor)));\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices) indicesAccessors.add(indices);\n\t\t});\n\t});\n\n\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input) inputAccessors.add(input);\n\t\t\tif (output) outputAccessors.add(output);\n\t\t}\n\t}\n\n\t// Find duplicate accessors of a given type.\n\tfunction detectDuplicates(accessors: Accessor[]): Map<Accessor, Accessor> {\n\t\tconst duplicateAccessors: Map<Accessor, Accessor> = new Map();\n\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = a.getArray()!.slice().buffer;\n\n\t\t\tif (duplicateAccessors.has(a)) continue;\n\n\t\t\tfor (let j = 0; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (a === b) continue;\n\t\t\t\tif (duplicateAccessors.has(b)) continue;\n\n\t\t\t\tif (a.getType() !== b.getType()) continue;\n\t\t\t\tif (a.getComponentType() !== b.getComponentType()) continue;\n\t\t\t\tif (a.getCount() !== b.getCount()) continue;\n\t\t\t\tif (a.getNormalized() !== b.getNormalized()) continue;\n\t\t\t\tif (BufferUtils.equals(aData, b.getArray()!.slice().buffer)) {\n\t\t\t\t\tduplicateAccessors.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn duplicateAccessors;\n\t}\n\n\tconst duplicateIndices = detectDuplicates(Array.from(indicesAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateIndices.size} duplicates among ${indicesAccessors.size} indices.`\n\t);\n\n\tconst duplicateAttributes = detectDuplicates(Array.from(attributeAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateAttributes.size} duplicates among ${attributeAccessors.size}`\n\t\t+ ' attributes.'\n\t);\n\n\tconst duplicateInputs = detectDuplicates(Array.from(inputAccessors));\n\tconst duplicateOutputs = detectDuplicates(Array.from(outputAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateInputs.size + duplicateOutputs.size} duplicates among`\n\t\t+ ` ${inputAccessors.size + outputAccessors.size} animation accessors.`\n\t);\n\n\t// Dissolve duplicate vertex attributes and indices.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicateAttributes.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicateAttributes.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicateIndices.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicateIndices.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\tArray.from(duplicateIndices.keys()).forEach((indices) => indices.dispose());\n\tArray.from(duplicateAttributes.keys()).forEach((attribute) => attribute.dispose());\n\n\t// Dissolve duplicate animation sampler inputs and outputs.\n\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input && duplicateInputs.has(input)) {\n\t\t\t\tsampler.swap(input, duplicateInputs.get(input) as Accessor);\n\t\t\t}\n\t\t\tif (output && duplicateOutputs.has(output)) {\n\t\t\t\tsampler.swap(output, duplicateOutputs.get(output) as Accessor);\n\t\t\t}\n\t\t}\n\t}\n\tArray.from(duplicateInputs.keys()).forEach((input) => input.dispose());\n\tArray.from(duplicateOutputs.keys()).forEach((output) => output.dispose());\n}\n\nfunction dedupMeshes(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\n\t// Create Reference -> ID lookup table.\n\tconst refs = new Map<Accessor|Material, number>();\n\troot.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n\troot.listMaterials().forEach((material, index) => refs.set(material, index));\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tsrcKeyItems.push(createPrimitiveKey(prim, refs));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tconst meshKey = srcKeyItems.join(';');\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t`${NAME}: Found ${numMeshes - uniqueMeshes.size} duplicates among ${numMeshes} meshes.`\n\t);\n}\n\nfunction dedupImages(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\t// Compare each texture to every other texture — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicates.size} duplicates among ${root.listTextures().length} textures.`\n\t);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupMaterials(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst materials = root.listMaterials();\n\tconst duplicates: Map<Material, Material> = new Map();\n\n\t// Compare each material to every other material — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < materials.length; i++){\n\t\tconst a = materials[i];\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < materials.length; j++){\n\t\t\tconst b = materials[j];\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\tif (a.equals(b)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t// eslint-disable-next-line max-len\n\t\t`${NAME}: Found ${duplicates.size} duplicates among ${root.listMaterials().length} materials.`\n\t);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(\n\tprim: Primitive | PrimitiveTarget,\n\trefs: Map<Accessor|Material, number>\n): string {\n\tconst primKeyItems = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tprimKeyItems.push(semantic + ':' + refs.get(attribute));\n\t}\n\tif (prim instanceof Primitive) {\n\t\tconst indices = prim.getIndices();\n\t\tif (indices) {\n\t\t\tprimKeyItems.push('indices:' + refs.get(indices));\n\t\t}\n\t\tconst material = prim.getMaterial();\n\t\tif (material) {\n\t\t\tprimKeyItems.push('material:' + refs.get(material));\n\t\t}\n\t\tprimKeyItems.push('mode:' + prim.getMode());\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tprimKeyItems.push('target:' + createPrimitiveKey(target, refs));\n\t\t}\n\t}\n\treturn primKeyItems.join(',');\n}\n","import { Accessor, Document, Primitive, Transform } from '@gltf-transform/core';\nimport { MeshQuantization } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'dequantize';\n\n/** Options for the {@link dequantize} function. */\nexport interface DequantizeOptions {\n\t/**\n\t * Pattern (regex) used to filter vertex attribute semantics for quantization.\n\t * Default: `/^((?!JOINTS_).)*$/`.\n\t */\n\tpattern?: RegExp;\n}\n\nconst DEQUANTIZE_DEFAULTS: DequantizeOptions = {\n\tpattern: /^((?!JOINTS_).)*$/,\n};\n\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link MeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n */\nexport function dequantize(_options: DequantizeOptions = DEQUANTIZE_DEFAULTS): Transform {\n\tconst options = {...DEQUANTIZE_DEFAULTS, ..._options} as Required<DequantizeOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tdequantizePrimitive(prim, options);\n\t\t\t}\n\t\t}\n\t\tdoc.createExtension(MeshQuantization).dispose();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction dequantizePrimitive(prim: Primitive, options: Required<DequantizeOptions>): void {\n\tfor (const semantic of prim.listSemantics()) {\n\t\tdequantizeAttribute(semantic, prim.getAttribute(semantic)!, options);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const semantic of target.listSemantics()) {\n\t\t\tdequantizeAttribute(semantic, target.getAttribute(semantic)!, options);\n\t\t}\n\t}\n}\n\nfunction dequantizeAttribute(semantic: string, attribute: Accessor, options: Required<DequantizeOptions>): void {\n\tif (!attribute.getArray()) return;\n\tif (!options.pattern.test(semantic)) return;\n\tif (attribute.getComponentSize() >= 4) return;\n\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\n\tfor (let i = 0, il = attribute.getCount(), el = [] as number[]; i < il; i++) {\n\t\tel = attribute.getElement(i, el);\n\t\tattribute.setArray(dstArray).setElement(i, el).setArray(srcArray);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n","import { Accessor, Document, ExtensionProperty, GLTF, ImageUtils, Texture, TypedArray, bounds } from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect (doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes (doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc.getRoot().listScenes().map((scene) => {\n\t\tconst root = scene.listChildren()[0];\n\t\tconst sceneBounds = bounds(scene);\n\t\treturn {\n\t\t\tname: scene.getName(),\n\t\t\trootName: root ? root.getName() : '',\n\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t};\n\t});\n\treturn {properties: scenes};\n}\n\n/** List meshes. */\nfunction listMeshes (doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc.getRoot().listMeshes().map((mesh) => {\n\t\tconst instances = mesh.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\t\tlet glPrimitives = 0;\n\t\tlet verts = 0;\n\t\tconst semantics = new Set<string>();\n\t\tconst meshIndices = new Set<string>();\n\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\tsemantics.add(semantic + ':' + arrayToType(attr.getArray()!));\n\t\t\t\tmeshAccessors.add(attr);\n\t\t\t}\n\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t}\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (indices) {\n\t\t\t\tmeshIndices.add(arrayToType(indices.getArray()!));\n\t\t\t\tmeshAccessors.add(indices);\n\t\t\t}\n\t\t\tverts += prim.listAttributes()[0].getCount();\n\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t});\n\n\t\tlet size = 0;\n\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\tconst modes = mesh.listPrimitives()\n\t\t\t.map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\treturn {\n\t\t\tname: mesh.getName(),\n\t\t\tmode: Array.from(new Set(modes)),\n\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\tglPrimitives: glPrimitives,\n\t\t\tvertices: verts,\n\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\tinstances: instances,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: meshes};\n}\n\n/** List materials. */\nfunction listMaterials (doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc.getRoot().listMaterials().map((material) => {\n\t\tconst instances = material.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\t// Find all texture slots attached to this material or its extensions.\n\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\tconst slots = doc.getGraph().getLinks()\n\t\t\t.filter((link) => {\n\t\t\t\tconst child = link.getChild();\n\t\t\t\tconst parent = link.getParent();\n\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (child instanceof Texture\n\t\t\t\t\t\t&& parent instanceof ExtensionProperty\n\t\t\t\t\t\t&& extensions.has(parent)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t})\n\t\t\t.map((link) => link.getName());\n\n\t\treturn {\n\t\t\tname: material.getName(),\n\t\t\tinstances,\n\t\t\ttextures: slots,\n\t\t\talphaMode: material.getAlphaMode(),\n\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t};\n\t});\n\n\treturn {properties: materials};\n}\n\n/** List textures. */\nfunction listTextures (doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc.getRoot().listTextures().map((texture) => {\n\t\tconst instances = texture.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\tconst slots = doc.getGraph().listParentLinks(texture)\n\t\t\t.map((link) => link.getName())\n\t\t\t.filter((name) => name !== 'texture');\n\n\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\treturn {\n\t\t\tname: texture.getName(),\n\t\t\turi: texture.getURI(),\n\t\t\tslots: Array.from(new Set(slots)),\n\t\t\tinstances,\n\t\t\tmimeType: texture.getMimeType(),\n\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\tgpuSize: ImageUtils.getMemSize(texture.getImage()!, texture.getMimeType()),\n\t\t};\n\t});\n\n\treturn {properties: textures};\n}\n\n/** List animations. */\nfunction listAnimations (doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc.getRoot().listAnimations().map((anim) => {\n\t\tlet minTime = Infinity;\n\t\tlet maxTime = -Infinity;\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\tconst input = sampler.getInput();\n\t\t\tif (!input) return;\n\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t});\n\n\t\tlet size = 0;\n\t\tlet keyframes = 0;\n\t\tconst accessors: Set<Accessor> = new Set();\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (!input) return;\n\t\t\tkeyframes += input.getCount();\n\t\t\taccessors.add(input);\n\t\t\tif (!output) return;\n\t\t\taccessors.add(output);\n\t\t});\n\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t});\n\n\t\treturn {\n\t\t\tname: anim.getName(),\n\t\t\tchannels: anim.listChannels().length,\n\t\t\tsamplers: anim.listSamplers().length,\n\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\tkeyframes: keyframes,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: animations};\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tprimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction arrayToType(array: TypedArray): string {\n\treturn array.constructor.name.replace('Array', '').toLowerCase();\n}\n","import { Document, Logger, MathUtils, Mesh, Node, Transform, vec3, vec4 } from '@gltf-transform/core';\nimport { InstancedMesh, MeshGPUInstancing } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'instance';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface InstanceOptions {}\n\nconst INSTANCE_DEFAULTS: Required<InstanceOptions> = {};\n\n/**\n * Creates GPU instances (with `EXT_mesh_gpu_instancing`) for shared {@link Mesh} references. No\n * options are currently implemented for this function.\n */\nexport function instance (_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...INSTANCE_DEFAULTS, ..._options} as Required<InstanceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst batchExtension = doc.createExtension(MeshGPUInstancing);\n\n\t\tif (root.listAnimations().length) {\n\t\t\tthrow new Error(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t}\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < 2) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode()\n\t\t\t\t\t.setMesh(mesh)\n\t\t\t\t\t.setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, t = node.getWorldTranslation());\n\t\t\t\t\tbatchRotation.setElement(i, r = node.getWorldRotation());\n\t\t\t\t\tbatchScale.setElement(i, s = node.getWorldScale());\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\n\t\t\t\t\t// Mark the node for cleanup.\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(\n\t\t\t\t`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`\n\t\t\t);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with multiple parent nodes were found.`);\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: Logger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (node.listChildren().length\n\t\t\t\t|| node.getCamera()\n\t\t\t\t|| node.getMesh()\n\t\t\t\t|| node.getSkin()\n\t\t\t\t|| node.listExtensions().length) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParent();\n\t\tif (nodeParent instanceof Node) {\n\t\t\tnodes.push(nodeParent);\n\t\t}\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction createBatch(\n\t\tdoc: Document,\n\t\tbatchExtension: MeshGPUInstancing,\n\t\tmesh: Mesh,\n\t\tcount: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n","import { Document, Texture, Transform } from '@gltf-transform/core';\nimport { MaterialsIOR, MaterialsPBRSpecularGlossiness, MaterialsSpecular, PBRSpecularGlossiness } from '@gltf-transform/extensions';\nimport { createTransform, rewriteTexture } from './utils';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n */\nexport function metalRough (_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...METALROUGH_DEFAULTS, ..._options} as Required<MetalRoughOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionsUsed = doc.getRoot().listExtensionsUsed().map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n\t\t\tlogger.warn(`${NAME}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(MaterialsIOR);\n\t\tconst specExtension = doc.createExtension(MaterialsSpecular);\n\t\tconst specGlossExtension = doc.createExtension(MaterialsPBRSpecularGlossiness);\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material\n\t\t\t\t.getExtension<PBRSpecularGlossiness>('KHR_materials_pbrSpecularGlossiness');\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t});\n\n}\n","import { AnimationChannel, Document, Graph, Property, PropertyType, Root, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'prune';\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n}\nconst PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t]\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```\n * document.getRoot().listMaterials(); // → [Material, Material]\n *\n * await document.transform(prune());\n *\n * document.getRoot().listMaterials(); // → [Material]\n * ```\n *\n * No options are currently implemented for this function.\n */\nexport const prune = function (_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...PRUNE_DEFAULTS, ..._options} as Required<PruneOptions>;\n\tconst propertyTypes = options.propertyTypes;\n\n\treturn createTransform(NAME, (doc: Document): void =>  {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst graph = doc.getGraph();\n\n\t\tconst disposed: Record<string, number> = {};\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\tif (propertyTypes.includes(PropertyType.NODE)) root.listNodes().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.SKIN)) root.listSkins().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.MESH)) root.listMeshes().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.CAMERA)) root.listCameras().forEach(treeShake);\n\n\t\tif (propertyTypes.includes(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE);\n\t\t}\n\t\tif (propertyTypes.includes(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET);\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.includes(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tchannel.dispose();\n\t\t\t\t\t\tmarkDisposed(channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim);\n\t\t\t\t\tsamplers.forEach(treeShake);\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach(treeShake);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.includes(PropertyType.MATERIAL)) root.listMaterials().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.TEXTURE)) root.listTextures().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.ACCESSOR)) root.listAccessors().forEach(treeShake);\n\t\tif (propertyTypes.includes(PropertyType.BUFFER)) root.listBuffers().forEach(treeShake);\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\tif (Object.keys(disposed).length) {\n\t\t\tconst str = Object.keys(disposed).map((t) => `${t} (${disposed[t]})`).join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t\t//\n\n\t\t/** Disposes of the given property if it is unused. */\n\t\tfunction treeShake(prop: Property): void {\n\t\t\t// Consider a property unused if it has no references from another property, excluding\n\t\t\t// types Root and AnimationChannel.\n\t\t\tconst parents = prop.listParents()\n\t\t\t\t.filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\t\t\tif (!parents.length) {\n\t\t\t\tprop.dispose();\n\t\t\t\tmarkDisposed(prop);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * For property types the Root does not maintain references to, we'll need to search the\n\t\t * graph. It's possible that objects may have been constructed without any outbound links,\n\t\t * but since they're not on the graph they don't need to be tree-shaken.\n\t\t */\n\t\tfunction indirectTreeShake(graph: Graph<Property>, propertyType: string): void {\n\t\t\tgraph.getLinks()\n\t\t\t\t.map((link) => link.getParent())\n\t\t\t\t.filter((parent) => parent.propertyType === propertyType)\n\t\t\t\t.forEach(treeShake);\n\t\t}\n\n\t\t/** Records properties disposed by type. */\n\t\tfunction markDisposed(prop: Property): void {\n\t\t\tdisposed[prop.propertyType] = disposed[prop.propertyType] || 0;\n\t\t\tdisposed[prop.propertyType]++;\n\t\t}\n\n\t});\n\n};\n","import { Document, Logger, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> =  {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n * ```\n */\nconst partition = (_options: PartitionOptions = PARTITION_DEFAULTS): Transform => {\n\n\tconst options = {...PARTITION_DEFAULTS, ..._options} as Required<PartitionOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({propertyTypes: [PropertyType.BUFFER]}));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n\n};\n\nfunction partitionMeshes (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(\n\t\t\t\t\t`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives()\n\t\t\t\t.forEach((primitive) => {\n\t\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\t\tprimitive.listAttributes()\n\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\tprimitive.listTargets()\n\t\t\t\t\t\t.forEach((primTarget) => {\n\t\t\t\t\t\t\tprimTarget.listAttributes()\n\t\t\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(\n\t\t\t\t\t`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers()\n\t\t\t\t.forEach((sampler) => {\n\t\t\t\t\tconst input = sampler.getInput();\n\t\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI (basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n\nexport { partition };\n","import {\n\tAccessor,\n\tAnimationChannel,\n\tbbox,\n\tDocument,\n\tLogger,\n\tmat4,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tSkin,\n\tTransform,\n\tvec2,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { MeshQuantization } from '@gltf-transform/extensions';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor =\n\t| Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<QuantizeOptions> = {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file.\n */\nconst quantize = (_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform => {\n\tconst options = { ...QUANTIZE_DEFAULTS, ..._options } as Required<QuantizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tdoc.createExtension(MeshQuantization).setRequired(true);\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined = undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(doc, mesh, nodeTransform);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tquantizePrimitive(doc, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(doc, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait doc.transform(\n\t\t\tprune({ propertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN] }),\n\t\t\tdedup({ propertyTypes: [PropertyType.ACCESSOR] })\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction quantizePrimitive(\n\tdoc: Document,\n\tprim: Primitive | PrimitiveTarget,\n\tnodeTransform: VectorTransform<vec3>,\n\toptions: Required<QuantizeOptions>\n): void {\n\tconst logger = doc.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!options.pattern.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\t\tconst { bits, ctor } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 8–16.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (prim.getAttribute('WEIGHTS_0')) {\n\t\tnormalizeWeights(prim);\n\t}\n\n\tif (\n\t\tprim instanceof Primitive &&\n\t\tprim.getIndices() &&\n\t\tprim.listAttributes().length &&\n\t\tprim.listAttributes()[0]!.getCount() < 65535\n\t) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst { min, max } = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn { offset, scale };\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(doc: Document, mesh: Mesh, nodeTransform: VectorTransform<vec3>): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (parent instanceof Node) {\n\t\t\tconst animChannels = parent\n\t\t\t\t.listParents()\n\t\t\t\t.filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\t\tconst isAnimated = animChannels.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\t\tif (parent.getSkin()) {\n\t\t\t\tparent.setSkin(transformSkin(parent.getSkin()!, nodeTransform));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet targetNode: Node;\n\t\t\tif (isParentNode || isAnimated) {\n\t\t\t\ttargetNode = doc.createNode('').setMesh(mesh);\n\t\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\t\tanimChannels\n\t\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t\t} else {\n\t\t\t\ttargetNode = parent;\n\t\t\t}\n\n\t\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\t\ttargetNode.setMatrix(nodeMatrix);\n\t\t}\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone();\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute: Accessor, ctor: TypedArrayConstructor, bits: number): void {\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tlet value = Math.round(Math.abs(el[j]) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(true);\n}\n\nfunction getQuantizationSettings(\n\tsemantic: string,\n\tattribute: Accessor,\n\tlogger: Logger,\n\toptions: Required<QuantizeOptions>\n): { bits: number; ctor?: TypedArrayConstructor } {\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn { bits: -1 };\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some((v) => v < -1) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some((v) => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn { bits, ctor };\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst { min: relMin, max: relMax } = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2 | vec3>(accessors: Accessor[], elementSize: number): { min: T; max: T } {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn { min, max } as unknown as { min: T; max: T };\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2 | vec3 | vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale([] as unknown as mat4, [0, 0, 0, 1], transform.offset, [\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t]) as mat4;\n}\n\nfunction normalizeWeights(prim: Primitive | PrimitiveTarget): void {\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst weightsEl: number[] = [];\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tlet vertexWeightsSum = 0;\n\n\t\tlet leastWeight = Infinity;\n\t\tlet leastIndex = -1;\n\t\tlet leastAttribute: Accessor | null = null;\n\n\t\tlet weights: Accessor | null;\n\t\tlet attributeIndex = 0;\n\n\t\t// Find sum of weights and the joint with the lowest non-zero weight.\n\t\twhile ((weights = prim.getAttribute(`WEIGHTS_${attributeIndex++}`))) {\n\t\t\tweights.getElement(i, weightsEl);\n\t\t\tfor (let j = 0; j < weightsEl.length; j++) {\n\t\t\t\tvertexWeightsSum += weightsEl[j];\n\t\t\t\tif (weightsEl[j] > 0 && weightsEl[j] < leastWeight) {\n\t\t\t\t\tleastAttribute = weights;\n\t\t\t\t\tleastWeight = weightsEl[j];\n\t\t\t\t\tleastIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Normalize by updating least-significant joint weight.\n\t\tif (leastAttribute && vertexWeightsSum !== 1) {\n\t\t\tleastAttribute.getElement(i, weightsEl);\n\t\t\tweightsEl[leastIndex] += 1 - vertexWeightsSum;\n\t\t\tleastAttribute.setElement(i, weightsEl);\n\t\t}\n\t}\n}\n\nexport { quantize };\n","import { Accessor, AnimationSampler, Document, Root, Transform, TransformContext } from '@gltf-transform/core';\nimport { createTransform, isTransformPending } from './utils';\n\nconst NAME = 'resample';\n\nexport interface ResampleOptions {tolerance?: number}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> =  {tolerance: 1e-4};\n\n/**\n * Resample {@link Animation}s, losslessly deduplicating keyframes to reduce file size. Duplicate\n * keyframes are commonly present in animation 'baked' by the authoring software to apply IK\n * constraints or other software-specific features. Based on THREE.KeyframeTrack.optimize().\n *\n * Example: (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n */\nexport const resample = (_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform => {\n\n\tconst options = {...RESAMPLE_DEFAULTS, ..._options} as Required<ResampleOptions>;\n\n\treturn createTransform(NAME, (doc: Document, context?: TransformContext): void => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst accessorsCountPrev = doc.getRoot().listAccessors().length;\n\t\tconst logger = doc.getLogger();\n\n\t\tlet didSkipMorphTargets = false;\n\n\t\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\t\t// Skip morph targets, see https://github.com/donmccurdy/glTF-Transform/issues/290.\n\t\t\tconst morphTargetSamplers = new Set<AnimationSampler>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tif (channel.getSampler() && channel.getTargetPath() === 'weights') {\n\t\t\t\t\tmorphTargetSamplers.add(channel.getSampler()!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tif (morphTargetSamplers.has(sampler)) {\n\t\t\t\t\tdidSkipMorphTargets = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sampler.getInterpolation() === 'STEP'\n\t\t\t\t\t|| sampler.getInterpolation() === 'LINEAR') {\n\t\t\t\t\taccessorsVisited.add(sampler.getInput()!);\n\t\t\t\t\taccessorsVisited.add(sampler.getOutput()!);\n\t\t\t\t\toptimize(sampler, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\tif (doc.getRoot().listAccessors().length > accessorsCountPrev && !isTransformPending(context, NAME, 'dedup')) {\n\t\t\tlogger.warn(\n\t\t\t\t`${NAME}: Resampling required copying accessors, some of which may be duplicates.`\n\t\t\t\t+ ' Consider using \"dedup\" to consolidate any duplicates.'\n\t\t\t);\n\t\t}\n\n\t\tif (didSkipMorphTargets) {\n\t\t\tlogger.warn(`${NAME}: Skipped optimizing morph target keyframes, not yet supported.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n\n};\n\nfunction optimize (sampler: AnimationSampler, options: ResampleOptions): void {\n\tconst input = sampler.getInput()!.clone();\n\tconst output = sampler.getOutput()!.clone();\n\n\tconst tolerance = options.tolerance as number;\n\n\tconst lastIndex = input.getCount() - 1;\n\tconst tmp: number[] = [];\n\n\tlet writeIndex = 1;\n\n\tfor (let i = 1; i < lastIndex; ++ i) {\n\t\tconst time = input.getScalar(i);\n\t\tconst timePrev = input.getScalar(i - 1);\n\t\tconst timeNext = input.getScalar(i + 1);\n\t\tconst timeMix = (time - timePrev) / (timeNext - timePrev);\n\n\t\tlet keep = false;\n\n\t\t// Remove unnecessary adjacent keyframes.\n\t\tif (time !== timeNext && (i !== 1 || time !== input.getScalar(0))) {\n\t\t\tfor (let j = 0; j < output.getElementSize(); j++) {\n\t\t\t\tconst value = output.getElement(i, tmp)[j];\n\t\t\t\tconst valuePrev = output.getElement(i - 1, tmp)[j];\n\t\t\t\tconst valueNext = output.getElement(i + 1, tmp)[j];\n\n\t\t\t\tif (sampler.getInterpolation() === 'LINEAR') {\n\t\t\t\t\t// Prune keyframes that are colinear with prev/next keyframes.\n\t\t\t\t\tif (Math.abs(value - lerp(valuePrev, valueNext, timeMix)) > tolerance) {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (sampler.getInterpolation() === 'STEP') {\n\t\t\t\t\t// Prune keyframes that are identical to prev/next keyframes.\n\t\t\t\t\tif (value !== valuePrev || value !== valueNext) {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In-place compaction.\n\t\tif (keep) {\n\t\t\tif (i !== writeIndex) {\n\t\t\t\tinput.setScalar(writeIndex, input.getScalar(i));\n\t\t\t\toutput.setElement(writeIndex, output.getElement(i, tmp));\n\t\t\t}\n\t\t\twriteIndex++;\n\t\t}\n\n\t}\n\n\t// Flush last keyframe (compaction looks ahead).\n\tif (lastIndex > 0) {\n\t\tinput.setScalar(writeIndex, input.getScalar(lastIndex));\n\t\toutput.setElement(writeIndex, output.getElement(lastIndex, tmp));\n\t\twriteIndex++;\n\t}\n\n\t// If the sampler was optimized, truncate and save the results. If not, clean up.\n\tif (writeIndex !== input.getCount()) {\n\t\tinput.setArray(input.getArray()!.slice(0, writeIndex));\n\t\toutput.setArray(output.getArray()!.slice(0, writeIndex * output.getElementSize()));\n\t\tsampler.setInput(input);\n\t\tsampler.setOutput(output);\n\t} else {\n\t\tinput.dispose();\n\t\toutput.dispose();\n\t}\n}\n\nfunction lerp (v0: number, v1: number, t: number): number {\n    return v0 * (1 - t) + v1 * t;\n}\n","import { Accessor, Document, GLTF, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { createTransform, SetMap } from './utils';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder?: typeof MeshoptEncoder,\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance',\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n};\n\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n */\nexport function reorder (_options: ReorderOptions = REORDER_DEFAULTS): Transform {\n\tconst options = {...REORDER_DEFAULTS, ..._options} as Required<ReorderOptions>;\n\tconst encoder = options.encoder;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = preprocessPrimitives(doc);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tconst dstIndices = srcIndices.clone();\n\t\t\tlet indicesArray = dstIndices.getArray()!.slice();\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size'\n\t\t\t);\n\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = srcAttribute.clone();\n\t\t\t\tremapAttribute(dstAttribute, remap, unique);\n\t\t\t\tfor (const prim of plan.attributesToPrimitives.get(srcAttribute)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\t\t\t\t\tif (prim.getIndices() === dstIndices) {\n\t\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tawait doc.transform(prune({propertyTypes: [PropertyType.ACCESSOR]}));\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction remapAttribute(attribute: Accessor, remap: Uint32Array, dstCount: number) {\n\tconst elementSize = attribute.getElementSize();\n\tconst srcCount = attribute.getCount();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = srcArray.slice(0, dstCount * elementSize);\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[remap[i] * elementSize + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray);\n}\n\n/**\n * Constructs a plan for creating optimal vertex cache order, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n */\nfunction preprocessPrimitives(doc: Document): LayoutPlan {\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\n\t\t\tfor (const attribute of listAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {indicesToAttributes, indicesToMode, attributesToPrimitives};\n}\n\nfunction listAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n","import { Accessor, AnimationChannel, AnimationSampler, Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n */\nexport function sequence (_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = {...SEQUENCE_DEFAULTS, ..._options} as Required<SequenceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes()\n\t\t\t.filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(inputArray))\n\t\t\t\t.setBuffer(animBuffer);\n\t\t\tconst output = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t});\n\n}\n","import { Accessor, Document, Logger, Primitive, Transform, TypedArray, uuid } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array,\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean,\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occuring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n */\nexport function tangents (_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tif (!_options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required — install \"mikktspace\".`);\n\t}\n\n\tconst options = {...TANGENTS_DEFAULTS, ..._options} as Required<TangentsOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord)\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor()\n\t\t\t\t\t.setBuffer(tangentBuffer)\n\t\t\t\t\t.setArray(tangentArray)\n\t\t\t\t\t.setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(\n\t\tprim: Primitive,\n\t\tlogger: Logger,\n\t\tmeshName: string,\n\t\ti: number,\n\t\toverwrite: boolean): boolean {\n\n\tif (prim.getMode() !== Primitive.Mode.TRIANGLES\n\t\t\t|| !prim.getAttribute('POSITION')\n\t\t\t|| !prim.getAttribute('NORMAL')\n\t\t\t|| !prim.getAttribute('TEXCOORD_0')) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must`\n\t\t\t+ ' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.'\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\t// TODO(feat): Do this automatically for qualifying primitives.\n\t\tlogger.warn(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must`\n\t\t\t+ ' be unwelded.'\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","import ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { Document, Transform, vec2 } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'textureResize';\n\n/** Options for the {@link textureResize} function. */\nexport interface TextureResizeOptions {\n\t/**\n\t * Maximum width/height to enforce, preserving aspect ratio. For example,\n\t * a 4096x8192 texture, resized with limit [2048, 2048] will be reduced\n\t * to 1024x2048.\n\t */\n\tsize: vec2;\n\t/** Resampling filter method. LANCZOS3 is sharper, LANCZOS2 is smoother. */\n\tfilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to resize, matched to name or URI. */\n\tpattern?: RegExp | null;\n}\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport const TEXTURE_RESIZE_DEFAULTS: TextureResizeOptions = {\n\tsize: [2048, 2048],\n\tfilter: TextureResizeFilter.LANCZOS3,\n\tpattern: null\n};\n\n/**\n * Resize PNG or JPEG {@link Texture Textures}, with {@link https://en.wikipedia.org/wiki/Lanczos_algorithm Lanczos filtering}.\n * Implementation provided by {@link https://github.com/donmccurdy/ndarray-lanczos ndarray-lanczos} package.\n */\nexport function textureResize(_options: TextureResizeOptions = TEXTURE_RESIZE_DEFAULTS): Transform {\n\tconst options = {...TEXTURE_RESIZE_DEFAULTS, ..._options} as Required<TextureResizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const texture of doc.getRoot().listTextures()) {\n\t\t\tconst name = texture.getName();\n\t\t\tconst uri = texture.getURI();\n\t\t\tconst match = !options.pattern\n\t\t\t\t|| options.pattern.test(name)\n\t\t\t\t|| options.pattern.test(uri);\n\t\t\tif (!match) continue;\n\n\t\t\tif (texture.getMimeType() !== 'image/png' && texture.getMimeType() !== 'image/jpeg') {\n\t\t\t\tlogger.warn(`Skipping unsupported texture type, \"${texture.getMimeType()}\".`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst [maxWidth, maxHeight] = options.size;\n\t\t\tconst [srcWidth, srcHeight] = texture.getSize()!;\n\n\t\t\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping \"${uri || name}\", within size range.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dstWidth = srcWidth;\n\t\t\tlet dstHeight = srcHeight;\n\n\t\t\tif (dstWidth > maxWidth) {\n\t\t\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\t\t\tdstWidth = maxWidth;\n\t\t\t}\n\n\t\t\tif (dstHeight > maxHeight) {\n\t\t\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\t\t\tdstHeight = maxHeight;\n\t\t\t}\n\n\t\t\tconst srcImage = new Uint8Array(texture.getImage() as ArrayBuffer);\n\t\t\tconst srcPixels = await getPixels(srcImage, texture.getMimeType());\n\t\t\tconst dstPixels = ndarray(\n\t\t\t\tnew Uint8Array(dstWidth * dstHeight * 4), [dstWidth, dstHeight, 4]\n\t\t\t);\n\n\t\t\tlogger.debug(\n\t\t\t\t`${NAME}: Resizing \"${uri || name}\", ${srcPixels.shape} → ${dstPixels.shape}...`\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\toptions.filter === TextureResizeFilter.LANCZOS3\n\t\t\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\tlogger.warn(`${NAME}: Failed to resize \"${uri || name}\": \"${e.message}\".`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\ttexture.setImage((await savePixels(dstPixels, texture.getMimeType())).buffer);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t});\n\n}\n","import { Accessor, Document, Logger, Transform, TypedArray } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n */\nexport function unweld (_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = {...UNWELD_DEFAULTS, ..._options} as Required<UnweldOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (!indices) continue;\n\n\t\t\t\t// Vertex attributes.\n\t\t\t\tfor (const srcAttribute of prim.listAttributes()) {\n\t\t\t\t\tprim.swap(\n\t\t\t\t\t\tsrcAttribute,\n\t\t\t\t\t\tunweldAttribute(srcAttribute, indices, logger, visited)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Clean up.\n\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t}\n\n\t\t\t\t// Morph target vertex attributes.\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\t\t\t\ttarget.swap(\n\t\t\t\t\t\t\tsrcAttribute,\n\t\t\t\t\t\t\tunweldAttribute(srcAttribute, indices, logger, visited)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Clean up.\n\t\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clean up.\n\t\t\t\tprim.setIndices(null);\n\t\t\t\tif (indices.listParents().length === 1) indices.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction unweldAttribute(\n\t\tsrcAttribute: Accessor,\n\t\tindices: Accessor,\n\t\tlogger: Logger,\n\t\tvisited: Map<Accessor, Map<Accessor, Accessor>>): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\tlogger.debug(`${NAME}: Cache hit for reused attribute, \"${srcAttribute.getName()}\".`);\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst dstAttribute = srcAttribute.clone();\n\tconst ArrayCtor = srcAttribute.getArray()!.constructor as\n\t\tnew (len: number) => TypedArray;\n\tdstAttribute.setArray(\n\t\tnew ArrayCtor(indices.getCount() * srcAttribute.getElementSize())\n\t);\n\n\tconst el: number[] = [];\n\tfor (let i = 0; i < indices.getCount(); i++) {\n\t\tdstAttribute.setElement(i, srcAttribute.getElement(indices.getScalar(i), el));\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n","import { Accessor, Document, Primitive, PrimitiveTarget, Transform, TypedArray } from '@gltf-transform/core';\nimport { getGLPrimitiveCount, createTransform } from './utils';\n\nconst NAME = 'weld';\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Per-attribute tolerance used when merging similar vertices. */\n\ttolerance?: number\n}\n\nconst WELD_DEFAULTS: Required<WeldOptions> = {tolerance: 1e-4};\n\n/**\n * Index {@link Primitive}s and (optionally) merge similar vertices.\n */\nexport function weld (_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = {...WELD_DEFAULTS, ..._options} as Required<WeldOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tif (options.tolerance === 0) {\n\t\t\t\t\tweldOnly(doc, prim);\n\t\t\t\t} else {\n\t\t\t\t\tweldAndMerge(doc, prim, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**  In-place weld, adds indices without changing number of vertices. */\nfunction weldOnly (doc: Document, prim: Primitive): void {\n\tif (prim.getIndices()) return;\n\tconst attr = prim.listAttributes()[0];\n\tconst numVertices = attr.getCount();\n\tconst buffer = attr.getBuffer();\n\tconst indicesArray = numVertices <= 65534\n\t\t? new Uint16Array(getGLPrimitiveCount(prim) * 3)\n\t\t: new Uint32Array(getGLPrimitiveCount(prim) * 3);\n\tconst indices = doc.createAccessor()\n\t\t.setBuffer(buffer)\n\t\t.setType(Accessor.Type.SCALAR)\n\t\t.setArray(indicesArray);\n\tfor (let i = 0; i < indices.getCount(); i++) indices.setScalar(i, i);\n\tprim.setIndices(indices);\n}\n\n/**\n * Weld and merge, combining vertices that are similar on all vertex attributes. Morph target\n * attributes are not considered when scoring vertex similarity, but are retained when merging.\n */\nfunction weldAndMerge (doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tconst tolerance = Math.max(options.tolerance, Number.EPSILON);\n\tconst decimalShift = Math.log10(1 / tolerance);\n\tconst shiftFactor = Math.pow(10, decimalShift);\n\n\tconst hashToIndex: {[key: string]: number} = {};\n\tconst srcIndices = prim.getIndices();\n\tconst vertexCount = srcIndices\n\t\t? srcIndices.getCount()\n\t\t: prim.listAttributes()[0].getCount();\n\n\t// Prepare storage for new elements of each attribute.\n\tconst dstAttributes = new Map<Accessor, number[][]>();\n\tprim.listAttributes().forEach((attr) => dstAttributes.set(attr, []));\n\tprim.listTargets().forEach((target) => {\n\t\ttarget.listAttributes().forEach((attr) => dstAttributes.set(attr, []));\n\t});\n\n\tconst dstIndicesArray = [];\n\tlet nextIndex = 0;\n\n\t// For each vertex, compute a hash based on its tolerance and merge with any sufficiently\n\t// similar vertices.\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tconst index = srcIndices ? srcIndices.getScalar(i) : i;\n\n\t\tconst hashElements: number[] = [];\n\t\tconst el: number[] = [];\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tfor (let j = 0; j < attribute.getElementSize(); j++) {\n\t\t\t\thashElements.push(~ ~ (attribute.getElement(index, el)[j] * shiftFactor));\n\t\t\t}\n\t\t}\n\n\t\tconst hash = hashElements.join('|');\n\t\tif (hash in hashToIndex) {\n\t\t\tdstIndicesArray.push(hashToIndex[hash]);\n\t\t} else {\n\t\t\tfor (const attr of prim.listAttributes()) {\n\t\t\t\tdstAttributes.get(attr)!.push(attr.getElement(index, []));\n\t\t\t}\n\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\tfor (const attr of target.listAttributes()) {\n\t\t\t\t\tdstAttributes.get(attr)!.push(attr.getElement(index, []));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thashToIndex[hash] = nextIndex;\n\t\t\tdstIndicesArray.push(nextIndex);\n\t\t\tnextIndex++;\n\t\t}\n\t}\n\n\tconst srcVertexCount = prim.listAttributes()[0].getCount();\n\tconst dstVertexCount = dstAttributes.get(prim.getAttribute('POSITION')!)!.length;\n\tdoc.getLogger().debug(`${NAME}: ${srcVertexCount} → ${dstVertexCount} vertices.`);\n\n\t// Update the primitive.\n\tfor (const srcAttr of prim.listAttributes()) {\n\t\tswapAttributes(prim, srcAttr, dstAttributes.get(srcAttr)!);\n\n\t\t// Clean up.\n\t\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttr of target.listAttributes()) {\n\t\t\tswapAttributes(target, srcAttr, dstAttributes.get(srcAttr)!);\n\n\t\t\t// Clean up.\n\t\t\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n\t\t}\n\t}\n\tif (srcIndices) {\n\t\tconst dstIndicesTypedArray\n\t\t\t= createArrayOfType(srcIndices.getArray()!, dstIndicesArray.length);\n\t\tdstIndicesTypedArray.set(dstIndicesArray);\n\t\tprim.setIndices(srcIndices.clone().setArray(dstIndicesTypedArray));\n\n\t\t// Clean up.\n\t\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\t} else {\n\t\tconst indicesArray = srcVertexCount <= 65534\n\t\t\t? new Uint16Array(dstIndicesArray)\n\t\t\t: new Uint32Array(dstIndicesArray);\n\t\tprim.setIndices(doc.createAccessor().setArray(indicesArray));\n\t}\n}\n\n/** Creates a new TypedArray of the same type as an original, with a new length. */\nfunction createArrayOfType<T extends TypedArray>(array: T, length: number): T {\n\tconst ArrayCtor = array.constructor as new (length: number) => T;\n\treturn new ArrayCtor(length);\n}\n\n/** Replaces an {@link Attribute}, creating a new one with the given elements. */\nfunction swapAttributes(\n\t\tparent: Primitive | PrimitiveTarget,\n\t\tsrcAttr: Accessor,\n\t\tdstAttrElements: number[][]): void {\n\tconst dstAttrArrayLength = dstAttrElements.length * srcAttr.getElementSize();\n\tconst dstAttrArray = createArrayOfType(srcAttr.getArray()!, dstAttrArrayLength);\n\tconst dstAttr = srcAttr.clone().setArray(dstAttrArray);\n\n\tfor (let i = 0; i < dstAttrElements.length; i++) {\n\t\tdstAttr.setElement(i, dstAttrElements[i]);\n\t}\n\n\tparent.swap(srcAttr, dstAttr);\n}\n"],"names":["createTransform","name","fn","Object","defineProperty","value","rewriteTexture","source","target","srcImage","getImage","pixels","getPixels","Uint8Array","getMimeType","i","shape","j","dstImage","savePixels","buffer","setImage","setMimeType","getGLPrimitiveCount","prim","indices","getIndices","position","getAttribute","getMode","Primitive","Mode","POINTS","getCount","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Error","SetMap","_map","Map","size","has","k","add","v","entry","this","get","Set","set","keys","CENTER_DEFAULTS","pivot","center","_options","options","doc","logger","getLogger","root","getRoot","isAnimated","listAnimations","length","listSkins","listScenes","forEach","scene","index","debug","bbox","bounds","max","min","join","offset","offsetNode","createNode","setTranslation","listChildren","child","addChild","t","getTranslation","NAME","colorspace","inputEncoding","info","error","converted","sRGBToLinear","c","Math","pow","updatePrimitive","primitive","color","attribute","getElement","setElement","listMeshes","mesh","listPrimitives","DEDUP_DEFAULTS","propertyTypes","PropertyType","ACCESSOR","MESH","TEXTURE","MATERIAL","dedup","propertyType","includes","indicesAccessors","attributeAccessors","inputAccessors","outputAccessors","meshes","listAttributes","accessor","animation","sampler","listSamplers","input","getInput","output","getOutput","detectDuplicates","accessors","duplicateAccessors","a","aData","getArray","slice","b","getType","getComponentType","getNormalized","BufferUtils","equals","duplicateIndices","Array","from","duplicateAttributes","duplicateInputs","duplicateOutputs","swap","dispose","dedupAccessors","refs","listAccessors","listMaterials","material","numMeshes","uniqueMeshes","src","srcKeyItems","push","createPrimitiveKey","meshKey","targetMesh","listParents","parent","ROOT","dedupMeshes","textures","listTextures","duplicates","bData","aSize","getSize","bSize","entries","dst","property","Root","dedupImages","materials","dedupMaterials","primKeyItems","semantic","listSemantics","getMaterial","listTargets","DEQUANTIZE_DEFAULTS","pattern","dequantize","dequantizePrimitive","createExtension","MeshQuantization","dequantizeAttribute","test","getComponentSize","srcArray","dstArray","Float32Array","il","el","setArray","setNormalized","inspect","scenes","animations","properties","map","sceneBounds","getName","rootName","bboxMin","toPrecision","bboxMax","instances","filter","glPrimitives","verts","semantics","meshIndices","meshAccessors","attr","arrayToType","targ","byteLength","modes","MeshPrimitiveModeLabels","mode","primitives","vertices","sort","attributes","extensions","listExtensions","slots","getGraph","getLinks","link","getChild","getParent","Texture","ExtensionProperty","alphaMode","getAlphaMode","doubleSided","getDoubleSided","texture","listParentLinks","resolution","ImageUtils","uri","getURI","mimeType","gpuSize","getMemSize","anim","minTime","Infinity","maxTime","getMin","getMax","keyframes","channels","listChannels","samplers","duration","round","toFixed","Number","array","constructor","replace","toLowerCase","INSTANCE_DEFAULTS","instance","batchExtension","MeshGPUInstancing","numBatches","numInstances","meshInstances","traverse","node","getMesh","modifiedNodes","nodes","some","getSkin","batch","createBatch","batchTranslation","batchRotation","batchScale","batchNode","setMesh","setExtension","needsTranslation","needsRotation","needsScale","r","s","getWorldTranslation","getWorldRotation","getWorldScale","MathUtils","eq","pruneUnusedNodes","unusedNodes","pop","getCamera","nodeParent","Node","count","getBuffer","createAccessor","setType","setBuffer","createInstancedMesh","setAttribute","METALROUGH_DEFAULTS","metalRough","async","listExtensionsUsed","ext","extensionName","warn","iorExtension","MaterialsIOR","specExtension","MaterialsSpecular","specGlossExtension","MaterialsPBRSpecularGlossiness","inputTextures","specGloss","getExtension","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","setBaseColorFactor","getDiffuseFactor","setMetallicFactor","setRoughnessFactor","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","createTexture","setSpecularTexture","setSpecularColorTexture","getSpecularTextureInfo","getSpecularColorTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","tex","PRUNE_DEFAULTS","NODE","SKIN","CAMERA","PRIMITIVE","PRIMITIVE_TARGET","ANIMATION","BUFFER","prune","graph","disposed","listNodes","treeShake","listCameras","indirectTreeShake","channel","getTargetNode","markDisposed","listBuffers","str","prop","p","AnimationChannel","PARTITION_DEFAULTS","partition","existingURIs","meshIndex","isArray","createBuffer","setURI","createBufferURI","primTarget","partitionMeshes","animIndex","partitionAnimations","transform","basename","existing","SIGNED_INT","Int8Array","Int16Array","Int32Array","TRANSLATION","ROTATION","SCALE","WEIGHTS","TargetPath","TRS_CHANNELS","QUANTIZE_DEFAULTS","quantizationVolume","quantizePosition","quantizeNormal","quantizeTexcoord","quantizeColor","quantizeWeight","quantizeGeneric","quantize","nodeTransform","setRequired","getNodeTransform","bboxes","result","expandBounds","getPositionQuantizationVolume","transformMeshParents","quantizePrimitive","srcAttribute","bits","ctor","getQuantizationSettings","dstAttribute","clone","scale","invert","fromTransform","fromScaling","transformMat4","quantizeAttribute","vertexCount","weightsEl","weights","vertexWeightsSum","leastWeight","leastIndex","leastAttribute","attributeIndex","normalizeWeights","Uint16Array","volume","transformMatrix","animChannels","getTargetPath","isParentNode","setSkin","transformSkin","targetNode","setTargetNode","nodeMatrix","getMatrix","multiplyMat4","setMatrix","skin","inverseBindMatrices","getInverseBindMatrices","ibm","setInverseBindMatrices","signBits","quantBits","storageBits","BYTES_PER_ELEMENT","lo","hi","di","abs","sign","getMinNormalized","getMaxNormalized","startsWith","positions","relativePositions","flatBounds","relMin","relMax","elementSize","fill","tmpMin","tmpMax","fromRotationTranslationScale","RESAMPLE_DEFAULTS","tolerance","resample","context","accessorsVisited","accessorsCountPrev","didSkipMorphTargets","morphTargetSamplers","getSampler","getInterpolation","optimize","values","initial","pending","stack","lastIndexOf","isTransformPending","lastIndex","tmp","writeIndex","time","getScalar","timePrev","timeNext","timeMix","keep","getElementSize","valuePrev","valueNext","setScalar","setInput","setOutput","REORDER_DEFAULTS","reorder","encoder","ready","plan","indicesToAttributes","indicesToMode","attributesToPrimitives","preprocessPrimitives","srcIndices","dstIndices","indicesArray","Uint32Array","remap","unique","reorderMesh","remapAttribute","dstCount","srcCount","SEQUENCE_DEFAULTS","fps","sequence","sequenceNodes","match","createAnimation","animBuffer","inputArray","outputArray","Accessor","Type","VEC3","createAnimationSampler","setInterpolation","AnimationSampler","Interpolation","STEP","createAnimationChannel","setTargetPath","setSampler","addSampler","addChannel","TANGENTS_DEFAULTS","overwrite","tangents","generateTangents","attributeIDs","tangentCache","modified","meshName","meshPrimitives","filterPrimitive","texcoordSemantic","getNormalTexcoord","normal","texcoord","positionID","uuid","normalID","texcoordID","prevTangent","attributeHash","tangent","tangentBuffer","tangentArray","normalTextureInfo","getNormalTextureInfo","getTexCoord","TextureResizeFilter","TEXTURE_RESIZE_DEFAULTS","LANCZOS3","textureResize","maxWidth","maxHeight","srcWidth","srcHeight","dstWidth","dstHeight","floor","srcPixels","dstPixels","ndarray","lanczos3","lanczos2","e","message","UNWELD_DEFAULTS","unweld","visited","unweldAttribute","setIndices","ArrayCtor","WELD_DEFAULTS","weld","weldOnly","weldAndMerge","numVertices","SCALAR","EPSILON","decimalShift","log10","shiftFactor","hashToIndex","dstAttributes","dstIndicesArray","nextIndex","hashElements","hash","srcVertexCount","dstVertexCount","srcAttr","swapAttributes","dstIndicesTypedArray","createArrayOfType","dstAttrElements","dstAttrArrayLength","dstAttrArray","dstAttr"],"mappings":"89BASgBA,EAAgBC,EAAcC,GAE7C,OADAC,OAAOC,eAAeF,EAAI,OAAQ,CAAEG,MAAOJ,IACpCC,iBAWcI,EACpBC,EACAC,EACAN,GAED,IAAKK,EAAQ,YAEb,MAAME,EAAWF,EAAOG,WACxB,IAAKD,EAAU,YAEf,MAAME,QAAeC,EAAU,IAAIC,WAAWJ,GAAWF,EAAOO,eAEhE,IAAI,IAAIC,EAAI,EAAGA,EAAIJ,EAAOK,MAAM,KAAMD,EACrC,IAAI,IAAIE,EAAI,EAAGA,EAAIN,EAAOK,MAAM,KAAMC,EACrCf,EAAGS,EAAQI,EAAGE,GAIhB,MAAMC,SAAkBC,EAAWR,EAAQ,cAAcS,OACzD,OAAOZ,EAAOa,SAASH,GAAUI,YAAY,sBAG9BC,EAAoBC,GACnC,MAAMC,EAAUD,EAAKE,aACfC,EAAWH,EAAKI,aAAa,YAGnC,OAAQJ,EAAKK,WACZ,KAAKC,EAAUC,KAAKC,OACnB,OAAOL,EAASM,WACjB,KAAKH,EAAUC,KAAKG,MACnB,OAAOT,EACJA,EAAQQ,WAAa,EACrBN,EAASM,WAAa,EAC1B,KAAKH,EAAUC,KAAKI,UACnB,OAAOR,EAASM,WACjB,KAAKH,EAAUC,KAAKK,WACnB,OAAOT,EAASM,WAAa,EAC9B,KAAKH,EAAUC,KAAKM,UACnB,OAAOZ,EACJA,EAAQQ,WAAa,EACrBN,EAASM,WAAa,EAC1B,KAAKH,EAAUC,KAAKO,eACpB,KAAKR,EAAUC,KAAKQ,aACnB,OAAOZ,EAASM,WAAa,EAC9B,QACC,UAAUO,MAAM,oBAAsBhB,EAAKK,kBAIjCY,qBACJC,KAAO,IAAIC,IACJC,WACd,YAAYF,KAAKE,KAEXC,IAAIC,GACV,YAAYJ,KAAKG,IAAIC,GAEfC,IAAID,EAAME,GAChB,IAAIC,EAAQC,KAAKR,KAAKS,IAAIL,GAM1B,OALKG,IACJA,EAAQ,IAAIG,IACZF,KAAKR,KAAKW,IAAIP,EAAGG,IAElBA,EAAMF,IAAIC,QAGJG,IAAIL,GACV,YAAYJ,KAAKS,IAAIL,IAAM,IAAIM,IAEzBE,OACN,YAAYZ,KAAKY,QCzFnB,MAQMC,EAA2C,CAACC,MAAO,mBAYzCC,EAAQC,EAA0BH,GACjD,MAAMI,OAAcJ,EAAoBG,GAExC,OAAO1D,EAvBK,SAuBkB4D,IAC7B,MAAMC,EAASD,EAAIE,YACbC,EAAOH,EAAII,UACXC,EAAaF,EAAKG,iBAAiBC,OAAS,GAAKJ,EAAKK,YAAYD,OAAS,EAEjFP,EAAII,UAAUK,aAAaC,QAAQ,CAACC,EAAOC,KAG1C,IAAIhB,EACJ,GAHAK,EAAOY,uBAAwBD,EAAQ,OAAOT,EAAKM,aAAaF,WAGnC,iBAAlBR,EAAQH,MAAoB,CACtC,MAAMkB,EAAOC,EAAOJ,GACpBf,EAAQ,EACNkB,EAAKE,IAAI,GAAKF,EAAKG,IAAI,IAAM,EAAIH,EAAKG,IAAI,IAC1CH,EAAKE,IAAI,GAAKF,EAAKG,IAAI,IAAM,EAAIH,EAAKG,IAAI,IAC1CH,EAAKE,IAAI,GAAKF,EAAKG,IAAI,IAAM,EAAIH,EAAKG,IAAI,IAEtB,UAAlBlB,EAAQH,QAAmBA,EAAM,GAAKkB,EAAKE,IAAI,IAC7B,UAAlBjB,EAAQH,QAAmBA,EAAM,GAAKkB,EAAKG,IAAI,SAEnDrB,EAAQG,EAAQH,MAGjBK,EAAOY,wBAAyBjB,EAAMsB,KAAK,WAE3C,MAAMC,EAAe,EAAE,EAAIvB,EAAM,IAAK,EAAIA,EAAM,IAAK,EAAIA,EAAM,IAE/D,GAAIS,EAAY,CACfJ,EAAOY,0EACP,MAAMO,EAAapB,EAAIqB,WAAW,SAASC,eAAeH,GAC1DR,EAAMY,eAAeb,QAASc,GAAUJ,EAAWK,SAASD,IAC5Db,EAAMc,SAASL,QAEfnB,EAAOY,8DACPF,EAAMY,eAAeb,QAASc,IAC7B,MAAME,EAAIF,EAAMG,iBAChBH,EAAMF,eAAe,CACpBI,EAAE,GAAKP,EAAO,GACdO,EAAE,GAAKP,EAAO,GACdO,EAAE,GAAKP,EAAO,SAMlBlB,EAAOY,6BCpET,MAAMe,EAAO,sBAaGC,EAAY9B,GAE3B,OAAO3D,EAAgBwF,EAAO5B,IAE7B,MAAMC,EAASD,EAAIE,YAEnB,GAA8B,WAA1BH,EAAQ+B,cAEX,YADA7B,EAAO8B,QAAQH,yDAIhB,GAA8B,SAA1B7B,EAAQ+B,cAKX,YAJA7B,EAAO+B,SACHJ,8BAAiC7B,EAAQ+B,uEAM9C,MAAMG,EAAY,IAAIzC,IAGtB,SAAS0C,EAAcC,GAEtB,OAASA,EAAI,OACN,YAAJA,EACAC,KAAKC,IAAS,YAAJF,EAAmB,YAAc,KAI/C,SAASG,EAAgBC,GACxB,MAAMC,EAAQ,CAAC,EAAG,EAAG,GACrB,IAAIC,EACJ,IAAK,IAAItF,EAAI,EAAIsF,EAAYF,EAAUvE,sBAAsBb,KAAOA,IACnE,IAAI8E,EAAUhD,IAAIwD,GAAlB,CAEA,IAAK,IAAIpF,EAAI,EAAGA,EAAIoF,EAAUpE,WAAYhB,IACzCoF,EAAUC,WAAWrF,EAAGmF,GACxBA,EAAM,GAAKN,EAAaM,EAAM,IAC9BA,EAAM,GAAKN,EAAaM,EAAM,IAC9BA,EAAM,GAAKN,EAAaM,EAAM,IAC9BC,EAAUE,WAAWtF,EAAGmF,GAGzBP,EAAU9C,IAAIsD,IAIhBzC,EAAII,UACFwC,aACAlC,QAASmC,GAASA,EAAKC,iBAAiBpC,QAAQ4B,IAElDrC,EAAOY,SAASe,kBCjElB,MAOMmB,EAAyC,CAC9CC,cAAe,CACdC,EAAaC,SACbD,EAAaE,KACbF,EAAaG,QACbH,EAAaI,WAoBFC,EAAQ,SAAUxD,EAAyBiD,GACvD,MAAMhD,OAAcgD,EAAmBjD,GAEjCkD,EAAgB,IAAIxD,IAAIO,EAAQiD,eACtC,IAAK,MAAMO,KAAgBxD,EAAQiD,cAClC,IAAKD,EAAeC,cAAcQ,SAASD,GAC1C,UAAU3E,mDAAqD2E,OAIjE,OAAOnH,EA1CK,QA0CkB4D,IAC7B,MAAMC,EAASD,EAAIE,YAEf8C,EAAc/D,IAAIgE,EAAaC,WAUrC,SAAwBjD,EAAgBD,GAEvC,MAAMyD,EAAkC,IAAIjE,IACtCkE,EAAoC,IAAIlE,IACxCmE,EAAgC,IAAInE,IACpCoE,EAAiC,IAAIpE,IAErCqE,EAAS7D,EAAII,UAAUwC,aAC7BiB,EAAOnD,QAASmC,IACfA,EAAKC,iBAAiBpC,QAAS6B,IAC9BA,EAAUuB,iBAAiBpD,QAASqD,GAAcL,EAAmBvE,IAAI4E,IACzE,MAAMlG,EAAU0E,EAAUzE,aACtBD,GAAS4F,EAAiBtE,IAAItB,OAIpC,IAAK,MAAMmG,KAAahE,EAAII,UAAUE,iBACrC,IAAK,MAAM2D,KAAWD,EAAUE,eAAgB,CAC/C,MAAMC,EAAQF,EAAQG,WAChBC,EAASJ,EAAQK,YACnBH,GAAOR,EAAexE,IAAIgF,GAC1BE,GAAQT,EAAgBzE,IAAIkF,GAKlC,SAASE,EAAiBC,GACzB,MAAMC,EAA8C,IAAI1F,IAExD,IAAK,IAAI5B,EAAI,EAAGA,EAAIqH,EAAUjE,OAAQpD,IAAK,CAC1C,MAAMuH,EAAIF,EAAUrH,GACdwH,EAAQD,EAAEE,WAAYC,QAAQrH,OAEpC,IAAIiH,EAAmBxF,IAAIyF,GAE3B,IAAK,IAAIrH,EAAI,EAAGA,EAAImH,EAAUjE,OAAQlD,IAAK,CAC1C,MAAMyH,EAAIN,EAAUnH,GAEhBqH,IAAMI,IACNL,EAAmBxF,IAAI6F,IAEvBJ,EAAEK,YAAcD,EAAEC,WAClBL,EAAEM,qBAAuBF,EAAEE,oBAC3BN,EAAErG,aAAeyG,EAAEzG,YACnBqG,EAAEO,kBAAoBH,EAAEG,iBACxBC,EAAYC,OAAOR,EAAOG,EAAEF,WAAYC,QAAQrH,SACnDiH,EAAmBhF,IAAIqF,EAAGJ,KAK7B,OAAOD,EAGR,MAAMW,EAAmBb,EAAiBc,MAAMC,KAAK7B,IACrDxD,EAAOY,sBACYuE,EAAiBpG,yBAAyByE,EAAiBzE,iBAG9E,MAAMuG,EAAsBhB,EAAiBc,MAAMC,KAAK5B,IACxDzD,EAAOY,sBACY0E,EAAoBvG,yBAAyB0E,EAAmB1E,oBAInF,MAAMwG,EAAkBjB,EAAiBc,MAAMC,KAAK3B,IAC9C8B,EAAmBlB,EAAiBc,MAAMC,KAAK1B,IACrD3D,EAAOY,sBACY2E,EAAgBxG,KAAOyG,EAAiBzG,yBACpD2E,EAAe3E,KAAO4E,EAAgB5E,6BAI7C6E,EAAOnD,QAASmC,IACfA,EAAKC,iBAAiBpC,QAAS6B,IAC9BA,EAAUuB,iBAAiBpD,QAASqD,IAC/BwB,EAAoBtG,IAAI8E,IAC3BxB,EAAUmD,KAAK3B,EAAUwB,EAAoBhG,IAAIwE,MAGnD,MAAMlG,EAAU0E,EAAUzE,aACtBD,GAAWuH,EAAiBnG,IAAIpB,IACnC0E,EAAUmD,KAAK7H,EAASuH,EAAiB7F,IAAI1B,QAIhDwH,MAAMC,KAAKF,EAAiB1F,QAAQgB,QAAS7C,GAAYA,EAAQ8H,WACjEN,MAAMC,KAAKC,EAAoB7F,QAAQgB,QAAS+B,GAAcA,EAAUkD,WAGxE,IAAK,MAAM3B,KAAahE,EAAII,UAAUE,iBACrC,IAAK,MAAM2D,KAAWD,EAAUE,eAAgB,CAC/C,MAAMC,EAAQF,EAAQG,WAChBC,EAASJ,EAAQK,YACnBH,GAASqB,EAAgBvG,IAAIkF,IAChCF,EAAQyB,KAAKvB,EAAOqB,EAAgBjG,IAAI4E,IAErCE,GAAUoB,EAAiBxG,IAAIoF,IAClCJ,EAAQyB,KAAKrB,EAAQoB,EAAiBlG,IAAI8E,IAI7CgB,MAAMC,KAAKE,EAAgB9F,QAAQgB,QAASyD,GAAUA,EAAMwB,WAC5DN,MAAMC,KAAKG,EAAiB/F,QAAQgB,QAAS2D,GAAWA,EAAOsB,WAjHhBC,CAAe3F,EAAQD,GACjEgD,EAAc/D,IAAIgE,EAAaE,OAmHrC,SAAqBlD,EAAgBD,GACpC,MAAMG,EAAOH,EAAII,UAGXyF,EAAO,IAAI9G,IACjBoB,EAAK2F,gBAAgBpF,QAAQ,CAACqD,EAAUnD,IAAUiF,EAAKpG,IAAIsE,EAAUnD,IACrET,EAAK4F,gBAAgBrF,QAAQ,CAACsF,EAAUpF,IAAUiF,EAAKpG,IAAIuG,EAAUpF,IAGrE,MAAMqF,EAAY9F,EAAKyC,aAAarC,OAC9B2F,EAAe,IAAInH,IACzB,IAAK,MAAMoH,KAAOhG,EAAKyC,aAAc,CAEpC,MAAMwD,EAAc,GACpB,IAAK,MAAMxI,KAAQuI,EAAIrD,iBACtBsD,EAAYC,KAAKC,EAAmB1I,EAAMiI,IAK3C,MAAMU,EAAUH,EAAYlF,KAAK,KACjC,GAAIgF,EAAajH,IAAIsH,GAAU,CAC9B,MAAMC,EAAaN,EAAa3G,IAAIgH,GACpCJ,EAAIM,cAAc/F,QAASgG,IACtBA,EAAOnD,eAAiBN,EAAa0D,MACxCD,EAAOhB,KAAKS,EAAKK,KAGnBL,EAAIR,eAEJO,EAAazG,IAAI8G,EAASJ,GAI5BlG,EAAOY,sBACYoF,EAAYC,EAAalH,yBAAyBiH,aAtJ1BW,CAAY3G,EAAQD,GAC1DgD,EAAc/D,IAAIgE,EAAaG,UAyJrC,SAAqBnD,EAAgBD,GACpC,MAAMG,EAAOH,EAAII,UACXyG,EAAW1G,EAAK2G,eAChBC,EAAoC,IAAIhI,IAG9C,IAAK,IAAI5B,EAAI,EAAGA,EAAI0J,EAAStG,OAAQpD,IAAK,CACzC,MAAMuH,EAAImC,EAAS1J,GACbwH,EAAQD,EAAE5H,WAEhB,IAAIiK,EAAW9H,IAAIyF,GAEnB,IAAK,IAAIrH,EAAI,EAAGA,EAAIwJ,EAAStG,OAAQlD,IAAK,CACzC,MAAMyH,EAAI+B,EAASxJ,GACb2J,EAAQlC,EAAEhI,WAEhB,GAAI4H,IAAMI,EAAG,SACb,GAAIiC,EAAW9H,IAAI6F,GAAI,SAGvB,GAAIJ,EAAExH,gBAAkB4H,EAAE5H,cAAe,SAEzC,MAAM+J,EAAQvC,EAAEwC,UACVC,EAAQrC,EAAEoC,UACXD,GAAUE,GACXF,EAAM,KAAOE,EAAM,IACnBF,EAAM,KAAOE,EAAM,IAClBxC,GAAUqC,GACX9B,EAAYC,OAAOR,EAAOqC,IAC7BD,EAAWtH,IAAIqF,EAAGJ,IAKrBzE,EAAOY,sBACYkG,EAAW/H,yBAAyBmB,EAAK2G,eAAevG,oBAG3E8E,MAAMC,KAAKyB,EAAWK,WAAW1G,QAAQ,EAAEyF,EAAKkB,MAC/ClB,EAAIM,cAAc/F,QAAS4G,IACpBA,aAAoBC,GAAOD,EAAS5B,KAAKS,EAAKkB,KAErDlB,EAAIR,YAnMyC6B,CAAYvH,EAAQD,GAC7DgD,EAAc/D,IAAIgE,EAAaI,WAsMrC,SAAwBpD,EAAgBD,GACvC,MAAMG,EAAOH,EAAII,UACXqH,EAAYtH,EAAK4F,gBACjBgB,EAAsC,IAAIhI,IAGhD,IAAK,IAAI5B,EAAI,EAAGA,EAAIsK,EAAUlH,OAAQpD,IAAI,CACzC,MAAMuH,EAAI+C,EAAUtK,GAEpB,IAAI4J,EAAW9H,IAAIyF,GAEnB,IAAK,IAAIrH,EAAI,EAAGA,EAAIoK,EAAUlH,OAAQlD,IAAI,CACzC,MAAMyH,EAAI2C,EAAUpK,GAEhBqH,IAAMI,IACNiC,EAAW9H,IAAI6F,IAEfJ,EAAES,OAAOL,IACZiC,EAAWtH,IAAIqF,EAAGJ,KAKrBzE,EAAOY,sBAEYkG,EAAW/H,yBAAyBmB,EAAK4F,gBAAgBxF,qBAG5E8E,MAAMC,KAAKyB,EAAWK,WAAW1G,QAAQ,EAAEyF,EAAKkB,MAC/ClB,EAAIM,cAAc/F,QAAS4G,IACpBA,aAAoBC,GAAOD,EAAS5B,KAAKS,EAAKkB,KAErDlB,EAAIR,YAtO0C+B,CAAezH,EAAQD,GAErEC,EAAOY,6BAyOT,SAASyF,EACR1I,EACAiI,GAEA,MAAM8B,EAAe,GACrB,IAAK,MAAMC,KAAYhK,EAAKiK,gBAAiB,CAC5C,MAAMpF,EAAY7E,EAAKI,aAAa4J,GACpCD,EAAatB,KAAKuB,EAAW,IAAM/B,EAAKtG,IAAIkD,IAE7C,GAAI7E,aAAgBM,EAAW,CAC9B,MAAML,EAAUD,EAAKE,aACjBD,GACH8J,EAAatB,KAAK,WAAaR,EAAKtG,IAAI1B,IAEzC,MAAMmI,EAAWpI,EAAKkK,cAClB9B,GACH2B,EAAatB,KAAK,YAAcR,EAAKtG,IAAIyG,IAE1C2B,EAAatB,KAAK,QAAUzI,EAAKK,WACjC,IAAK,MAAMrB,KAAUgB,EAAKmK,cACzBJ,EAAatB,KAAK,UAAYC,EAAmB1J,EAAQiJ,IAG3D,OAAO8B,EAAazG,KAAK,KCjT1B,MAWM8G,EAAyC,CAC9CC,QAAS,8BAQMC,EAAWpI,EAA8BkI,GACxD,MAAMjI,OAAciI,EAAwBlI,GAE5C,OAAO1D,EAvBK,aAuBkB4D,IAC7B,MAAMC,EAASD,EAAIE,YACnB,IAAK,MAAM2C,KAAQ7C,EAAII,UAAUwC,aAChC,IAAK,MAAMhF,KAAQiF,EAAKC,iBACvBqF,EAAoBvK,EAAMmC,GAG5BC,EAAIoI,gBAAgBC,GAAkB1C,UACtC1F,EAAOY,iCAIT,SAASsH,EAAoBvK,EAAiBmC,GAC7C,IAAK,MAAM6H,KAAYhK,EAAKiK,gBAC3BS,EAAoBV,EAAUhK,EAAKI,aAAa4J,GAAY7H,GAE7D,IAAK,MAAMnD,KAAUgB,EAAKmK,cACzB,IAAK,MAAMH,KAAYhL,EAAOiL,gBAC7BS,EAAoBV,EAAUhL,EAAOoB,aAAa4J,GAAY7H,GAKjE,SAASuI,EAAoBV,EAAkBnF,EAAqB1C,GACnE,IAAK0C,EAAUmC,WAAY,OAC3B,IAAK7E,EAAQkI,QAAQM,KAAKX,GAAW,OACrC,GAAInF,EAAU+F,oBAAsB,EAAG,OAEvC,MAAMC,EAAWhG,EAAUmC,WACrB8D,EAAW,IAAIC,aAAaF,EAASlI,QAE3C,IAAK,IAAIpD,EAAI,EAAGyL,EAAKnG,EAAUpE,WAAYwK,EAAK,GAAgB1L,EAAIyL,EAAIzL,IACvE0L,EAAKpG,EAAUC,WAAWvF,EAAG0L,GAC7BpG,EAAUqG,SAASJ,GAAU/F,WAAWxF,EAAG0L,GAAIC,SAASL,GAGzDhG,EAAUqG,SAASJ,GAAUK,eAAc,YC3D5BC,EAAShJ,GACxB,MAAO,CACNiJ,OAAQxI,EAAWT,GACnB6D,OAAQjB,EAAW5C,GACnByH,UAAW1B,EAAc/F,GACzB6G,SAAUC,EAAa9G,GACvBkJ,WAAY5I,EAAeN,IAK7B,SAASS,EAAYT,GAWpB,MAAO,CAACmJ,WAVOnJ,EAAII,UAAUK,aAAa2I,IAAKzI,IAC9C,MAAMR,EAAOQ,EAAMY,eAAe,GAC5B8H,EAActI,EAAOJ,GAC3B,MAAO,CACNtE,KAAMsE,EAAM2I,UACZC,SAAUpJ,EAAOA,EAAKmJ,UAAY,GAClCE,QAASC,GAAYJ,EAAYpI,KACjCyI,QAASD,GAAYJ,EAAYrI,SAOpC,SAAS4B,EAAY5C,GAgDpB,MAAO,CAACmJ,WA/C4BnJ,EAAII,UAAUwC,aAAawG,IAAKvG,IACnE,MAAM8G,EAAY9G,EAAK4D,cACrBmD,OAAQlD,GAAmC,SAAxBA,EAAOnD,cAC1BhD,OACF,IAAIsJ,EAAe,EACfC,EAAQ,EACZ,MAAMC,EAAY,IAAIvK,IAChBwK,EAAc,IAAIxK,IAClByK,EAA+B,IAAIzK,IAEzCqD,EAAKC,iBAAiBpC,QAAS9C,IAC9B,IAAK,MAAMgK,KAAYhK,EAAKiK,gBAAiB,CAC5C,MAAMqC,EAAOtM,EAAKI,aAAa4J,GAC/BmC,EAAU5K,IAAIyI,EAAW,IAAMuC,GAAYD,EAAKtF,aAChDqF,EAAc9K,IAAI+K,GAEnB,IAAK,MAAME,KAAQxM,EAAKmK,cACvBqC,EAAKtG,iBAAiBpD,QAASwJ,GAASD,EAAc9K,IAAI+K,IAE3D,MAAMrM,EAAUD,EAAKE,aACjBD,IACHmM,EAAY7K,IAAIgL,GAAYtM,EAAQ+G,aACpCqF,EAAc9K,IAAItB,IAEnBiM,GAASlM,EAAKkG,iBAAiB,GAAGzF,WAClCwL,GAAgBlM,EAAoBC,KAGrC,IAAIoB,EAAO,EACXqG,MAAMC,KAAK2E,GAAevJ,QAASgE,GAAO1F,GAAQ0F,EAAEE,WAAYyF,YAEhE,MAAMC,EAAQzH,EAAKC,iBACjBsG,IAAKxL,GAAS2M,GAAwB3M,EAAKK,YAE7C,MAAO,CACN5B,KAAMwG,EAAKyG,UACXkB,KAAMnF,MAAMC,KAAK,IAAI9F,IAAI8K,IACzBG,WAAY5H,EAAKC,iBAAiBvC,OAClCsJ,aAAcA,EACda,SAAUZ,EACVjM,QAASwH,MAAMC,KAAK0E,GAAaW,OACjCC,WAAYvF,MAAMC,KAAKyE,GAAWY,OAClChB,UAAWA,EACX3K,KAAMA,MAQT,SAAS+G,EAAe/F,GAiCvB,MAAO,CAACmJ,WAhCmCnJ,EAAII,UAAU2F,gBAAgBqD,IAAKpD,IAC7E,MAAM2D,EAAY3D,EAASS,cACzBmD,OAAQlD,GAAmC,SAAxBA,EAAOnD,cAC1BhD,OAGIsK,EAAa,IAAIrL,IAAuBwG,EAAS8E,kBACjDC,EAAQ/K,EAAIgL,WAAWC,WAC3BrB,OAAQsB,IACR,MAAM1J,EAAQ0J,EAAKC,WACbzE,EAASwE,EAAKE,YACpB,OAAI5J,aAAiB6J,GAAW3E,IAAWV,MAGvCxE,aAAiB6J,GAChB3E,aAAkB4E,GAClBT,EAAW5L,IAAIyH,MAKpB0C,IAAK8B,GAASA,EAAK5B,WAErB,MAAO,CACNjN,KAAM2J,EAASsD,UACfK,UAAAA,EACA9C,SAAUkE,EACVQ,UAAWvF,EAASwF,eACpBC,YAAazF,EAAS0F,qBAQzB,SAAS5E,EAAc9G,GAwBtB,MAAO,CAACmJ,WAvBiCnJ,EAAII,UAAU0G,eAAesC,IAAKuC,IAC1E,MAAMhC,EAAYgC,EAAQlF,cACxBmD,OAAQlD,GAAmC,SAAxBA,EAAOnD,cAC1BhD,OAEIwK,EAAQ/K,EAAIgL,WAAWY,gBAAgBD,GAC3CvC,IAAK8B,GAASA,EAAK5B,WACnBM,OAAQvN,GAAkB,YAATA,GAEbwP,EAAaC,EAAW5E,QAAQyE,EAAQ7O,WAAa6O,EAAQzO,eAEnE,MAAO,CACNb,KAAMsP,EAAQrC,UACdyC,IAAKJ,EAAQK,SACbjB,MAAO1F,MAAMC,KAAK,IAAI9F,IAAIuL,IAC1BpB,UAAAA,EACAsC,SAAUN,EAAQzO,cAClB2O,WAAYA,EAAaA,EAAW3K,KAAK,KAAO,GAChDlC,KAAM2M,EAAQ7O,WAAYuN,WAC1B6B,QAASJ,EAAWK,WAAWR,EAAQ7O,WAAa6O,EAAQzO,mBAQ/D,SAASoD,EAAgBN,GAqCxB,MAAO,CAACmJ,WApCqCnJ,EAAII,UAAUE,iBAAiB8I,IAAKgD,IAChF,IAAIC,EAAUC,SACVC,GAAWD,SACfF,EAAKlI,eAAexD,QAASuD,IAC5B,MAAME,EAAQF,EAAQG,WACjBD,IACLkI,EAAUjK,KAAKnB,IAAIoL,EAASlI,EAAMqI,OAAO,IAAI,IAC7CD,EAAUnK,KAAKpB,IAAIuL,EAASpI,EAAMsI,OAAO,IAAI,OAG9C,IAAIzN,EAAO,EACP0N,EAAY,EAChB,MAAMlI,EAA2B,IAAIhF,IAcrC,OAbA4M,EAAKlI,eAAexD,QAASuD,IAC5B,MAAME,EAAQF,EAAQG,WAChBC,EAASJ,EAAQK,YAClBH,IACLuI,GAAavI,EAAM9F,WACnBmG,EAAUrF,IAAIgF,GACTE,GACLG,EAAUrF,IAAIkF,MAEfgB,MAAMC,KAAKd,GAAW9D,QAASqD,IAC9B/E,GAAQ+E,EAASa,WAAYyF,aAGvB,CACNhO,KAAM+P,EAAK9C,UACXqD,SAAUP,EAAKQ,eAAerM,OAC9BsM,SAAUT,EAAKlI,eAAe3D,OAC9BuM,SAAU1K,KAAK2K,MAA4B,KAArBR,EAAUF,IAAmB,IACnDK,UAAWA,EACX1N,KAAMA,MAoET,MAAMuL,GAA0B,CAC/B,SACA,QACA,YACA,aACA,YACA,iBACA,gBAID,SAASd,GAAYrK,GACpB,IAAK,IAAIjC,EAAI,EAAGA,EAAIiC,EAAEmB,OAAQpD,IACxBiC,EAAEjC,GAAc6P,UAAS5N,EAAEjC,GAAK8P,OAAO7N,EAAEjC,GAAG6P,QAAQ,KAE1D,OAAO5N,EAGR,SAAS+K,GAAY+C,GACpB,OAAOA,EAAMC,YAAY9Q,KAAK+Q,QAAQ,QAAS,IAAIC,cCvQpD,MAKMC,GAA+C,YAMrCC,GAAUzN,EAA4BwN,IAIrD,YAFoBA,GAAsBxN,GAEnC1D,EAfK,WAekB4D,IAC7B,MAAMC,EAASD,EAAIE,YACbC,EAAOH,EAAII,UACXoN,EAAiBxN,EAAIoI,gBAAgBqF,GAE3C,GAAItN,EAAKG,iBAAiBC,OACzB,UAAU3B,8EAGX,IAAI8O,EAAa,EACbC,EAAe,EAEnB,IAAK,MAAMhN,KAASR,EAAKM,aAAc,CAEtC,MAAMmN,EAAgB,IAAI7O,IAC1B4B,EAAMkN,SAAUC,IACf,MAAMjL,EAAOiL,EAAKC,UACblL,GACL+K,EAAcnO,IAAIoD,GAAO+K,EAAcrO,IAAIsD,IAAS,IAAIrD,KAAaL,IAAI2O,MAI1E,MAAME,EAAgB,GACtB,IAAK,MAAMnL,KAAQwC,MAAMC,KAAKsI,EAAclO,QAAS,CACpD,MAAMuO,EAAQ5I,MAAMC,KAAKsI,EAAcrO,IAAIsD,IAC3C,GAAIoL,EAAM1N,OAAS,EAAG,SACtB,GAAI0N,EAAMC,KAAMJ,GAASA,EAAKK,WAAY,SAE1C,MAAMC,EAAQC,GAAYrO,EAAKwN,EAAgB3K,EAAMoL,EAAM1N,QACrD+N,EAAmBF,EAAMpQ,aAAa,eACtCuQ,EAAgBH,EAAMpQ,aAAa,YACnCwQ,EAAaJ,EAAMpQ,aAAa,SAEhCyQ,EAAYzO,EAAIqB,aACpBqN,QAAQ7L,GACR8L,aAAa,0BAA2BP,GAC1CzN,EAAMc,SAASgN,GAEf,IAAIG,GAAmB,EACnBC,GAAgB,EAChBC,GAAa,EAGjB,IAAK,IAAI3R,EAAI,EAAGA,EAAI8Q,EAAM1N,OAAQpD,IAAK,CACtC,IAAIuE,EAASqN,EAASC,EACtB,MAAMlB,EAAOG,EAAM9Q,GAEnBmR,EAAiB3L,WAAWxF,EAAGuE,EAAIoM,EAAKmB,uBACxCV,EAAc5L,WAAWxF,EAAG4R,EAAIjB,EAAKoB,oBACrCV,EAAW7L,WAAWxF,EAAG6R,EAAIlB,EAAKqB,iBAE7BC,EAAUC,GAAG3N,EAAG,CAAC,EAAG,EAAG,MAAKkN,GAAmB,GAC/CQ,EAAUC,GAAGN,EAAG,CAAC,EAAG,EAAG,EAAG,MAAKF,GAAgB,GAC/CO,EAAUC,GAAGL,EAAG,CAAC,EAAG,EAAG,MAAKF,GAAa,GAG9ChB,EAAKY,QAAQ,MACbV,EAAc3H,KAAKyH,GAGfc,GAAkBN,EAAiB3I,UACnCkJ,GAAeN,EAAc5I,UAC7BmJ,GAAYN,EAAW7I,UAE5B2J,GAAiBtB,EAAe/N,GAEhCyN,IACAC,GAAgBM,EAAM1N,QAIpBmN,EAAa,EAChBzN,EAAO8B,0BACc2L,mBAA4BC,uBAGjD1N,EAAO8B,mEACPyL,EAAe7H,WAGhB1F,EAAOY,+BAKT,SAASyO,GAAiBrB,EAAehO,GACxC,IAAI6N,EACAyB,EAAc,EAClB,KAAQzB,EAAOG,EAAMuB,OAAQ,CAC5B,GAAI1B,EAAKvM,eAAehB,QACnBuN,EAAK2B,aACL3B,EAAKC,WACLD,EAAKK,WACLL,EAAKhD,iBAAiBvK,OAC1B,SAED,MAAMmP,EAAa5B,EAAK1C,YACpBsE,aAAsBC,GACzB1B,EAAM5H,KAAKqJ,GAEZ5B,EAAKnI,UACL4J,IAGDtP,EAAOY,2BAA0B0O,mBAGlC,SAASlB,GACPrO,EACAwN,EACA3K,EACA+M,GACD,MAAMpS,EAASqF,EAAKC,iBAAiB,GAAG9E,aAAa,YAAa6R,YAE5DvB,EAAmBtO,EAAI8P,iBAC3BC,QAAQ,QACRjH,SAAS,IAAIH,aAAa,EAAIiH,IAC9BI,UAAUxS,GACN+Q,EAAgBvO,EAAI8P,iBACxBC,QAAQ,QACRjH,SAAS,IAAIH,aAAa,EAAIiH,IAC9BI,UAAUxS,GACNgR,EAAaxO,EAAI8P,iBACrBC,QAAQ,QACRjH,SAAS,IAAIH,aAAa,EAAIiH,IAC9BI,UAAUxS,GAEZ,OAAOgQ,EAAeyC,sBACpBC,aAAa,cAAe5B,GAC5B4B,aAAa,WAAY3B,GACzB2B,aAAa,QAAS1B,GCjJzB,MAKM2B,GAAmD,YAUzCC,GAAYtQ,EAA8BqQ,IAIzD,YAFoBA,GAAwBrQ,GAErC1D,EAnBK,aAmBiBiU,MAAAA,IAE5B,MAAMpQ,EAASD,EAAIE,YAGnB,IADuBF,EAAII,UAAUkQ,qBAAqBlH,IAAKmH,GAAQA,EAAIC,eACvDhN,SAAS,uCAE5B,YADAvD,EAAOwQ,+EAIR,MAAMC,EAAe1Q,EAAIoI,gBAAgBuI,GACnCC,EAAgB5Q,EAAIoI,gBAAgByI,GACpCC,EAAqB9Q,EAAIoI,gBAAgB2I,GAEzCC,EAAgB,IAAIxR,IAE1B,IAAK,MAAMwG,KAAYhG,EAAII,UAAU2F,gBAAiB,CACrD,MAAMkL,EAAYjL,EAChBkL,aAAoC,uCACtC,IAAKD,EAAW,SAGhB,MAAME,EAAWP,EAAcQ,iBAC7BC,kBAAkB,GAClBC,uBAAuBL,EAAUM,qBAGnCP,EAAc7R,IAAI8R,EAAUO,gCAC5BR,EAAc7R,IAAI6G,EAASyL,uBAC3BT,EAAc7R,IAAI6G,EAAS0L,+BAO3B1L,EACE2L,mBAAmBV,EAAUW,oBAC7BC,kBAAkB,GAClBC,mBAAmB,GACnBnD,aAAa,oBAAqB+B,EAAaqB,YAAYC,OAAO,MAClErD,aAAa,yBAA0BwC,GAGzC,MAAMc,EAAiBhB,EAAUiB,oBAC7BD,IACHjM,EAASmM,oBAAoBF,GAC7BjM,EAASoM,0BAA2BC,KAAKpB,EAAUqB,0BAIpD,MAAMC,EAAYtB,EAAUO,+BAC5B,GAAIe,EAAW,CAEd,MAAMC,EAAgBvB,EAAUwB,mCAC1BC,EAAkB1S,EAAI2S,sBACtBjW,EAAe6V,EAAWG,EAAiB,CAAC3V,EAAQI,EAAGE,KAC5DN,EAAO0C,IAAItC,EAAGE,EAAG,EAAG,OAErB8T,EAASyB,mBAAmBF,GAC5BvB,EAAS0B,wBAAwBH,GACjCvB,EAAS2B,yBAA0BT,KAAKG,GACxCrB,EAAS4B,8BAA+BV,KAAKG,GAG7C,MAAMQ,EAAmB/B,EAAUgC,sBAC7BC,EAAoBlT,EAAI2S,sBACxBjW,EAAe6V,EAAWW,EAAmB,CAACnW,EAAQI,EAAGE,KAE9D,MAAM8V,EAAY,IAAM/Q,KAAK2K,MAAMhQ,EAAOwC,IAAIpC,EAAGE,EAAG,GAAK2V,GACzDjW,EAAO0C,IAAItC,EAAGE,EAAG,EAAG,GACpBN,EAAO0C,IAAItC,EAAGE,EAAG,EAAG8V,GACpBpW,EAAO0C,IAAItC,EAAGE,EAAG,EAAG,GACpBN,EAAO0C,IAAItC,EAAGE,EAAG,EAAG,OAErB2I,EAASoN,4BAA4BF,GACrClN,EAASqN,kCAAmChB,KAAKG,QAEjDrB,EAASG,uBAAuBL,EAAUM,qBAC1CvL,EAAS8L,mBAAmB,EAAIb,EAAUgC,uBAI3CjN,EAAS2I,aAAa,sCAAuC,MAI9DmC,EAAmBnL,UAGnB,IAAK,MAAM2N,KAAOtC,EACbsC,GAAoC,IAA7BA,EAAI7M,cAAclG,QAAc+S,EAAI3N,UAGhD1F,EAAOY,iCClHT,MAMM0S,GAAyC,CAC9CvQ,cAAe,CACdC,EAAauQ,KACbvQ,EAAawQ,KACbxQ,EAAaE,KACbF,EAAayQ,OACbzQ,EAAa0Q,UACb1Q,EAAa2Q,iBACb3Q,EAAa4Q,UACb5Q,EAAaI,SACbJ,EAAaG,QACbH,EAAaC,SACbD,EAAa6Q,SAqBFC,GAAQ,SAAUjU,EAAyByT,IAEvD,MACMvQ,OADcuQ,GAAmBzT,GACTkD,cAE9B,OAAO5G,EA5CK,QA4CkB4D,IAC7B,MAAMC,EAASD,EAAIE,YACbC,EAAOH,EAAII,UACX4T,EAAQhU,EAAIgL,WAEZiJ,EAAmC,GAqBzC,GAhBIjR,EAAcQ,SAASP,EAAauQ,OAAOrT,EAAK+T,YAAYxT,QAAQyT,GACpEnR,EAAcQ,SAASP,EAAawQ,OAAOtT,EAAKK,YAAYE,QAAQyT,GACpEnR,EAAcQ,SAASP,EAAaE,OAAOhD,EAAKyC,aAAalC,QAAQyT,GACrEnR,EAAcQ,SAASP,EAAayQ,SAASvT,EAAKiU,cAAc1T,QAAQyT,GAExEnR,EAAcQ,SAASP,EAAa0Q,YACvCU,EAAkBL,EAAO/Q,EAAa0Q,WAEnC3Q,EAAcQ,SAASP,EAAa2Q,mBACvCS,EAAkBL,EAAO/Q,EAAa2Q,kBAOnC5Q,EAAcQ,SAASP,EAAa4Q,WACvC,IAAK,MAAMzH,KAAQjM,EAAKG,iBAAkB,CACzC,IAAK,MAAMgU,KAAWlI,EAAKQ,eACrB0H,EAAQC,kBACZD,EAAQ3O,UACR6O,EAAaF,IAGf,GAAKlI,EAAKQ,eAAerM,OAKxB6L,EAAKlI,eAAexD,QAAQyT,OALI,CAChC,MAAMtH,EAAWT,EAAKlI,eACtBiQ,EAAU/H,GACVS,EAASnM,QAAQyT,IAiBpB,GAVInR,EAAcQ,SAASP,EAAaI,WAAWlD,EAAK4F,gBAAgBrF,QAAQyT,GAC5EnR,EAAcQ,SAASP,EAAaG,UAAUjD,EAAK2G,eAAepG,QAAQyT,GAC1EnR,EAAcQ,SAASP,EAAaC,WAAW/C,EAAK2F,gBAAgBpF,QAAQyT,GAC5EnR,EAAcQ,SAASP,EAAa6Q,SAAS3T,EAAKsU,cAAc/T,QAAQyT,GAOxE5X,OAAOmD,KAAKuU,GAAU1T,OAAQ,CACjC,MAAMmU,EAAMnY,OAAOmD,KAAKuU,GAAU7K,IAAK1H,MAASA,MAAMuS,EAASvS,OAAOR,KAAK,MAC3EjB,EAAO8B,gCAAkC2S,UAEzCzU,EAAO8B,2CAQR,SAASoS,EAAUQ,GAGFA,EAAKlO,cACnBmD,OAAQgL,KAAQA,aAAarN,GAAQqN,aAAaC,IACvCtU,SACZoU,EAAKhP,UACL6O,EAAaG,IASf,SAASN,EAAkBL,EAAwBzQ,GAClDyQ,EAAM/I,WACJ7B,IAAK8B,GAASA,EAAKE,aACnBxB,OAAQlD,GAAWA,EAAOnD,eAAiBA,GAC3C7C,QAAQyT,GAIX,SAASK,EAAaG,GACrBV,EAASU,EAAKpR,cAAgB0Q,EAASU,EAAKpR,eAAiB,EAC7D0Q,EAASU,EAAKpR,gBA/BftD,EAAOY,6BCjGHiU,GAAkD,CACvD5L,YAAY,EACZrF,QAAQ,GAkBHkR,GAAY,CAACjV,EAA6BgV,MAE/C,MAAM/U,OAAc+U,GAAuBhV,GAE3C,OAAO1D,EA/BK,YA+BiBiU,MAAAA,IAC5B,MAAMpQ,EAASD,EAAIE,aAEI,IAAnBH,EAAQ8D,QAcd,SAA0B7D,EAAeC,EAAgBF,GACxD,MAAMiV,EAAe,IAAIxV,IAAYQ,EAAII,UAAUqU,cAAcrL,IAAKtE,GAAMA,EAAEkH,WAE9EhM,EAAII,UAAUwC,aACZlC,QAAQ,CAACmC,EAAMoS,KACf,GAAI5P,MAAM6P,QAAQnV,EAAQ8D,UAAY9D,EAAQ8D,OAAOL,SAASX,EAAKyG,WAIlE,YAHArJ,EAAOY,mCACqBoU,gBAAwBpS,EAAKyG,eAK1DrJ,EAAOY,8CAA4CgC,EAAKyG,eAExD,MAAM9L,EAASwC,EAAImV,aAAatS,EAAKyG,WACnC8L,OAAOC,GAAgBxS,EAAKyG,WAAa,OAAQ0L,IAEnDnS,EAAKC,iBACHpC,QAAS6B,IACT,MAAM1E,EAAU0E,EAAUzE,aACtBD,GAASA,EAAQmS,UAAUxS,GAC/B+E,EAAUuB,iBACRpD,QAAS+B,GAAcA,EAAUuN,UAAUxS,IAC7C+E,EAAUwF,cACRrH,QAAS4U,IACTA,EAAWxR,iBACTpD,QAAS+B,GAAcA,EAAUuN,UAAUxS,UAxCpB+X,CAAgBvV,EAAKC,EAAQF,IAChC,IAAvBA,EAAQmJ,YA6Cd,SAA8BlJ,EAAeC,EAAgBF,GAC5D,MAAMiV,EAAe,IAAIxV,IAAYQ,EAAII,UAAUqU,cAAcrL,IAAKtE,GAAMA,EAAEkH,WAE9EhM,EAAII,UAAUE,iBACZI,QAAQ,CAAC0L,EAAMoJ,KACf,GAAInQ,MAAM6P,QAAQnV,EAAQmJ,cAAgBnJ,EAAQmJ,WAAW1F,SAAS4I,EAAK9C,WAI1E,YAHArJ,EAAOY,wCAC0B2U,gBAAwBpJ,EAAK9C,eAK/DrJ,EAAOY,mDAAiDuL,EAAK9C,eAE7D,MAAM9L,EAASwC,EAAImV,aAAa/I,EAAK9C,WACnC8L,OAAOC,GAAgBjJ,EAAK9C,WAAa,YAAa0L,IAExD5I,EAAKlI,eACHxD,QAASuD,IACT,MAAME,EAAQF,EAAQG,WAChBC,EAASJ,EAAQK,YACnBH,GAAOA,EAAM6L,UAAUxS,GACvB6G,GAAQA,EAAO2L,UAAUxS,OAnEEiY,CAAoBzV,EAAKC,EAAQF,GAE9DA,EAAQ8D,QAAW9D,EAAQmJ,YAC/BjJ,EAAOwQ,4EAGFzQ,EAAI0V,UAAU3B,GAAM,CAAC/Q,cAAe,CAACC,EAAa6Q,WAExD7T,EAAOY,iCAgET,SAASwU,GAAiBM,EAAkBC,GAC3C,IAAI7J,KAAS4J,QACTxY,EAAI,EACR,KAAOyY,EAAS3W,IAAI8M,IAAMA,KAAS4J,KAAYxY,UAC/C,OAAO4O,EC1FR,MAOM8J,GAAa,CAACC,UAAWC,WAAYC,aAErCC,YAAEA,GAAFC,SAAeA,GAAfC,MAAyBA,GAAzBC,QAAgCA,IAAYvB,EAAiBwB,WAC7DC,GAAe,CAACL,GAAaC,GAAUC,IAsBhCI,GAA+C,CAC3DtO,QAAS,KACTuO,mBAAoB,OACpBC,iBAAkB,GAClBC,eAAgB,GAChBC,iBAAkB,GAClBC,cAAe,EACfC,eAAgB,EAChBC,gBAAiB,IAeZC,GAAW,CAACjX,EAA4ByW,MAC7C,MAAMxW,OAAewW,GAAsBzW,GAE3C,OAAO1D,EA1DK,WA0DiBiU,MAAAA,IAC5B,MAAMpQ,EAASD,EAAIE,YACbC,EAAOH,EAAII,UAKjB,IAAI4W,EAHJhX,EAAIoI,gBAAgBC,GAAkB4O,aAAY,GAIf,UAA/BlX,EAAQyW,qBACXQ,EAAgBE,GA4SnB,SAAsBC,GACrB,MAAMC,EAASD,EAAO,GACtB,IAAK,MAAMrW,KAAQqW,EAClBlW,EAAImW,EAAOnW,IAAKmW,EAAOnW,IAAKH,EAAKG,KACjCD,EAAIoW,EAAOpW,IAAKoW,EAAOpW,IAAKF,EAAKE,KAElC,OAAOoW,EAlT4BC,CAAalX,EAAKyC,aAAawG,IAAIkO,OAIrE,IAAK,MAAMzU,KAAQ7C,EAAII,UAAUwC,aAAc,CACX,SAA/B7C,EAAQyW,qBACXQ,EAAgBE,GAAiBI,GAA8BzU,KAG5DmU,GAAiBjX,EAAQkI,QAAQM,KAAK,aACzCgP,GAAqBvX,EAAK6C,EAAMmU,GAGjC,IAAK,MAAMpZ,KAAQiF,EAAKC,iBAAkB,CACzC0U,GAAkBxX,EAAKpC,EAAMoZ,EAAgBjX,GAC7C,IAAK,MAAMnD,KAAUgB,EAAKmK,cACzByP,GAAkBxX,EAAKpD,EAAQoa,EAAgBjX,UAK5CC,EAAI0V,UACT3B,GAAM,CAAE/Q,cAAe,CAACC,EAAaC,SAAUD,EAAawQ,QAC5DnQ,EAAM,CAAEN,cAAe,CAACC,EAAaC,aAGtCjD,EAAOY,gCAIT,SAAS2W,GACRxX,EACApC,EACAoZ,EACAjX,GAEA,MAAME,EAASD,EAAIE,YAEnB,IAAK,MAAM0H,KAAYhK,EAAKiK,gBAAiB,CAC5C,IAAK9H,EAAQkI,QAAQM,KAAKX,GAAW,SAErC,MAAM6P,EAAe7Z,EAAKI,aAAa4J,IACjC8P,KAAEA,EAAFC,KAAQA,GAASC,GAAwBhQ,EAAU6P,EAAcxX,EAAQF,GAE/E,IAAK4X,EAAM,SACX,GAAID,EAAO,GAAKA,EAAO,GAAI,UAAU9Y,yCACrC,GAAI6Y,EAAajP,oBAAsBkP,EAAO,EAAG,SAEjD,MAAMG,EAAeJ,EAAaK,QAGlC,GAAiB,aAAblQ,EAAyB,CAC5B,MAAMmQ,EAAQf,EAAce,MACtBrC,EAAkB,GAExB9X,aAAgBM,EACb8Z,EAAOtC,EAAWuC,GAAcjB,IAChCkB,EAAYxC,EAAW,CAAC,EAAIqC,EAAO,EAAIA,EAAO,EAAIA,IACrD,IAAK,IAAI5a,EAAI,EAAG0L,EAAW,CAAC,EAAG,EAAG,GAAID,EAAKiP,EAAaxZ,WAAYlB,EAAIyL,EAAIzL,IAC3E0a,EAAanV,WAAWvF,EAAG0L,GAC3BgP,EAAalV,WAAWxF,EAAGgb,EAActP,EAAIA,EAAI6M,IAKnD0C,GAAkBP,EAAcF,EAAMD,GACtC9Z,EAAK8H,KAAK+R,EAAcI,GAQzB,GAJIja,EAAKI,aAAa,cA4PvB,SAA0BJ,GACzB,MAAMya,EAAcza,EAAKI,aAAa,YAAaK,WAC7Cia,EAAsB,GAE5B,IAAK,IAAInb,EAAI,EAAGA,EAAIkb,EAAalb,IAAK,CACrC,IAMIob,EANAC,EAAmB,EAEnBC,EAAcnM,SACdoM,GAAc,EACdC,EAAkC,KAGlCC,EAAiB,EAGrB,KAAQL,EAAU3a,EAAKI,wBAAwB4a,MAAsB,CACpEL,EAAQ7V,WAAWvF,EAAGmb,GACtB,IAAK,IAAIjb,EAAI,EAAGA,EAAIib,EAAU/X,OAAQlD,IACrCmb,GAAoBF,EAAUjb,GAC1Bib,EAAUjb,GAAK,GAAKib,EAAUjb,GAAKob,IACtCE,EAAiBJ,EACjBE,EAAcH,EAAUjb,GACxBqb,EAAarb,GAMZsb,GAAuC,IAArBH,IACrBG,EAAejW,WAAWvF,EAAGmb,GAC7BA,EAAUI,IAAe,EAAIF,EAC7BG,EAAehW,WAAWxF,EAAGmb,KA1R9BO,CAAiBjb,GAIjBA,aAAgBM,GAChBN,EAAKE,cACLF,EAAKkG,iBAAiBvD,QACtB3C,EAAKkG,iBAAiB,GAAIzF,WAAa,MACtC,CACD,MAAMR,EAAUD,EAAKE,aACrBD,EAAQiL,SAAS,IAAIgQ,YAAYjb,EAAQ+G,cAK3C,SAASsS,GAAiB6B,GACzB,MAAM9X,IAAEA,EAAFD,IAAOA,GAAQ+X,EAIfhB,EAAQ3V,KAAKpB,KACjBA,EAAI,GAAKC,EAAI,IAAM,GACnBD,EAAI,GAAKC,EAAI,IAAM,GACnBD,EAAI,GAAKC,EAAI,IAAM,GAUrB,MAAO,CAAEE,OANY,CACpBF,EAAI,IAAMD,EAAI,GAAKC,EAAI,IAAM,EAC7BA,EAAI,IAAMD,EAAI,GAAKC,EAAI,IAAM,EAC7BA,EAAI,IAAMD,EAAI,GAAKC,EAAI,IAAM,GAGb8W,MAAAA,GAIlB,SAASR,GAAqBvX,EAAe6C,EAAYmU,GACxD,MAAMgC,EAAkBf,GAAcjB,GACtC,IAAK,MAAMtQ,KAAU7D,EAAK4D,cACzB,GAAIC,aAAkBiJ,EAAM,CAC3B,MAAMsJ,EAAevS,EACnBD,cACAmD,OAAQgL,GAAMA,aAAaC,GACvBxU,EAAa4Y,EAAa/K,KAAMoG,GAAYgC,GAAa9S,SAAS8Q,EAAQ4E,kBAC1EC,EAAezS,EAAOnF,eAAehB,OAAS,EAEpD,GAAImG,EAAOyH,UAAW,CACrBzH,EAAO0S,QAAQC,GAAc3S,EAAOyH,UAAY6I,IAChD,SAGD,IAAIsC,EACAH,GAAgB9Y,GACnBiZ,EAAatZ,EAAIqB,WAAW,IAAIqN,QAAQ7L,GACxC6D,EAAOjF,SAAS6X,GAAY5K,QAAQ,MACpCuK,EACErP,OAAQ0K,GAAYA,EAAQ4E,kBAAoB9C,IAChD1V,QAAS4T,GAAYA,EAAQiF,cAAcD,KAE7CA,EAAa5S,EAGd,MAAM8S,EAAaF,EAAWG,YAC9BC,EAAaF,EAAYA,EAAYR,GACrCM,EAAWK,UAAUH,IAMxB,SAASH,GAAcO,EAAY5C,GAClC4C,EAAOA,EAAK9B,QACZ,MAAMkB,EAAkBf,GAAcjB,GAChC6C,EAAsBD,EAAKE,yBAA0BhC,QACrDiC,EAAM,GACZ,IAAK,IAAI5c,EAAI,EAAGyS,EAAQiK,EAAoBxb,WAAYlB,EAAIyS,EAAOzS,IAClE0c,EAAoBnX,WAAWvF,EAAG4c,GAClCL,EAAaK,EAAKA,EAAKf,GACvBa,EAAoBlX,WAAWxF,EAAG4c,GAEnC,OAAOH,EAAKI,uBAAuBH,GAWpC,SAASzB,GAAkB3V,EAAqBkV,EAA6BD,GAC5E,MAAMhP,EAAW,IAAIiP,EAAKlV,EAAUmC,WAAYrE,QAE1C0Z,EAAWpE,GAAWrS,SAASmU,GAAQ,EAAI,EAC3CuC,EAAYxC,EAAOuC,EACnBE,EAAuC,EAAzBxC,EAAKyC,kBAAwBH,EAE3ClC,EAAQ3V,KAAKC,IAAI,EAAG6X,GAAa,EACjCG,EAAKF,EAAcD,EACnBI,EAAK,EAAIJ,EAAYC,EAE3B,IAAK,IAAIhd,EAAI,EAAGod,EAAK,EAAG1R,EAAe,GAAI1L,EAAIsF,EAAUpE,WAAYlB,IAAK,CACzEsF,EAAUC,WAAWvF,EAAG0L,GACxB,IAAK,IAAIxL,EAAI,EAAGA,EAAIwL,EAAGtI,OAAQlD,IAAK,CAEnC,IAAIZ,EAAQ2F,KAAK2K,MAAM3K,KAAKoY,IAAI3R,EAAGxL,IAAM0a,GAGzCtb,EAASA,GAAS4d,EAAO5d,GAAS6d,EAGlC5R,EAAS6R,KAAQ9d,EAAQ2F,KAAKqY,KAAK5R,EAAGxL,KAIxCoF,EAAUqG,SAASJ,GAAUK,eAAc,GAG5C,SAAS6O,GACRhQ,EACAnF,EACAxC,EACAF,GAEA,MAAMkB,EAAMwB,EAAUiY,iBAAiB,IACjC1Z,EAAMyB,EAAUkY,iBAAiB,IAEvC,IAAIjD,EACAC,EAEJ,GAAiB,aAAb/P,EACH8P,EAAO3X,EAAQ0W,iBACfkB,EAAOD,GAAQ,EAAI5B,UAAYC,mBACR,WAAbnO,GAAsC,YAAbA,EACnC8P,EAAO3X,EAAQ2W,eACfiB,EAAOD,GAAQ,EAAI5B,UAAYC,mBACrBnO,EAASgT,WAAW,UAC9BlD,EAAO3X,EAAQ6W,cACfe,EAAOD,GAAQ,EAAIza,WAAa6b,oBACtBlR,EAASgT,WAAW,aAAc,CAC5C,GAAI3Z,EAAIiN,KAAM9O,GAAMA,EAAI,IAAM4B,EAAIkN,KAAM9O,GAAMA,EAAI,GAEjD,OADAa,EAAOwQ,2BAA0B7I,0BAC1B,CAAE8P,MAAO,GAEjBA,EAAO3X,EAAQ4W,iBACfgB,EAAOD,GAAQ,EAAIza,WAAa6b,oBACtBlR,EAASgT,WAAW,WAM9B,OALAlD,EAAOtV,KAAKpB,OAAOyB,EAAUgK,OAAO,MAAQ,IAAM,EAAI,GACtDkL,EAAOD,GAAQ,EAAIza,WAAa6b,YAC5BrW,EAAU+F,mBAAqBkP,EAAO,GACzCjV,EAAUqG,SAAS,IAAI6O,EAAKlV,EAAUmC,aAEhC,CAAE8S,MAAO,MACN9P,EAASgT,WAAW,YAAa,CAC3C,GAAI3Z,EAAIiN,KAAM9O,GAAMA,EAAI,IAAM4B,EAAIkN,KAAM9O,GAAMA,EAAI,GAEjD,OADAa,EAAOwQ,2BAA0B7I,0BAC1B,CAAE8P,MAAO,GAEjBA,EAAO3X,EAAQ8W,eACfc,EAAOD,GAAQ,EAAIza,WAAa6b,qBACtBlR,EAASgT,WAAW,KAU9B,UAAUhc,yCAAwCgJ,OATlD,GAAI3G,EAAIiN,KAAM9O,GAAMA,GAAK,IAAM4B,EAAIkN,KAAM9O,GAAMA,EAAI,GAElD,OADAa,EAAOwQ,2BAA0B7I,2BAC1B,CAAE8P,MAAO,GAEjBA,EAAO3X,EAAQ+W,gBACfa,EACIA,EADG1W,EAAIiN,KAAM9O,GAAMA,EAAI,GAChBsY,GAAQ,EAAI5B,UAAYC,WACxB2B,GAAQ,EAAIza,WAAa6b,aAKrC,MAAO,CAAEpB,KAAAA,EAAMC,KAAAA,GAGhB,SAASL,GAA8BzU,GACtC,MAAMgY,EAAwB,GACxBC,EAAgC,GACtC,IAAK,MAAMld,KAAQiF,EAAKC,iBAAkB,CACzC,MAAML,EAAY7E,EAAKI,aAAa,YAChCyE,GAAWoY,EAAUxU,KAAK5D,GAC9B,IAAK,MAAM7F,KAAUgB,EAAKmK,cAAe,CACxC,MAAMtF,EAAY7F,EAAOoB,aAAa,YAClCyE,GAAWqY,EAAkBzU,KAAK5D,IAIxC,GAAyB,IAArBoY,EAAUta,OACb,UAAU3B,iDAGX,MAAMkC,EAAOia,GAAiBF,EAAW,GAMzC,GAAIC,EAAkBva,OAAS,EAAG,CACjC,MAAQU,IAAK+Z,EAAQha,IAAKia,GAAWF,GAAiBD,EAAmB,GACzE7Z,EAAIH,EAAKG,IAAKH,EAAKG,IAAKA,EAAI+Z,EAAQjD,EAAMiD,EAAQA,EAAQ,GAAI,CAAC,EAAG,EAAG,KACrEha,EAAIF,EAAKE,IAAKF,EAAKE,IAAKA,EAAIia,EAAQlD,EAAMkD,EAAQA,EAAQ,GAAI,CAAC,EAAG,EAAG,KAGtE,OAAOna,EAIR,SAASia,GAA4BvW,EAAuB0W,GAC3D,MAAMja,EAAgB,IAAIoE,MAAM6V,GAAaC,KAAK7O,UAC5CtL,EAAgB,IAAIqE,MAAM6V,GAAaC,MAAM7O,UAE7C8O,EAAmB,GACnBC,EAAmB,GAEzB,IAAK,MAAMtX,KAAYS,EAAW,CACjCT,EAAS2W,iBAAiBU,GAC1BrX,EAAS4W,iBAAiBU,GAC1B,IAAK,IAAIle,EAAI,EAAGA,EAAI+d,EAAa/d,IAChC8D,EAAI9D,GAAKiF,KAAKnB,IAAIA,EAAI9D,GAAIie,EAAOje,IACjC6D,EAAI7D,GAAKiF,KAAKpB,IAAIA,EAAI7D,GAAIke,EAAOle,IAInC,MAAO,CAAE8D,IAAAA,EAAKD,IAAAA,GAiBf,SAASiX,GAAcvC,GACtB,OAAO4F,EAA6B,GAAuB,CAAC,EAAG,EAAG,EAAG,GAAI5F,EAAUvU,OAAQ,CAC1FuU,EAAUqC,MACVrC,EAAUqC,MACVrC,EAAUqC,QCvZZ,MAIMwD,GAAgD,CAACC,UAAW,MASrDC,GAAW,CAAC3b,EAA4Byb,MAEpD,MAAMxb,OAAcwb,GAAsBzb,GAE1C,OAAO1D,EAjBK,WAiBiB,CAAC4D,EAAe0b,KAC5C,MAAMC,EAAmB,IAAInc,IACvBoc,EAAqB5b,EAAII,UAAU0F,gBAAgBvF,OACnDN,EAASD,EAAIE,YAEnB,IAAI2b,GAAsB,EAE1B,IAAK,MAAM7X,KAAahE,EAAII,UAAUE,iBAAkB,CAEvD,MAAMwb,EAAsB,IAAItc,IAChC,IAAK,MAAM8U,KAAWtQ,EAAU4I,eAC3B0H,EAAQyH,cAA4C,YAA5BzH,EAAQ4E,iBACnC4C,EAAoB3c,IAAImV,EAAQyH,cAIlC,IAAK,MAAM9X,KAAWD,EAAUE,eAC3B4X,EAAoB7c,IAAIgF,GAC3B4X,GAAsB,EAGY,SAA/B5X,EAAQ+X,oBACuB,WAA/B/X,EAAQ+X,qBACXL,EAAiBxc,IAAI8E,EAAQG,YAC7BuX,EAAiBxc,IAAI8E,EAAQK,aAC7B2X,GAAShY,EAASlE,IAKrB,IAAK,MAAMgE,KAAYsB,MAAMC,KAAKqW,EAAiBO,UACrCnY,EAAS0C,cAAcyH,KAAM0G,KAAQA,aAAarN,KACpDxD,EAAS4B,UAGjB3F,EAAII,UAAU0F,gBAAgBvF,OAASqb,aXzCVF,EAAuCS,EAAiBC,GAC1F,QAAKV,GACgBA,EAAQW,MAAMC,YWuC4D1a,YXtC1E8Z,EAAQW,MAAMC,YWsCkE,SAAlCC,CAAmBb,IACpFzb,EAAOwQ,gJAMJoL,GACH5b,EAAOwQ,gFAGRxQ,EAAOY,gCAKT,SAASob,GAAUhY,EAA2BlE,GAC7C,MAAMoE,EAAQF,EAAQG,WAAY0T,QAC5BzT,EAASJ,EAAQK,YAAawT,QAE9B0D,EAAYzb,EAAQyb,UAEpBgB,EAAYrY,EAAM9F,WAAa,EAC/Boe,EAAgB,GAEtB,IAAIC,EAAa,EAEjB,IAAK,IAAIvf,EAAI,EAAGA,EAAIqf,IAAcrf,EAAG,CACpC,MAAMwf,EAAOxY,EAAMyY,UAAUzf,GACvB0f,EAAW1Y,EAAMyY,UAAUzf,EAAI,GAC/B2f,EAAW3Y,EAAMyY,UAAUzf,EAAI,GAC/B4f,GAAWJ,EAAOE,IAAaC,EAAWD,GAEhD,IAAIG,GAAO,EAGX,GAAIL,IAASG,IAAmB,IAAN3f,GAAWwf,IAASxY,EAAMyY,UAAU,IAC7D,IAAK,IAAIvf,EAAI,EAAGA,EAAIgH,EAAO4Y,iBAAkB5f,IAAK,CACjD,MAAMZ,EAAQ4H,EAAO3B,WAAWvF,EAAGsf,GAAKpf,GAClC6f,EAAY7Y,EAAO3B,WAAWvF,EAAI,EAAGsf,GAAKpf,GAC1C8f,EAAY9Y,EAAO3B,WAAWvF,EAAI,EAAGsf,GAAKpf,GAEhD,GAAmC,WAA/B4G,EAAQ+X,oBAEX,GAAI5Z,KAAKoY,IAAI/d,GAAaygB,GA6Cd,GADsBxb,EA5Ccqb,IAAXI,EA6CXzb,IA7CkC8Z,EAAW,CACtEwB,GAAO,EACP,eAEwC,SAA/B/Y,EAAQ+X,qBAEdvf,IAAUygB,GAAazgB,IAAU0gB,GAAW,CAC/CH,GAAO,EACP,OAOAA,IACC7f,IAAMuf,IACTvY,EAAMiZ,UAAUV,EAAYvY,EAAMyY,UAAUzf,IAC5CkH,EAAO1B,WAAW+Z,EAAYrY,EAAO3B,WAAWvF,EAAGsf,KAEpDC,KAwBH,IAAuChb,EAlBlC8a,EAAY,IACfrY,EAAMiZ,UAAUV,EAAYvY,EAAMyY,UAAUJ,IAC5CnY,EAAO1B,WAAW+Z,EAAYrY,EAAO3B,WAAW8Z,EAAWC,IAC3DC,KAIGA,IAAevY,EAAM9F,YACxB8F,EAAM2E,SAAS3E,EAAMS,WAAYC,MAAM,EAAG6X,IAC1CrY,EAAOyE,SAASzE,EAAOO,WAAYC,MAAM,EAAG6X,EAAarY,EAAO4Y,mBAChEhZ,EAAQoZ,SAASlZ,GACjBF,EAAQqZ,UAAUjZ,KAElBF,EAAMwB,UACNtB,EAAOsB,WCtIT,MAaM4X,GAA8D,CACnE3gB,OAAQ,iBAyBO4gB,GAAS1d,EAA2Byd,IACnD,MAAMxd,OAAcwd,GAAqBzd,GACnC2d,EAAU1d,EAAQ0d,QAExB,OAAOrhB,EA3CK,UA2CiBiU,MAAAA,IAC5B,MAAMpQ,EAASD,EAAIE,kBAEbud,EAAQC,MAEd,MAAMC,EAoER,SAA8B3d,GAC7B,MAAM4d,EAAsB,IAAI/e,EAC1Bgf,EAAgB,IAAI9e,IACpB+e,EAAyB,IAAIjf,EAEnC,IAAK,MAAMgE,KAAQ7C,EAAII,UAAUwC,aAChC,IAAK,MAAMhF,KAAQiF,EAAKC,iBAAkB,CACzC,MAAMjF,EAAUD,EAAKE,aACrB,GAAKD,EAAL,CAEAggB,EAAcpe,IAAI5B,EAASD,EAAKK,WAEhC,IAAK,MAAMwE,KAAaqB,GAAelG,GACtCggB,EAAoBze,IAAItB,EAAS4E,GACjCqb,EAAuB3e,IAAIsD,EAAW7E,IAKzC,MAAO,CAACggB,oBAAAA,EAAqBC,cAAAA,EAAeC,uBAAAA,GAvF9BC,CAAqB/d,GAElC,IAAK,MAAMge,KAAcL,EAAKC,oBAAoBle,OAAQ,CACzD,MAAMue,EAAaD,EAAWlG,QAC9B,IAAIoG,EAAeD,EAAWrZ,WAAYC,QACpCqZ,aAAwBC,cAC7BD,EAAe,IAAIC,YAAYD,IAIhC,MAAOE,EAAOC,GAAUZ,EAAQa,YAC/BJ,EACAP,EAAKE,cAActe,IAAIye,KAAgB9f,EAAUC,KAAKM,UACnC,SAAnBsB,EAAQnD,QAGTqhB,EAAWnV,SAASuV,GAAU,MAAQ,IAAIvF,YAAYoF,GAAgBA,GAGtE,IAAK,MAAMzG,KAAgBkG,EAAKC,oBAAoBre,IAAIye,GAAa,CACpE,MAAMnG,EAAeJ,EAAaK,QAClCyG,GAAe1G,EAAcuG,EAAOC,GACpC,IAAK,MAAMzgB,KAAQ+f,EAAKG,uBAAuBve,IAAIkY,GAIlD,GAHI7Z,EAAKE,eAAiBkgB,GACzBpgB,EAAK8H,KAAKsY,EAAYC,GAEnBrgB,EAAKE,eAAiBmgB,EAAY,CACrCrgB,EAAK8H,KAAK+R,EAAcI,GACxB,IAAK,MAAMjb,KAAUgB,EAAKmK,cACzBnL,EAAO8I,KAAK+R,EAAcI,WAQzB7X,EAAI0V,UAAU3B,GAAM,CAAC/Q,cAAe,CAACC,EAAaC,aAEnDya,EAAKC,oBAAoB5e,KAG7BiB,EAAOY,4BAFPZ,EAAOwQ,2EAOV,SAAS8N,GAAe9b,EAAqB2b,EAAoBI,GAChE,MAAMtD,EAAczY,EAAUwa,iBACxBwB,EAAWhc,EAAUpE,WACrBoK,EAAWhG,EAAUmC,WACrB8D,EAAWD,EAAS5D,MAAM,EAAG2Z,EAAWtD,GAE9C,IAAK,IAAI/d,EAAI,EAAGA,EAAIshB,EAAUthB,IAC7B,IAAK,IAAIE,EAAI,EAAGA,EAAI6d,EAAa7d,IAChCqL,EAAS0V,EAAMjhB,GAAK+d,EAAc7d,GAAKoL,EAAStL,EAAI+d,EAAc7d,GAIpEoF,EAAUqG,SAASJ,GA+BpB,SAAS5E,GAAelG,GACvB,MAAM4G,EAAwB,GAE9B,IAAK,MAAM/B,KAAa7E,EAAKkG,iBAC5BU,EAAU6B,KAAK5D,GAEhB,IAAK,MAAM7F,KAAUgB,EAAKmK,cACzB,IAAK,MAAMtF,KAAa7F,EAAOkH,iBAC9BU,EAAU6B,KAAK5D,GAIjB,OAAO4C,MAAMC,KAAK,IAAI9F,IAAIgF,ICxJ3B,MAaMka,GAA+C,CACpDriB,KAAM,GACNsiB,IAAK,GACL1W,QAAS,KACT0C,MAAM,YAMSiU,GAAU9e,EAA4B4e,IACrD,MAAM3e,OAAc2e,GAAsB5e,GAE1C,OAAO1D,EA1BK,WA0BkB4D,IAE7B,MAAMC,EAASD,EAAIE,YACbC,EAAOH,EAAII,UACXue,EAAM5e,EAAQ4e,IAGdE,EAAgB1e,EAAK+T,YACzBtK,OAAQkE,GAASA,EAAKxE,UAAUwV,MAAM/e,EAAQkI,UAG5ClI,EAAQ4K,MACXkU,EAAclU,KAAK,CAACjG,EAAGI,IAAMJ,EAAE4E,UAAYxE,EAAEwE,UAAY,GAAK,GAI/D,MAAM8C,EAAOpM,EAAI+e,gBAAgBhf,EAAQ1D,MACnC2iB,EAAa7e,EAAKsU,cAAc,GACtCoK,EAAcne,QAAQ,CAACoN,EAAM3Q,KAE5B,IAAI8hB,EACAC,EACM,IAAN/hB,GACH8hB,EAAa,CAAC9hB,EAAIwhB,GAAMxhB,EAAI,GAAKwhB,GACjCO,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IACpB/hB,IAAM0hB,EAActe,OAAS,GACvC0e,EAAa,EAAE9hB,EAAI,GAAKwhB,EAAKxhB,EAAIwhB,GACjCO,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,KAE9BD,EAAa,EAAE9hB,EAAI,GAAKwhB,EAAKxhB,EAAIwhB,GAAMxhB,EAAI,GAAKwhB,GAChDO,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAIxC,MAAM/a,EAAQnE,EAAI8P,iBAChBhH,SAAS,IAAIH,aAAasW,IAC1BjP,UAAUgP,GACN3a,EAASrE,EAAI8P,iBACjBhH,SAAS,IAAIH,aAAauW,IAC1BlP,UAAUgP,GACVjP,QAAQoP,EAASC,KAAKC,MAClBpb,EAAUjE,EAAIsf,yBAClBC,iBAAiBC,EAAiBC,cAAcC,MAChDrC,SAASlZ,GACTmZ,UAAUjZ,GACNiQ,EAAUtU,EAAI2f,yBAClBpG,cAAczL,GACd8R,cAAc/K,EAAiBwB,WAAWF,OAC1C0J,WAAW5b,GACbmI,EAAK0T,WAAW7b,GAAS8b,WAAWzL,KAGrCrU,EAAOY,+BC9ET,MAeMmf,GAAyE,CAC9EC,WAAW,YAmBIC,GAAUpgB,EAA4BkgB,IACrD,IAAKlgB,EAASqgB,iBACb,UAAUvhB,8EAGX,MAAMmB,OAAcigB,GAAsBlgB,GAE1C,OAAO1D,EA1CK,WA0CkB4D,IAC7B,MAAMC,EAASD,EAAIE,YACbkgB,EAAe,IAAIrhB,IACnBshB,EAAe,IAAIthB,IACzB,IAAIuhB,EAAW,EAEf,IAAK,MAAMzd,KAAQ7C,EAAII,UAAUwC,aAAc,CAC9C,MAAM2d,EAAW1d,EAAKyG,UAChBkX,EAAiB3d,EAAKC,iBAE5B,IAAK,IAAI3F,EAAI,EAAGA,EAAIqjB,EAAejgB,OAAQpD,IAAK,CAC/C,MAAMS,EAAO4iB,EAAerjB,GAG5B,IAAKsjB,GAAgB7iB,EAAMqC,EAAQsgB,EAAUpjB,EAAG4C,EAAQkgB,WAAY,SAEpE,MAAMS,EAAmBC,GAAkB/iB,GAGrCG,EAAWH,EAAKI,aAAa,YAAa4G,WAC1Cgc,EAAShjB,EAAKI,aAAa,UAAW4G,WACtCic,EAAWjjB,EAAKI,aAAa0iB,GAAmB9b,WAGhDkc,EAAaV,EAAa7gB,IAAIxB,IAAagjB,IACjDX,EAAa3gB,IAAI1B,EAAU+iB,GAE3B,MAAME,EAAWZ,EAAa7gB,IAAIqhB,IAAWG,IAC7CX,EAAa3gB,IAAImhB,EAAQI,GAEzB,MAAMC,EAAab,EAAa7gB,IAAIshB,IAAaE,IACjDX,EAAa3gB,IAAIohB,EAAUI,GAG3B,MAAMC,EAActjB,EAAKI,aAAa,WAClCkjB,GAAoD,IAArCA,EAAYza,cAAclG,QAAc2gB,EAAYvb,UAGvE,MAAMwb,KAAmBL,KAAcE,KAAYC,IACnD,IAAIG,EAAUf,EAAa9gB,IAAI4hB,GAC/B,GAAIC,EAAS,CACZnhB,EAAOY,6CAA4C1D,cAAcojB,OACjE3iB,EAAKsS,aAAa,UAAWkR,GAC7Bd,IACA,SAIDrgB,EAAOY,4CAA2C1D,cAAcojB,OAChE,MAAMc,EAAgBzjB,EAAKI,aAAa,YAAa6R,YAC/CyR,EAAevhB,EAAQogB,iBAC5BpiB,aAAoB4K,aAAe5K,EAAW,IAAI4K,aAAa5K,GAC/D6iB,aAAkBjY,aAAeiY,EAAS,IAAIjY,aAAaiY,GAC3DC,aAAoBlY,aAAekY,EAAW,IAAIlY,aAAakY,IAIhE,IAAK,IAAI1jB,EAAI,EAAGA,EAAImkB,EAAa/gB,OAAQpD,GAAK,EAAGmkB,EAAankB,KAAO,EAErEikB,EAAUphB,EAAI8P,iBACZE,UAAUqR,GACVvY,SAASwY,GACTvR,QAAQ,QACVnS,EAAKsS,aAAa,UAAWkR,GAE7Bf,EAAa5gB,IAAI0hB,EAAeC,GAChCd,KAIGA,EAGJrgB,EAAOY,6BAFPZ,EAAOwQ,sEAOV,SAASkQ,GAAkB/iB,GAC1B,MAAMoI,EAAWpI,EAAKkK,cACtB,IAAK9B,EAAU,MAAO,aAEtB,MAAMub,EAAoBvb,EAASwb,uBACnC,IAAKD,EAAmB,MAAO,aAE/B,MACM3Z,cADW2Z,EAAkBE,gBAEnC,OAAI7jB,EAAKI,aAAa4J,GAAkBA,EAEjC,aAGR,SAAS6Y,GACP7iB,EACAqC,EACAsgB,EACApjB,EACA8iB,GAED,OAAIriB,EAAKK,YAAcC,EAAUC,KAAKM,WAChCb,EAAKI,aAAa,aAClBJ,EAAKI,aAAa,WAClBJ,EAAKI,aAAa,cAQpBJ,EAAKI,aAAa,aAAeiiB,GACpChgB,EAAOY,sCACyB1D,cAAcojB,2BAK3C3iB,EAAKE,eAERmC,EAAOwQ,qCACyBtT,cAAcojB,yCAjB9CtgB,EAAOY,sCACyB1D,cAAcojB,8FC/IhD,MAAM3e,GAAO,gBAiBD8f,IAAAA,IAAZ,SAAYA,GAEXA,sBAEAA,sBAJD,CAAYA,KAAAA,QAOCC,MAAAA,GAAgD,CAC5D3iB,KAAM,CAAC,KAAM,MACb4K,OAAQ8X,GAAoBE,SAC5B3Z,QAAS,eAOM4Z,GAAc/hB,EAAiC6hB,IAC9D,MAAM5hB,OAAc4hB,GAA4B7hB,GAEhD,OAAO1D,EAAgBwF,GAAMyO,MAAAA,IAE5B,MAAMpQ,EAASD,EAAIE,YAEnB,IAAK,MAAMyL,KAAW3L,EAAII,UAAU0G,eAAgB,CACnD,MAAMzK,EAAOsP,EAAQrC,UACfyC,EAAMJ,EAAQK,SAIpB,GAHejM,EAAQkI,UACnBlI,EAAQkI,QAAQM,KAAKlM,KACrB0D,EAAQkI,QAAQM,KAAKwD,GACb,SAEZ,GAA8B,cAA1BJ,EAAQzO,eAA2D,eAA1ByO,EAAQzO,cAAgC,CACpF+C,EAAOwQ,4CAA4C9E,EAAQzO,mBAC3D,SAGD,MAAO4kB,EAAUC,GAAahiB,EAAQf,MAC/BgjB,EAAUC,GAAatW,EAAQzE,UAEtC,GAAI8a,GAAYF,GAAYG,GAAaF,EAAW,CACnD9hB,EAAOY,SAASe,iBAAmBmK,GAAO1P,0BAC1C,SAGD,IAAI6lB,EAAWF,EACXG,EAAYF,EAEZC,EAAWJ,IACdK,EAAY/f,KAAKggB,MAAMD,GAAaL,EAAWI,IAC/CA,EAAWJ,GAGRK,EAAYJ,IACfG,EAAW9f,KAAKggB,MAAMF,GAAYH,EAAYI,IAC9CA,EAAYJ,GAGb,MAAMllB,EAAW,IAAII,WAAW0O,EAAQ7O,YAClCulB,QAAkBrlB,EAAUH,EAAU8O,EAAQzO,eAC9ColB,EAAYC,EACjB,IAAItlB,WAAWilB,EAAWC,EAAY,GAAI,CAACD,EAAUC,EAAW,IAGjEliB,EAAOY,SACHe,iBAAmBmK,GAAO1P,OAAUgmB,EAAUjlB,WAAWklB,EAAUllB,YAGvE,IACC2C,EAAQ6J,SAAW8X,GAAoBE,SACpCY,EAASH,EAAWC,GACpBG,EAASJ,EAAWC,GACtB,MAAOI,GACR,GAAIA,aAAa9jB,MAAO,CACvBqB,EAAOwQ,QAAQ7O,yBAA2BmK,GAAO1P,QAAWqmB,EAAEC,aAC9D,SAED,MAAMD,EAGP/W,EAAQlO,gBAAgBF,EAAW+kB,EAAW3W,EAAQzO,gBAAgBM,QAGvEyC,EAAOY,SAASe,mBCvGlB,MAMMghB,GAAiC,YASvBC,GAAQ/iB,EAA0B8iB,IAIjD,YAFoBA,GAAoB9iB,GAEjC1D,EAnBK,SAmBkB4D,IAE7B,MAAMC,EAASD,EAAIE,YACb4iB,EAAU,IAAI/jB,IAEpB,IAAK,MAAM8D,KAAQ7C,EAAII,UAAUwC,aAChC,IAAK,MAAMhF,KAAQiF,EAAKC,iBAAkB,CACzC,MAAMjF,EAAUD,EAAKE,aACrB,GAAKD,EAAL,CAGA,IAAK,MAAM4Z,KAAgB7Z,EAAKkG,iBAC/BlG,EAAK8H,KACJ+R,EACAsL,GAAgBtL,EAAc5Z,EAASoC,EAAQ6iB,IAIN,IAAtCrL,EAAahR,cAAclG,QAAckX,EAAa9R,UAI3D,IAAK,MAAM/I,KAAUgB,EAAKmK,cACzB,IAAK,MAAM0P,KAAgB7a,EAAOkH,iBACjClH,EAAO8I,KACN+R,EACAsL,GAAgBtL,EAAc5Z,EAASoC,EAAQ6iB,IAIN,IAAtCrL,EAAahR,cAAclG,QAAckX,EAAa9R,UAK5D/H,EAAKolB,WAAW,MACqB,IAAjCnlB,EAAQ4I,cAAclG,QAAc1C,EAAQ8H,WAIlD1F,EAAOY,6BAIT,SAASkiB,GACPtL,EACA5Z,EACAoC,EACA6iB,GACD,GAAIA,EAAQ7jB,IAAIwY,IAAiBqL,EAAQvjB,IAAIkY,GAAexY,IAAIpB,GAE/D,OADAoC,EAAOY,kDAAmD4W,EAAanO,eAChEwZ,EAAQvjB,IAAIkY,GAAelY,IAAI1B,GAGvC,MAAMga,EAAeJ,EAAaK,QAC5BmL,EAAYxL,EAAa7S,WAAYuI,YAE3C0K,EAAa/O,SACZ,IAAIma,EAAUplB,EAAQQ,WAAaoZ,EAAawF,mBAGjD,MAAMpU,EAAe,GACrB,IAAK,IAAI1L,EAAI,EAAGA,EAAIU,EAAQQ,WAAYlB,IACvC0a,EAAalV,WAAWxF,EAAGsa,EAAa/U,WAAW7E,EAAQ+e,UAAUzf,GAAI0L,IAM1E,OAHKia,EAAQ7jB,IAAIwY,IAAeqL,EAAQrjB,IAAIgY,EAAc,IAAI1Y,KAC9D+jB,EAAQvjB,IAAIkY,GAAehY,IAAI5B,EAASga,GAEjCA,ECxFR,MAQMqL,GAAuC,CAAC1H,UAAW,eAKzC2H,GAAMrjB,EAAwBojB,IAC7C,MAAMnjB,OAAcmjB,GAAkBpjB,GAEtC,OAAO1D,EAhBK,OAgBkB4D,IAC7B,MAAMC,EAASD,EAAIE,YAEnB,IAAK,MAAM2C,KAAQ7C,EAAII,UAAUwC,aAChC,IAAK,MAAMhF,KAAQiF,EAAKC,iBACG,IAAtB/C,EAAQyb,UACX4H,GAASpjB,EAAKpC,GAEdylB,GAAarjB,EAAKpC,EAAMmC,GAK3BE,EAAOY,2BAKT,SAASuiB,GAAUpjB,EAAepC,GACjC,GAAIA,EAAKE,aAAc,OACvB,MAAMoM,EAAOtM,EAAKkG,iBAAiB,GAC7Bwf,EAAcpZ,EAAK7L,WACnBb,EAAS0M,EAAK2F,YACdqO,EAAeoF,GAAe,MACjC,IAAIxK,YAAwC,EAA5Bnb,EAAoBC,IACpC,IAAIugB,YAAwC,EAA5BxgB,EAAoBC,IACjCC,EAAUmC,EAAI8P,iBAClBE,UAAUxS,GACVuS,QAAQoP,EAASC,KAAKmE,QACtBza,SAASoV,GACX,IAAK,IAAI/gB,EAAI,EAAGA,EAAIU,EAAQQ,WAAYlB,IAAKU,EAAQuf,UAAUjgB,EAAGA,GAClES,EAAKolB,WAAWnlB,GAOjB,SAASwlB,GAAcrjB,EAAepC,EAAiBmC,GACtD,MAAMyb,EAAYpZ,KAAKpB,IAAIjB,EAAQyb,UAAWvO,OAAOuW,SAC/CC,EAAerhB,KAAKshB,MAAM,EAAIlI,GAC9BmI,EAAcvhB,KAAKC,IAAI,GAAIohB,GAE3BG,EAAuC,GACvC5F,EAAapgB,EAAKE,aAClBua,EAAc2F,EACjBA,EAAW3f,WACXT,EAAKkG,iBAAiB,GAAGzF,WAGtBwlB,EAAgB,IAAI9kB,IAC1BnB,EAAKkG,iBAAiBpD,QAASwJ,GAAS2Z,EAAcpkB,IAAIyK,EAAM,KAChEtM,EAAKmK,cAAcrH,QAAS9D,IAC3BA,EAAOkH,iBAAiBpD,QAASwJ,GAAS2Z,EAAcpkB,IAAIyK,EAAM,OAGnE,MAAM4Z,EAAkB,GACxB,IAAIC,EAAY,EAIhB,IAAK,IAAI5mB,EAAI,EAAGA,EAAIkb,EAAalb,IAAK,CACrC,MAAMyD,EAAQod,EAAaA,EAAWpB,UAAUzf,GAAKA,EAE/C6mB,EAAyB,GACzBnb,EAAe,GACrB,IAAK,MAAMpG,KAAa7E,EAAKkG,iBAC5B,IAAK,IAAIzG,EAAI,EAAGA,EAAIoF,EAAUwa,iBAAkB5f,IAC/C2mB,EAAa3d,QAAU5D,EAAUC,WAAW9B,EAAOiI,GAAIxL,GAAKsmB,IAI9D,MAAMM,EAAOD,EAAa9iB,KAAK,KAC/B,GAAI+iB,KAAQL,EACXE,EAAgBzd,KAAKud,EAAYK,QAC3B,CACN,IAAK,MAAM/Z,KAAQtM,EAAKkG,iBACvB+f,EAActkB,IAAI2K,GAAO7D,KAAK6D,EAAKxH,WAAW9B,EAAO,KAEtD,IAAK,MAAMhE,KAAUgB,EAAKmK,cACzB,IAAK,MAAMmC,KAAQtN,EAAOkH,iBACzB+f,EAActkB,IAAI2K,GAAO7D,KAAK6D,EAAKxH,WAAW9B,EAAO,KAIvDgjB,EAAYK,GAAQF,EACpBD,EAAgBzd,KAAK0d,GACrBA,KAIF,MAAMG,EAAiBtmB,EAAKkG,iBAAiB,GAAGzF,WAC1C8lB,EAAiBN,EAActkB,IAAI3B,EAAKI,aAAa,aAAeuC,OAC1EP,EAAIE,YAAYW,eAAkBqjB,OAAoBC,eAGtD,IAAK,MAAMC,KAAWxmB,EAAKkG,iBAC1BugB,GAAezmB,EAAMwmB,EAASP,EAActkB,IAAI6kB,IAGX,IAAjCA,EAAQ3d,cAAclG,QAAc6jB,EAAQze,UAEjD,IAAK,MAAM/I,KAAUgB,EAAKmK,cACzB,IAAK,MAAMqc,KAAWxnB,EAAOkH,iBAC5BugB,GAAeznB,EAAQwnB,EAASP,EAActkB,IAAI6kB,IAGb,IAAjCA,EAAQ3d,cAAclG,QAAc6jB,EAAQze,UAGlD,GAAIqY,EAAY,CACf,MAAMsG,EACHC,GAAkBvG,EAAWpZ,WAAakf,EAAgBvjB,QAC7D+jB,EAAqB7kB,IAAIqkB,GACzBlmB,EAAKolB,WAAWhF,EAAWlG,QAAQhP,SAASwb,IAGJ,IAApCtG,EAAWvX,cAAclG,QAAcyd,EAAWrY,cAChD,CACN,MAAMuY,EAAegG,GAAkB,MACpC,IAAIpL,YAAYgL,GAChB,IAAI3F,YAAY2F,GACnBlmB,EAAKolB,WAAWhjB,EAAI8P,iBAAiBhH,SAASoV,KAKhD,SAASqG,GAAwCrX,EAAU3M,GAE1D,WAAW0iB,EADO/V,EAAMC,aACH5M,GAItB,SAAS8jB,GACP3d,EACA0d,EACAI,GACD,MAAMC,EAAqBD,EAAgBjkB,OAAS6jB,EAAQnH,iBACtDyH,EAAeH,GAAkBH,EAAQxf,WAAa6f,GACtDE,EAAUP,EAAQtM,QAAQhP,SAAS4b,GAEzC,IAAK,IAAIvnB,EAAI,EAAGA,EAAIqnB,EAAgBjkB,OAAQpD,IAC3CwnB,EAAQhiB,WAAWxF,EAAGqnB,EAAgBrnB,IAGvCuJ,EAAOhB,KAAK0e,EAASO"}